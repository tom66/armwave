   1              		.arch armv6
   2              		.eabi_attribute 28, 1	@ Tag_ABI_VFP_args
   3              		.eabi_attribute 20, 1	@ Tag_ABI_FP_denormal
   4              		.eabi_attribute 21, 1	@ Tag_ABI_FP_exceptions
   5              		.eabi_attribute 23, 3	@ Tag_ABI_FP_number_model
   6              		.eabi_attribute 24, 1	@ Tag_ABI_align8_needed
   7              		.eabi_attribute 25, 1	@ Tag_ABI_align8_preserved
   8              		.eabi_attribute 26, 2	@ Tag_ABI_enum_size
   9              		.eabi_attribute 30, 2	@ Tag_ABI_optimization_goals
  10              		.eabi_attribute 34, 1	@ Tag_CPU_unaligned_access
  11              		.eabi_attribute 18, 4	@ Tag_ABI_PCS_wchar_t
  12              		.file	"armwave.c"
  13              	@ GNU C17 (Raspbian 8.3.0-6+rpi1) version 8.3.0 (arm-linux-gnueabihf)
  14              	@	compiled by GNU C version 8.3.0, GMP version 6.1.2, MPFR version 4.0.2, MPC version 1.1.0, isl ve
  15              	
  16              	@ GGC heuristics: --param ggc-min-expand=81 --param ggc-min-heapsize=95638
  17              	@ options passed:  -I /usr/local/include/python3.8 -imultilib .
  18              	@ -imultiarch arm-linux-gnueabihf armwave.c -mfloat-abi=hard -mfpu=vfp
  19              	@ -mtls-dialect=gnu -marm -march=armv6+fp -auxbase-strip armwave.s -g -O3
  20              	@ -fverbose-asm -fwrapv
  21              	@ options enabled:  -faggressive-loop-optimizations -falign-jumps
  22              	@ -falign-labels -falign-loops -fauto-inc-dec -fbranch-count-reg
  23              	@ -fcaller-saves -fchkp-check-incomplete-type -fchkp-check-read
  24              	@ -fchkp-check-write -fchkp-instrument-calls -fchkp-narrow-bounds
  25              	@ -fchkp-optimize -fchkp-store-bounds -fchkp-use-static-bounds
  26              	@ -fchkp-use-static-const-bounds -fchkp-use-wrappers -fcode-hoisting
  27              	@ -fcombine-stack-adjustments -fcommon -fcompare-elim -fcprop-registers
  28              	@ -fcrossjumping -fcse-follow-jumps -fdefer-pop
  29              	@ -fdelete-null-pointer-checks -fdevirtualize -fdevirtualize-speculatively
  30              	@ -fdwarf2-cfi-asm -fearly-inlining -feliminate-unused-debug-types
  31              	@ -fexpensive-optimizations -fforward-propagate -ffp-int-builtin-inexact
  32              	@ -ffunction-cse -fgcse -fgcse-after-reload -fgcse-lm -fgnu-runtime
  33              	@ -fgnu-unique -fguess-branch-probability -fhoist-adjacent-loads -fident
  34              	@ -fif-conversion -fif-conversion2 -findirect-inlining -finline
  35              	@ -finline-atomics -finline-functions -finline-functions-called-once
  36              	@ -finline-small-functions -fipa-bit-cp -fipa-cp -fipa-cp-clone -fipa-icf
  37              	@ -fipa-icf-functions -fipa-icf-variables -fipa-profile -fipa-pure-const
  38              	@ -fipa-ra -fipa-reference -fipa-sra -fipa-vrp -fira-hoist-pressure
  39              	@ -fira-share-save-slots -fira-share-spill-slots
  40              	@ -fisolate-erroneous-paths-dereference -fivopts -fkeep-static-consts
  41              	@ -fleading-underscore -flifetime-dse -floop-interchange
  42              	@ -floop-unroll-and-jam -flra-remat -flto-odr-type-merging -fmath-errno
  43              	@ -fmerge-constants -fmerge-debug-strings -fmove-loop-invariants
  44              	@ -fomit-frame-pointer -foptimize-sibling-calls -foptimize-strlen
  45              	@ -fpartial-inlining -fpeel-loops -fpeephole -fpeephole2 -fplt
  46              	@ -fpredictive-commoning -fprefetch-loop-arrays -freg-struct-return
  47              	@ -freorder-blocks -freorder-functions -frerun-cse-after-loop
  48              	@ -fsched-critical-path-heuristic -fsched-dep-count-heuristic
  49              	@ -fsched-group-heuristic -fsched-interblock -fsched-last-insn-heuristic
  50              	@ -fsched-pressure -fsched-rank-heuristic -fsched-spec
  51              	@ -fsched-spec-insn-heuristic -fsched-stalled-insns-dep -fschedule-insns
  52              	@ -fschedule-insns2 -fsection-anchors -fsemantic-interposition
  53              	@ -fshow-column -fshrink-wrap -fshrink-wrap-separate -fsigned-zeros
  54              	@ -fsplit-ivs-in-unroller -fsplit-loops -fsplit-paths -fsplit-wide-types
  55              	@ -fssa-backprop -fssa-phiopt -fstdarg-opt -fstore-merging
  56              	@ -fstrict-aliasing -fstrict-volatile-bitfields -fsync-libcalls
  57              	@ -fthread-jumps -ftoplevel-reorder -ftrapping-math -ftree-bit-ccp
  58              	@ -ftree-builtin-call-dce -ftree-ccp -ftree-ch -ftree-coalesce-vars
  59              	@ -ftree-copy-prop -ftree-cselim -ftree-dce -ftree-dominator-opts
  60              	@ -ftree-dse -ftree-forwprop -ftree-fre -ftree-loop-distribute-patterns
  61              	@ -ftree-loop-distribution -ftree-loop-if-convert -ftree-loop-im
  62              	@ -ftree-loop-ivcanon -ftree-loop-optimize -ftree-loop-vectorize
  63              	@ -ftree-parallelize-loops= -ftree-partial-pre -ftree-phiprop -ftree-pre
  64              	@ -ftree-pta -ftree-reassoc -ftree-scev-cprop -ftree-sink
  65              	@ -ftree-slp-vectorize -ftree-slsr -ftree-sra -ftree-switch-conversion
  66              	@ -ftree-tail-merge -ftree-ter -ftree-vrp -funit-at-a-time -funswitch-loops
  67              	@ -fvar-tracking -fvar-tracking-assignments -fverbose-asm -fwrapv
  68              	@ -fzero-initialized-in-bss -marm -mbe32 -mglibc -mlittle-endian
  69              	@ -mpic-data-is-text-relative -msched-prolog -munaligned-access
  70              	@ -mvectorize-with-neon-quad
  71              	
  72              		.text
  73              	.Ltext0:
  74              		.cfi_sections	.debug_frame
  75              		.align	2
  76              		.global	test_create_gamma
  77              		.arch armv6
  78              		.syntax unified
  79              		.arm
  80              		.fpu vfp
  82              	test_create_gamma:
  83              	.LFB57:
  84              		.file 1 "armwave.c"
   1:armwave.c     **** /*
   2:armwave.c     ****  * This file is part of YAOS and is licenced under the MIT Licence.
   3:armwave.c     ****  *
   4:armwave.c     ****  * armwave: an ARM-optimised waveform rendering engine for the Raspberry Pi 3.  
   5:armwave.c     ****  * This library attempts to use NEON tricks and architectural features of the Pi's
   6:armwave.c     ****  * processor to render waveforms damn quickly.
   7:armwave.c     ****  */
   8:armwave.c     **** 
   9:armwave.c     **** #define _GNU_SOURCE
  10:armwave.c     **** 
  11:armwave.c     **** #include <Python.h>
  12:armwave.c     **** 
  13:armwave.c     **** #include <assert.h>
  14:armwave.c     **** #include <ctype.h>
  15:armwave.c     **** #include <stdio.h>
  16:armwave.c     **** #include <stdint.h>
  17:armwave.c     **** #include <stdlib.h>
  18:armwave.c     **** #include <stdbool.h>
  19:armwave.c     **** #include <malloc.h>
  20:armwave.c     **** #include <string.h>
  21:armwave.c     **** #include <math.h>
  22:armwave.c     **** 
  23:armwave.c     **** #include "armwave.h"
  24:armwave.c     **** 
  25:armwave.c     **** #define TEST_NWAVES                 64
  26:armwave.c     **** #define TEST_WAVE_SIZE              2048
  27:armwave.c     **** 
  28:armwave.c     **** #define ARMWAVE_VER                 "v0.0.1"
  29:armwave.c     **** 
  30:armwave.c     **** #define MAX(a,b)                    ((a) > (b) ? (a) : (b))
  31:armwave.c     **** #define MIN(a,b)                    ((a) < (b) ? (a) : (b))
  32:armwave.c     **** 
  33:armwave.c     **** #define CLAMP(x,mi,mx)              MIN(MAX((x),mi),mx)
  34:armwave.c     **** 
  35:armwave.c     **** #define COND_UNLIKELY(expr)         __builtin_expect((expr), 0)
  36:armwave.c     **** #define COND_LIKELY(expr)           __builtin_expect((expr), 1)
  37:armwave.c     **** 
  38:armwave.c     **** struct armwave_state_t g_armwave_state;
  39:armwave.c     **** 
  40:armwave.c     **** uint8_t gamma_table[256];
  41:armwave.c     **** 
  42:armwave.c     **** /*
  43:armwave.c     ****  * Create a gamma table.
  44:armwave.c     ****  */
  45:armwave.c     **** void test_create_gamma()
  46:armwave.c     **** {
  85              		.loc 1 46 1 view -0
  86              		.cfi_startproc
  87              		@ args = 0, pretend = 0, frame = 0
  88              		@ frame_needed = 0, uses_anonymous_args = 0
  47:armwave.c     ****     int i;
  89              		.loc 1 47 5 view .LVU1
  48:armwave.c     ****     float gamma = 0.90f;
  90              		.loc 1 48 5 view .LVU2
  91              	.LVL0:
  49:armwave.c     **** 
  50:armwave.c     ****     for(i = 0; i < 256; i++) {
  92              		.loc 1 50 5 view .LVU3
  93              	@ armwave.c:46: {
  46:armwave.c     ****     int i;
  94              		.loc 1 46 1 is_stmt 0 view .LVU4
  95 0000 70402DE9 		push	{r4, r5, r6, lr}	@
  96              		.cfi_def_cfa_offset 16
  97              		.cfi_offset 4, -16
  98              		.cfi_offset 5, -12
  99              		.cfi_offset 6, -8
 100              		.cfi_offset 14, -4
 101 0004 068B2DED 		vpush.64	{d8, d9, d10}	@
 102              		.cfi_def_cfa_offset 40
 103              		.cfi_offset 80, -40
 104              		.cfi_offset 81, -36
 105              		.cfi_offset 82, -32
 106              		.cfi_offset 83, -28
 107              		.cfi_offset 84, -24
 108              		.cfi_offset 85, -20
 109 0008 64409FE5 		ldr	r4, .L6+20	@ ivtmp.41,
 110              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  51:armwave.c     ****         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 111              		.loc 1 51 32 view .LVU5
 112 000c 17AA9FED 		vldr.32	s20, .L6+16	@ tmp128,
 113              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 114              		.loc 1 51 26 view .LVU6
 115 0010 129B9FED 		vldr.64	d9, .L6	@ tmp135,
 116              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 117              		.loc 1 51 49 view .LVU7
 118 0014 138B9FED 		vldr.64	d8, .L6+8	@ tmp131,
 119 0018 015084E2 		add	r5, r4, #1	@ _25, ivtmp.41,
 120 001c 016C84E2 		add	r6, r4, #256	@ _26, ivtmp.41,
 121 0020 015065E2 		rsb	r5, r5, #1	@ tmp134, _25,
 122              	.LVL1:
 123              	.L2:
 124              		.loc 1 51 9 is_stmt 1 discriminator 3 view .LVU8
 125              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 126              		.loc 1 51 32 is_stmt 0 discriminator 3 view .LVU9
 127 0024 043085E0 		add	r3, r5, r4	@ tmp125, tmp134, ivtmp.41
 128              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 129              		.loc 1 51 26 discriminator 3 view .LVU10
 130 0028 491BB0EE 		vmov.f64	d1, d9	@, tmp135
 131              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 132              		.loc 1 51 32 discriminator 3 view .LVU11
 133 002c 903A07EE 		vmov	s15, r3	@ int	@ tmp125, tmp125
 134 0030 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp126, tmp125
 135 0034 8A0A87EE 		vdiv.f32	s0, s15, s20	@ tmp127, tmp126, tmp128
 136              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 137              		.loc 1 51 26 discriminator 3 view .LVU12
 138 0038 C00AB7EE 		vcvt.f64.f32	d0, s0	@, tmp127
 139 003c FEFFFFEB 		bl	pow		@
 140              	.LVL2:
 141              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 142              		.loc 1 51 49 discriminator 3 view .LVU13
 143 0040 080B20EE 		vmul.f64	d0, d0, d8	@ tmp130,, tmp131
 144              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 145              		.loc 1 51 24 discriminator 3 view .LVU14
 146 0044 C07BFCEE 		vcvt.u32.f64	s15, d0	@ tmp132, tmp130
 147 0048 903A17EE 		vmov	r3, s15	@ int	@ tmp132, tmp132
 148 004c 0130E4E5 		strb	r3, [r4, #1]!	@ tmp132, MEM[base: _24, offset: 0B]
 149              	.LVL3:
 150              	@ armwave.c:50:     for(i = 0; i < 256; i++) {
  50:armwave.c     ****         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 151              		.loc 1 50 5 discriminator 3 view .LVU15
 152 0050 060054E1 		cmp	r4, r6	@ ivtmp.41, _26
 153 0054 F2FFFF1A 		bne	.L2		@,
 154              	@ armwave.c:53: }
  52:armwave.c     ****     }
  53:armwave.c     **** }
 155              		.loc 1 53 1 view .LVU16
 156 0058 068BBDEC 		vldm	sp!, {d8-d10}	@,
 157              		.cfi_restore 84
 158              		.cfi_restore 85
 159              		.cfi_restore 82
 160              		.cfi_restore 83
 161              		.cfi_restore 80
 162              		.cfi_restore 81
 163              		.cfi_def_cfa_offset 16
 164 005c 7080BDE8 		pop	{r4, r5, r6, pc}	@
 165              	.LVL4:
 166              	.L7:
 167              		.loc 1 53 1 view .LVU17
 168              		.align	3
 169              	.L6:
 170 0060 000000C0 		.word	-1073741824
 171 0064 CCCCEC3F 		.word	1072483532
 172 0068 00000000 		.word	0
 173 006c 00E06F40 		.word	1081073664
 174 0070 00007F43 		.word	1132396544
 175 0074 FFFFFFFF 		.word	gamma_table-1
 176              		.cfi_endproc
 177              	.LFE57:
 179              		.align	2
 180              		.global	armwave_init
 181              		.syntax unified
 182              		.arm
 183              		.fpu vfp
 185              	armwave_init:
 186              	.LFB58:
  54:armwave.c     **** 
  55:armwave.c     **** /*
  56:armwave.c     ****  * Initialise things.  STUB, mostly.
  57:armwave.c     ****  */
  58:armwave.c     **** void armwave_init()
  59:armwave.c     **** {
 187              		.loc 1 59 1 is_stmt 1 view -0
 188              		.cfi_startproc
 189              		@ args = 0, pretend = 0, frame = 0
 190              		@ frame_needed = 0, uses_anonymous_args = 0
 191              		@ link register save eliminated.
  60:armwave.c     ****     g_armwave_state.flags = 0;
 192              		.loc 1 60 5 view .LVU19
 193              	@ armwave.c:60:     g_armwave_state.flags = 0;
 194              		.loc 1 60 27 is_stmt 0 view .LVU20
 195 0078 10309FE5 		ldr	r3, .L9	@ tmp110,
 196 007c 0020A0E3 		mov	r2, #0	@ tmp111,
 197              	@ armwave.c:62:     printf("armwave version: %s\n", ARMWAVE_VER);
  61:armwave.c     **** 
  62:armwave.c     ****     printf("armwave version: %s\n", ARMWAVE_VER);
 198              		.loc 1 62 5 view .LVU21
 199 0080 0C109FE5 		ldr	r1, .L9+4	@,
 200 0084 0C009FE5 		ldr	r0, .L9+8	@,
 201              	@ armwave.c:60:     g_armwave_state.flags = 0;
  60:armwave.c     ****     g_armwave_state.flags = 0;
 202              		.loc 1 60 27 view .LVU22
 203 0088 002083E5 		str	r2, [r3]	@ tmp111, g_armwave_state.flags
 204              		.loc 1 62 5 is_stmt 1 view .LVU23
 205 008c FEFFFFEA 		b	printf		@
 206              	.LVL5:
 207              	.L10:
 208              		.align	2
 209              	.L9:
 210 0090 00000000 		.word	g_armwave_state
 211 0094 00000000 		.word	.LC0
 212 0098 08000000 		.word	.LC1
 213              		.cfi_endproc
 214              	.LFE58:
 216              		.align	2
 217              		.global	render_nonaa_to_buffer_1ch_slice
 218              		.syntax unified
 219              		.arm
 220              		.fpu vfp
 222              	render_nonaa_to_buffer_1ch_slice:
 223              	.LVL6:
 224              	.LFB59:
  63:armwave.c     **** }
  64:armwave.c     **** 
  65:armwave.c     **** /*
  66:armwave.c     ****  * 1ch renderer, renders up to slice-height buffer with X-coord of each waveaccess
  67:armwave.c     ****  * pre-computed.
  68:armwave.c     ****  *
  69:armwave.c     ****  * @param    slice_y        Slice to render at
  70:armwave.c     ****  * @param    height         Number of wave points to render (adjust for performance, 
  71:armwave.c     ****  *                          accounting for cache behaviour, etc.)
  72:armwave.c     ****  */
  73:armwave.c     **** void render_nonaa_to_buffer_1ch_slice(uint32_t slice_y, uint32_t height)
  74:armwave.c     **** {
 225              		.loc 1 74 1 view -0
 226              		.cfi_startproc
 227              		@ args = 0, pretend = 0, frame = 0
 228              		@ frame_needed = 0, uses_anonymous_args = 0
  75:armwave.c     ****     int yy, ys, w, scale_value;
 229              		.loc 1 75 5 view .LVU25
  76:armwave.c     ****     uint32_t value, word;
 230              		.loc 1 76 5 view .LVU26
  77:armwave.c     ****     uint8_t *wave_base;
 231              		.loc 1 77 5 view .LVU27
  78:armwave.c     ****     uint8_t *write_buffer_base;
 232              		.loc 1 78 5 view .LVU28
  79:armwave.c     ****     uint8_t *write_buffer;
 233              		.loc 1 79 5 view .LVU29
  80:armwave.c     **** 
  81:armwave.c     ****     //printf("ch1_buffer=0x%08x\n", g_armwave_state.ch1_buffer);
  82:armwave.c     ****     write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.bitdepth_height);
 234              		.loc 1 82 5 view .LVU30
 235              	@ armwave.c:74: {
  74:armwave.c     ****     int yy, ys, w, scale_value;
 236              		.loc 1 74 1 is_stmt 0 view .LVU31
 237 009c F04F2DE9 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}	@
 238              		.cfi_def_cfa_offset 36
 239              		.cfi_offset 4, -36
 240              		.cfi_offset 5, -32
 241              		.cfi_offset 6, -28
 242              		.cfi_offset 7, -24
 243              		.cfi_offset 8, -20
 244              		.cfi_offset 9, -16
 245              		.cfi_offset 10, -12
 246              		.cfi_offset 11, -8
 247              		.cfi_offset 14, -4
 248              	@ armwave.c:82:     write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.bit
 249              		.loc 1 82 40 view .LVU32
 250 00a0 E0409FE5 		ldr	r4, .L24	@ tmp246,
 251              	@ armwave.c:85:     for(w = 0; w < g_armwave_state.waves; w++) {
  83:armwave.c     **** 
  84:armwave.c     ****     // roll through each waveform
  85:armwave.c     ****     for(w = 0; w < g_armwave_state.waves; w++) {
 252              		.loc 1 85 35 view .LVU33
 253 00a4 2CC094E5 		ldr	ip, [r4, #44]	@ prephitmp_41, g_armwave_state.waves
 254              	@ armwave.c:82:     write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.bit
  82:armwave.c     **** 
 255              		.loc 1 82 63 view .LVU34
 256 00a8 345094E5 		ldr	r5, [r4, #52]	@ g_armwave_state.bitdepth_height, g_armwave_state.bitdepth_height
 257              	@ armwave.c:85:     for(w = 0; w < g_armwave_state.waves; w++) {
 258              		.loc 1 85 5 view .LVU35
 259 00ac 00005CE3 		cmp	ip, #0	@ prephitmp_41,
 260              	@ armwave.c:82:     write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.bit
  82:armwave.c     **** 
 261              		.loc 1 82 40 view .LVU36
 262 00b0 043094E5 		ldr	r3, [r4, #4]	@ _1, g_armwave_state.ch1_buffer
 263              	@ armwave.c:82:     write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.bit
  82:armwave.c     **** 
 264              		.loc 1 82 63 view .LVU37
 265 00b4 950005E0 		mul	r5, r5, r0	@ _3, g_armwave_state.bitdepth_height, slice_y
 266              	.LVL7:
 267              		.loc 1 85 5 is_stmt 1 view .LVU38
 268              		.loc 1 85 5 is_stmt 0 view .LVU39
 269 00b8 F08FBD08 		popeq	{r4, r5, r6, r7, r8, r9, r10, fp, pc}	@
 270 00bc 049040E2 		sub	r9, r0, #4	@ _62, slice_y,
 271              	@ armwave.c:99:                 if(COND_UNLIKELY(value == 0x00 || value == 0xff))
  86:armwave.c     ****         //printf("wave_buffer=0x%08x\n", g_armwave_state.wave_buffer);
  87:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
  88:armwave.c     **** 
  89:armwave.c     ****         // roll through y and render the slice into the out buffer
  90:armwave.c     ****         // buffer is rendered rotated by 90 degrees
  91:armwave.c     ****         for(yy = 0; yy < height; yy += 4) {
  92:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
  93:armwave.c     **** 
  94:armwave.c     ****             for(ys = 0; ys < 4; ys++) {
  95:armwave.c     ****                 //printf("write %d,%d ht %d\n", yy, ys, g_armwave_state.bitdepth_height);
  96:armwave.c     ****                 scale_value = (word & 0xff);
  97:armwave.c     ****                 
  98:armwave.c     ****                 // prevents saturating behaviour; we lose two ADC counts.
  99:armwave.c     ****                 if(COND_UNLIKELY(value == 0x00 || value == 0xff))
 272              		.loc 1 99 20 view .LVU40
 273 00c0 0180A0E3 		mov	r8, #1	@ _58,
 274              	@ armwave.c:85:     for(w = 0; w < g_armwave_state.waves; w++) {
  85:armwave.c     ****         //printf("wave_buffer=0x%08x\n", g_armwave_state.wave_buffer);
 275              		.loc 1 85 11 view .LVU41
 276 00c4 0070A0E3 		mov	r7, #0	@ w,
 277              	.LVL8:
 278              	.L16:
  87:armwave.c     **** 
 279              		.loc 1 87 9 is_stmt 1 view .LVU42
 280              	@ armwave.c:87:         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wa
  87:armwave.c     **** 
 281              		.loc 1 87 64 is_stmt 0 view .LVU43
 282 00c8 282094E5 		ldr	r2, [r4, #40]	@ g_armwave_state.wave_stride, g_armwave_state.wave_stride
 283              	@ armwave.c:91:         for(yy = 0; yy < height; yy += 4) {
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 284              		.loc 1 91 9 view .LVU44
 285 00cc 000051E3 		cmp	r1, #0	@ height,
 286              	@ armwave.c:87:         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wa
  87:armwave.c     **** 
 287              		.loc 1 87 36 view .LVU45
 288 00d0 146094E5 		ldr	r6, [r4, #20]	@ _4, g_armwave_state.wave_buffer
 289              	@ armwave.c:87:         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wa
  87:armwave.c     **** 
 290              		.loc 1 87 64 view .LVU46
 291 00d4 920702E0 		mul	r2, r2, r7	@ _7, g_armwave_state.wave_stride, w
 292              	.LVL9:
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 293              		.loc 1 91 9 is_stmt 1 view .LVU47
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 294              		.loc 1 91 9 is_stmt 0 view .LVU48
 295 00d8 2600000A 		beq	.L13		@,
 296 00dc 000058E3 		cmp	r8, #0	@ _58,
 297 00e0 2300001A 		bne	.L14		@,
 298 00e4 092082E0 		add	r2, r2, r9	@ tmp198, _7, _62
 299              	.LVL10:
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 300              		.loc 1 91 9 view .LVU49
 301 00e8 026086E0 		add	r6, r6, r2	@ ivtmp.48, _4, tmp198
 302              	.LVL11:
 303              	@ armwave.c:91:         for(yy = 0; yy < height; yy += 4) {
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 304              		.loc 1 91 16 view .LVU50
 305 00ec 0820A0E1 		mov	r2, r8	@ yy, _58
 306              	.LVL12:
 307              	.L15:
  92:armwave.c     **** 
 308              		.loc 1 92 13 is_stmt 1 view .LVU51
 309              	@ armwave.c:92:             word = *(uint32_t*)(wave_base + yy);
  92:armwave.c     **** 
 310              		.loc 1 92 18 is_stmt 0 view .LVU52
 311 00f0 0400B6E5 		ldr	r0, [r6, #4]!	@ word, MEM[base: _43, offset: 0B]
 312              	.LVL13:
  94:armwave.c     ****                 //printf("write %d,%d ht %d\n", yy, ys, g_armwave_state.bitdepth_height);
 313              		.loc 1 94 13 is_stmt 1 view .LVU53
  96:armwave.c     ****                 
 314              		.loc 1 96 17 view .LVU54
 315              		.loc 1 99 17 view .LVU55
 100:armwave.c     ****                     continue;
 101:armwave.c     **** 
 102:armwave.c     ****                 write_buffer = write_buffer_base + ((yy + ys) * g_armwave_state.bitdepth_height);
 316              		.loc 1 102 17 view .LVU56
 103:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 317              		.loc 1 103 17 view .LVU57
 318              	@ armwave.c:102:                 write_buffer = write_buffer_base + ((yy + ys) * g_armwave_state.bi
 102:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 319              		.loc 1 102 63 is_stmt 0 view .LVU58
 320 00f4 34E094E5 		ldr	lr, [r4, #52]	@ g_armwave_state.bitdepth_height, g_armwave_state.bitdepth_height
 321 00f8 01B082E2 		add	fp, r2, #1	@ tmp209, yy,
 322              	@ armwave.c:103:                 *(write_buffer + scale_value) += 1;
 323              		.loc 1 103 47 view .LVU59
 324 00fc 70C0E5E6 		uxtab	ip, r5, r0	@ tmp203, _3, word
 325 0100 9EC22EE0 		mla	lr, lr, r2, ip	@ tmp204, g_armwave_state.bitdepth_height, yy, tmp203
 326              	@ armwave.c:104:                 word >>= 8;
 104:armwave.c     ****                 word >>= 8;
 327              		.loc 1 104 22 view .LVU60
 328 0104 20A4A0E1 		lsr	r10, r0, #8	@ word, word,
 329              	@ armwave.c:103:                 *(write_buffer + scale_value) += 1;
 103:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 330              		.loc 1 103 47 view .LVU61
 331 0108 0EC0D3E7 		ldrb	ip, [r3, lr]	@ zero_extendqisi2	@ *_86, *_86
 332 010c 7AA0E5E6 		uxtab	r10, r5, r10	@ tmp215, _3, word
 333 0110 01C08CE2 		add	ip, ip, #1	@ tmp207, *_86,
 334 0114 0EC0C3E7 		strb	ip, [r3, lr]	@ tmp207, *_86
 335              	.LVL14:
 336              		.loc 1 104 17 is_stmt 1 view .LVU62
  96:armwave.c     ****                 
 337              		.loc 1 96 17 view .LVU63
  99:armwave.c     ****                     continue;
 338              		.loc 1 99 17 view .LVU64
 102:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 339              		.loc 1 102 17 view .LVU65
 103:armwave.c     ****                 word >>= 8;
 340              		.loc 1 103 17 view .LVU66
 341              	@ armwave.c:102:                 write_buffer = write_buffer_base + ((yy + ys) * g_armwave_state.bi
 102:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 342              		.loc 1 102 63 is_stmt 0 view .LVU67
 343 0118 34C094E5 		ldr	ip, [r4, #52]	@ g_armwave_state.bitdepth_height, g_armwave_state.bitdepth_height
 344              	@ armwave.c:104:                 word >>= 8;
 345              		.loc 1 104 22 view .LVU68
 346 011c 20E8A0E1 		lsr	lr, r0, #16	@ word, word,
 347              	@ armwave.c:103:                 *(write_buffer + scale_value) += 1;
 103:armwave.c     ****                 word >>= 8;
 348              		.loc 1 103 47 view .LVU69
 349 0120 200C85E0 		add	r0, r5, r0, lsr #24	@ tmp238, _3, word,
 350              	.LVL15:
 103:armwave.c     ****                 word >>= 8;
 351              		.loc 1 103 47 view .LVU70
 352 0124 9CAB2CE0 		mla	ip, ip, fp, r10	@ tmp216, g_armwave_state.bitdepth_height, tmp209, tmp215
 353 0128 7EA0E5E6 		uxtab	r10, r5, lr	@ tmp227, _3, word
 354 012c 0CB0D3E7 		ldrb	fp, [r3, ip]	@ zero_extendqisi2	@ *_36, *_36
 355              	@ armwave.c:102:                 write_buffer = write_buffer_base + ((yy + ys) * g_armwave_state.bi
 102:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 356              		.loc 1 102 63 view .LVU71
 357 0130 02E082E2 		add	lr, r2, #2	@ tmp222, yy,
 358              	@ armwave.c:103:                 *(write_buffer + scale_value) += 1;
 103:armwave.c     ****                 word >>= 8;
 359              		.loc 1 103 47 view .LVU72
 360 0134 01B08BE2 		add	fp, fp, #1	@ tmp219, *_36,
 361 0138 0CB0C3E7 		strb	fp, [r3, ip]	@ tmp219, *_36
 362              	.LVL16:
 363              		.loc 1 104 17 is_stmt 1 view .LVU73
  96:armwave.c     ****                 
 364              		.loc 1 96 17 view .LVU74
  99:armwave.c     ****                     continue;
 365              		.loc 1 99 17 view .LVU75
 102:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 366              		.loc 1 102 17 view .LVU76
 103:armwave.c     ****                 word >>= 8;
 367              		.loc 1 103 17 view .LVU77
 368              	@ armwave.c:102:                 write_buffer = write_buffer_base + ((yy + ys) * g_armwave_state.bi
 102:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 369              		.loc 1 102 63 is_stmt 0 view .LVU78
 370 013c 34B094E5 		ldr	fp, [r4, #52]	@ g_armwave_state.bitdepth_height, g_armwave_state.bitdepth_height
 371 0140 03C082E2 		add	ip, r2, #3	@ tmp234, yy,
 372              	@ armwave.c:91:         for(yy = 0; yy < height; yy += 4) {
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 373              		.loc 1 91 37 view .LVU79
 374 0144 042082E2 		add	r2, r2, #4	@ yy, yy,
 375              	.LVL17:
 376              	@ armwave.c:103:                 *(write_buffer + scale_value) += 1;
 103:armwave.c     ****                 word >>= 8;
 377              		.loc 1 103 47 view .LVU80
 378 0148 9BAE2EE0 		mla	lr, fp, lr, r10	@ tmp228, g_armwave_state.bitdepth_height, tmp222, tmp227
 379              	@ armwave.c:91:         for(yy = 0; yy < height; yy += 4) {
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 380              		.loc 1 91 9 view .LVU81
 381 014c 020051E1 		cmp	r1, r2	@ height, yy
 382              	@ armwave.c:103:                 *(write_buffer + scale_value) += 1;
 103:armwave.c     ****                 word >>= 8;
 383              		.loc 1 103 47 view .LVU82
 384 0150 0EA0D3E7 		ldrb	r10, [r3, lr]	@ zero_extendqisi2	@ *_80, *_80
 385 0154 01A08AE2 		add	r10, r10, #1	@ tmp231, *_80,
 386 0158 0EA0C3E7 		strb	r10, [r3, lr]	@ tmp231, *_80
 387              	.LVL18:
 388              		.loc 1 104 17 is_stmt 1 view .LVU83
  96:armwave.c     ****                 
 389              		.loc 1 96 17 view .LVU84
  99:armwave.c     ****                     continue;
 390              		.loc 1 99 17 view .LVU85
 102:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 391              		.loc 1 102 17 view .LVU86
 103:armwave.c     ****                 word >>= 8;
 392              		.loc 1 103 17 view .LVU87
 393              	@ armwave.c:102:                 write_buffer = write_buffer_base + ((yy + ys) * g_armwave_state.bi
 102:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 394              		.loc 1 102 63 is_stmt 0 view .LVU88
 395 015c 34E094E5 		ldr	lr, [r4, #52]	@ g_armwave_state.bitdepth_height, g_armwave_state.bitdepth_height
 396              	@ armwave.c:103:                 *(write_buffer + scale_value) += 1;
 103:armwave.c     ****                 word >>= 8;
 397              		.loc 1 103 47 view .LVU89
 398 0160 9E0C20E0 		mla	r0, lr, ip, r0	@ tmp239, g_armwave_state.bitdepth_height, tmp234, tmp238
 399 0164 00C0D3E7 		ldrb	ip, [r3, r0]	@ zero_extendqisi2	@ *_158, *_158
 400 0168 01C08CE2 		add	ip, ip, #1	@ tmp242, *_158,
 401 016c 00C0C3E7 		strb	ip, [r3, r0]	@ tmp242, *_158
 402              		.loc 1 104 17 is_stmt 1 view .LVU90
 403              	.LVL19:
 404              	@ armwave.c:91:         for(yy = 0; yy < height; yy += 4) {
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 405              		.loc 1 91 9 is_stmt 0 view .LVU91
 406 0170 DEFFFF8A 		bhi	.L15		@,
 407              	.LVL20:
 408              	.L14:
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 409              		.loc 1 91 9 view .LVU92
 410 0174 2CC094E5 		ldr	ip, [r4, #44]	@ prephitmp_41, g_armwave_state.waves
 411              	.L13:
 412              	@ armwave.c:85:     for(w = 0; w < g_armwave_state.waves; w++) {
  85:armwave.c     ****         //printf("wave_buffer=0x%08x\n", g_armwave_state.wave_buffer);
 413              		.loc 1 85 44 discriminator 2 view .LVU93
 414 0178 017087E2 		add	r7, r7, #1	@ w, w,
 415              	.LVL21:
 416              	@ armwave.c:85:     for(w = 0; w < g_armwave_state.waves; w++) {
  85:armwave.c     ****         //printf("wave_buffer=0x%08x\n", g_armwave_state.wave_buffer);
 417              		.loc 1 85 5 discriminator 2 view .LVU94
 418 017c 07005CE1 		cmp	ip, r7	@ prephitmp_41, w
 419 0180 D0FFFF8A 		bhi	.L16		@,
 420 0184 F08FBDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}	@
 421              	.L25:
 422              		.align	2
 423              	.L24:
 424 0188 00000000 		.word	g_armwave_state
 425              		.cfi_endproc
 426              	.LFE59:
 428              		.align	2
 429              		.global	armwave_fill_pixbuf_256
 430              		.syntax unified
 431              		.arm
 432              		.fpu vfp
 434              	armwave_fill_pixbuf_256:
 435              	.LVL22:
 436              	.LFB60:
 105:armwave.c     ****             }
 106:armwave.c     ****         }
 107:armwave.c     ****     }
 108:armwave.c     **** }
 109:armwave.c     **** 
 110:armwave.c     **** /*
 111:armwave.c     ****  * Fill a pixbuf with a 256-height waveform.
 112:armwave.c     ****  */
 113:armwave.c     **** void armwave_fill_pixbuf_256(uint32_t *out_buffer)
 114:armwave.c     **** {
 437              		.loc 1 114 1 is_stmt 1 view -0
 438              		.cfi_startproc
 439              		@ args = 0, pretend = 0, frame = 8
 440              		@ frame_needed = 0, uses_anonymous_args = 0
 115:armwave.c     ****     uint32_t xx, yy, word, wave_word;
 441              		.loc 1 115 5 view .LVU96
 116:armwave.c     ****     int rr, gg, bb, n, nsub, npix, i;
 442              		.loc 1 116 5 view .LVU97
 117:armwave.c     ****     uint8_t r, g, b, value;
 443              		.loc 1 117 5 view .LVU98
 118:armwave.c     ****     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 444              		.loc 1 118 5 view .LVU99
 445              	@ armwave.c:114: {
 114:armwave.c     ****     uint32_t xx, yy, word, wave_word;
 446              		.loc 1 114 1 is_stmt 0 view .LVU100
 447 018c F04F2DE9 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}	@
 448              		.cfi_def_cfa_offset 36
 449              		.cfi_offset 4, -36
 450              		.cfi_offset 5, -32
 451              		.cfi_offset 6, -28
 452              		.cfi_offset 7, -24
 453              		.cfi_offset 8, -20
 454              		.cfi_offset 9, -16
 455              		.cfi_offset 10, -12
 456              		.cfi_offset 11, -8
 457              		.cfi_offset 14, -4
 458              	@ armwave.c:122:     assert(out_buffer != NULL);
 119:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 120:armwave.c     ****     uint32_t offset;
 121:armwave.c     **** 
 122:armwave.c     ****     assert(out_buffer != NULL);
 459              		.loc 1 122 5 view .LVU101
 460 0190 000050E3 		cmp	r0, #0	@ out_buffer
 461              	@ armwave.c:118:     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 118:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 462              		.loc 1 118 15 view .LVU102
 463 0194 44529FE5 		ldr	r5, .L53	@ tmp360,
 464              	@ armwave.c:114: {
 114:armwave.c     ****     uint32_t xx, yy, word, wave_word;
 465              		.loc 1 114 1 view .LVU103
 466 0198 0CD04DE2 		sub	sp, sp, #12	@,,
 467              		.cfi_def_cfa_offset 48
 468              	@ armwave.c:118:     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 118:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 469              		.loc 1 118 15 view .LVU104
 470 019c 041095E5 		ldr	r1, [r5, #4]	@ base_32ptr, g_armwave_state.ch1_buffer
 471              	.LVL23:
 119:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 472              		.loc 1 119 5 is_stmt 1 view .LVU105
 120:armwave.c     **** 
 473              		.loc 1 120 5 view .LVU106
 474              		.loc 1 122 5 view .LVU107
 475 01a0 8900000A 		beq	.L51		@,
 123:armwave.c     **** 
 124:armwave.c     ****     // Buffer is sent non-rotated: we use GDK/GL to assemble and rotate it
 125:armwave.c     **** 
 126:armwave.c     ****     npix = g_armwave_state.target_width * 256;
 476              		.loc 1 126 5 view .LVU108
 477              	@ armwave.c:126:     npix = g_armwave_state.target_width * 256;
 478              		.loc 1 126 41 is_stmt 0 view .LVU109
 479 01a4 4CC095E5 		ldr	ip, [r5, #76]	@ g_armwave_state.target_width, g_armwave_state.target_width
 480 01a8 0CC4A0E1 		lsl	ip, ip, #8	@ npix, g_armwave_state.target_width,
 481              	.LVL24:
 127:armwave.c     **** 
 128:armwave.c     ****     for(n = 0; n < npix; n += 4) {
 482              		.loc 1 128 5 is_stmt 1 view .LVU110
 483              		.loc 1 128 5 is_stmt 0 view .LVU111
 484 01ac 00005CE3 		cmp	ip, #0	@ npix,
 485 01b0 0A0000DA 		ble	.L26		@,
 486              	@ armwave.c:140:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 129:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 130:armwave.c     ****         // each byte.  We can afford to do this because most pixels will be blank for
 131:armwave.c     ****         // most normal waveforms.
 132:armwave.c     ****         wave_word = *base_32ptr++;
 133:armwave.c     **** 
 134:armwave.c     ****         if(COND_UNLIKELY(wave_word != 0)) {
 135:armwave.c     ****             for(i = 0; i < 4; i++) {
 136:armwave.c     ****                 value = wave_word & 0xff;
 137:armwave.c     ****                 wave_word >>= 8;
 138:armwave.c     **** 
 139:armwave.c     ****                 if(value != 0) {
 140:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 487              		.loc 1 140 52 view .LVU112
 488 01b4 F0A6D5E1 		ldrsh	r10, [r5, #96]	@ _70, g_armwave_state.ch1_color.r
 489              	@ armwave.c:141:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 141:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 490              		.loc 1 141 52 view .LVU113
 491 01b8 F296D5E1 		ldrsh	r9, [r5, #98]	@ _76, g_armwave_state.ch1_color.g
 492              	@ armwave.c:142:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 142:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 493              		.loc 1 142 52 view .LVU114
 494 01bc F4B6D5E1 		ldrsh	fp, [r5, #100]	@ _80, g_armwave_state.ch1_color.b
 495              	@ armwave.c:128:     for(n = 0; n < npix; n += 4) {
 128:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 496              		.loc 1 128 11 view .LVU115
 497 01c0 0030A0E3 		mov	r3, #0	@ n,
 498 01c4 00008DE5 		str	r0, [sp]	@ out_buffer, %sfp
 499              	.LVL25:
 500              	.L35:
 132:armwave.c     **** 
 501              		.loc 1 132 9 is_stmt 1 view .LVU116
 502              	@ armwave.c:132:         wave_word = *base_32ptr++;
 132:armwave.c     **** 
 503              		.loc 1 132 19 is_stmt 0 view .LVU117
 504 01c8 042091E4 		ldr	r2, [r1], #4	@ wave_word, MEM[base: base_32ptr_46, offset: 4294967292B]
 505              	.LVL26:
 134:armwave.c     ****             for(i = 0; i < 4; i++) {
 506              		.loc 1 134 9 is_stmt 1 view .LVU118
 507              	@ armwave.c:134:         if(COND_UNLIKELY(wave_word != 0)) {
 134:armwave.c     ****             for(i = 0; i < 4; i++) {
 508              		.loc 1 134 11 is_stmt 0 view .LVU119
 509 01cc 000052E3 		cmp	r2, #0	@ wave_word,
 510 01d0 0400001A 		bne	.L52		@,
 511              	.LVL27:
 512              	.L30:
 513              	@ armwave.c:128:     for(n = 0; n < npix; n += 4) {
 128:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 514              		.loc 1 128 28 discriminator 2 view .LVU120
 515 01d4 043083E2 		add	r3, r3, #4	@ n, n,
 516              	.LVL28:
 517              	@ armwave.c:128:     for(n = 0; n < npix; n += 4) {
 128:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 518              		.loc 1 128 5 discriminator 2 view .LVU121
 519 01d8 03005CE1 		cmp	ip, r3	@ npix, n
 520 01dc F9FFFFCA 		bgt	.L35		@,
 521              	.LVL29:
 522              	.L26:
 523              	@ armwave.c:161: }
 143:armwave.c     **** 
 144:armwave.c     ****                     r = MIN(rr, 255);
 145:armwave.c     ****                     g = MIN(gg, 255);
 146:armwave.c     ****                     b = MIN(bb, 255);
 147:armwave.c     **** 
 148:armwave.c     ****                     // Ensure 100% alpha channel, if it is used
 149:armwave.c     ****                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 150:armwave.c     **** 
 151:armwave.c     ****                     // Is there a better way?
 152:armwave.c     ****                     nsub = n + i;
 153:armwave.c     ****                     xx = nsub & 0xff;
 154:armwave.c     ****                     yy = nsub >> 8;
 155:armwave.c     ****                     offset = yy + (xx * g_armwave_state.target_width);
 156:armwave.c     ****                     *(out_buffer_base + offset) = word;
 157:armwave.c     ****                 }
 158:armwave.c     ****             }
 159:armwave.c     ****         } 
 160:armwave.c     ****     }
 161:armwave.c     **** }
 524              		.loc 1 161 1 view .LVU122
 525 01e0 0CD08DE2 		add	sp, sp, #12	@,,
 526              		.cfi_remember_state
 527              		.cfi_def_cfa_offset 36
 528              		@ sp needed	@
 529 01e4 F08FBDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}	@
 530              	.LVL30:
 531              	.L52:
 532              		.cfi_restore_state
 136:armwave.c     ****                 wave_word >>= 8;
 533              		.loc 1 136 17 is_stmt 1 view .LVU123
 137:armwave.c     **** 
 534              		.loc 1 137 17 view .LVU124
 535              	@ armwave.c:139:                 if(value != 0) {
 139:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 536              		.loc 1 139 19 is_stmt 0 view .LVU125
 537 01e8 FF6012E2 		ands	r6, r2, #255	@ _72, wave_word,
 538              	@ armwave.c:137:                 wave_word >>= 8;
 137:armwave.c     **** 
 539              		.loc 1 137 27 view .LVU126
 540 01ec 22E4A0E1 		lsr	lr, r2, #8	@ wave_word, wave_word,
 541              	.LVL31:
 139:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 542              		.loc 1 139 17 is_stmt 1 view .LVU127
 543              	@ armwave.c:139:                 if(value != 0) {
 139:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 544              		.loc 1 139 19 is_stmt 0 view .LVU128
 545 01f0 1900000A 		beq	.L31		@,
 140:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 546              		.loc 1 140 21 is_stmt 1 view .LVU129
 547              	.LVL32:
 141:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 548              		.loc 1 141 21 view .LVU130
 142:armwave.c     **** 
 549              		.loc 1 142 21 view .LVU131
 144:armwave.c     ****                     g = MIN(gg, 255);
 550              		.loc 1 144 21 view .LVU132
 145:armwave.c     ****                     b = MIN(bb, 255);
 551              		.loc 1 145 21 view .LVU133
 146:armwave.c     **** 
 552              		.loc 1 146 21 view .LVU134
 149:armwave.c     **** 
 553              		.loc 1 149 21 view .LVU135
 152:armwave.c     ****                     xx = nsub & 0xff;
 554              		.loc 1 152 21 view .LVU136
 153:armwave.c     ****                     yy = nsub >> 8;
 555              		.loc 1 153 21 view .LVU137
 154:armwave.c     ****                     offset = yy + (xx * g_armwave_state.target_width);
 556              		.loc 1 154 21 view .LVU138
 155:armwave.c     ****                     *(out_buffer_base + offset) = word;
 557              		.loc 1 155 21 view .LVU139
 156:armwave.c     ****                 }
 558              		.loc 1 156 21 view .LVU140
 559              	@ armwave.c:142:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 142:armwave.c     **** 
 560              		.loc 1 142 55 is_stmt 0 view .LVU141
 561 01f4 9B0604E0 		mul	r4, fp, r6	@ tmp276, _80, _72
 562              	@ armwave.c:141:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 141:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 563              		.loc 1 141 55 view .LVU142
 564 01f8 990608E0 		mul	r8, r9, r6	@ tmp280, _76, _72
 565              	@ armwave.c:142:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 142:armwave.c     **** 
 566              		.loc 1 142 24 view .LVU143
 567 01fc 4444A0E1 		asr	r4, r4, #8	@ bb, tmp276,
 568              	.LVL33:
 569              	@ armwave.c:146:                     b = MIN(bb, 255);
 146:armwave.c     **** 
 570              		.loc 1 146 25 view .LVU144
 571 0200 FF0054E3 		cmp	r4, #255	@ bb,
 572              	@ armwave.c:141:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 141:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 573              		.loc 1 141 24 view .LVU145
 574 0204 4884A0E1 		asr	r8, r8, #8	@ gg, tmp280,
 575              	.LVL34:
 576              	@ armwave.c:146:                     b = MIN(bb, 255);
 146:armwave.c     **** 
 577              		.loc 1 146 25 view .LVU146
 578 0208 FF40A0A3 		movge	r4, #255	@ bb,
 579              	.LVL35:
 580              	@ armwave.c:140:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 140:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 581              		.loc 1 140 55 view .LVU147
 582 020c 960A06E0 		mul	r6, r6, r10	@ tmp286, _72, _70
 583              	.LVL36:
 584              	@ armwave.c:145:                     g = MIN(gg, 255);
 145:armwave.c     ****                     b = MIN(bb, 255);
 585              		.loc 1 145 25 view .LVU148
 586 0210 FF0058E3 		cmp	r8, #255	@ gg,
 587 0214 FF80A0A3 		movge	r8, #255	@ gg,
 588              	.LVL37:
 589              	@ armwave.c:140:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 140:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 590              		.loc 1 140 24 view .LVU149
 591 0218 4664A0E1 		asr	r6, r6, #8	@ rr, tmp286,
 592              	.LVL38:
 593              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 594              		.loc 1 149 56 view .LVU150
 595 021c 0884A0E1 		lsl	r8, r8, #8	@ tmp281, gg,
 596              	@ armwave.c:156:                     *(out_buffer_base + offset) = word;
 156:armwave.c     ****                 }
 597              		.loc 1 156 39 view .LVU151
 598 0220 4C0095E5 		ldr	r0, [r5, #76]	@ tmp372, g_armwave_state.target_width
 599              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 600              		.loc 1 149 44 view .LVU152
 601 0224 0448A0E1 		lsl	r4, r4, #16	@ tmp277, bb,
 602              	@ armwave.c:144:                     r = MIN(rr, 255);
 144:armwave.c     ****                     g = MIN(gg, 255);
 603              		.loc 1 144 25 view .LVU153
 604 0228 FF0056E3 		cmp	r6, #255	@ rr,
 605              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 606              		.loc 1 149 56 view .LVU154
 607 022c 7880FFE6 		uxth	r8, r8	@ tmp282, tmp281
 608              	@ armwave.c:153:                     xx = nsub & 0xff;
 153:armwave.c     ****                     yy = nsub >> 8;
 609              		.loc 1 153 24 view .LVU155
 610 0230 7370EFE6 		uxtb	r7, r3	@ xx, n
 611              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 612              		.loc 1 149 44 view .LVU156
 613 0234 FF4804E2 		and	r4, r4, #16711680	@ tmp278, tmp277,
 614              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 615              		.loc 1 149 51 view .LVU157
 616 0238 084084E1 		orr	r4, r4, r8	@ tmp284, tmp278, tmp282
 617              	@ armwave.c:144:                     r = MIN(rr, 255);
 144:armwave.c     ****                     g = MIN(gg, 255);
 618              		.loc 1 144 25 view .LVU158
 619 023c FF60A0A3 		movge	r6, #255	@ rr,
 620              	.LVL39:
 621              	@ armwave.c:154:                     yy = nsub >> 8;
 154:armwave.c     ****                     offset = yy + (xx * g_armwave_state.target_width);
 622              		.loc 1 154 31 view .LVU159
 623 0240 4384A0E1 		asr	r8, r3, #8	@ yy, n,
 624              	.LVL40:
 625              	@ armwave.c:156:                     *(out_buffer_base + offset) = word;
 156:armwave.c     ****                 }
 626              		.loc 1 156 39 view .LVU160
 627 0244 908727E0 		mla	r7, r0, r7, r8	@ tmp274, tmp372, xx, yy
 628              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 629              		.loc 1 149 62 view .LVU161
 630 0248 7660EFE6 		uxtb	r6, r6	@ rr, rr
 631              	@ armwave.c:156:                     *(out_buffer_base + offset) = word;
 156:armwave.c     ****                 }
 632              		.loc 1 156 49 view .LVU162
 633 024c 00009DE5 		ldr	r0, [sp]	@ out_buffer, %sfp
 634              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 635              		.loc 1 149 62 view .LVU163
 636 0250 066084E1 		orr	r6, r4, r6	@ tmp288, tmp284, rr
 637              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 638              		.loc 1 149 26 view .LVU164
 639 0254 FF6486E3 		orr	r6, r6, #-16777216	@ word, tmp288,
 640              	@ armwave.c:156:                     *(out_buffer_base + offset) = word;
 156:armwave.c     ****                 }
 641              		.loc 1 156 49 view .LVU165
 642 0258 076180E7 		str	r6, [r0, r7, lsl #2]	@ word, *_106
 643              	.LVL41:
 644              	.L31:
 136:armwave.c     ****                 wave_word >>= 8;
 645              		.loc 1 136 17 is_stmt 1 view .LVU166
 137:armwave.c     **** 
 646              		.loc 1 137 17 view .LVU167
 647              	@ armwave.c:139:                 if(value != 0) {
 139:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 648              		.loc 1 139 19 is_stmt 0 view .LVU168
 649 025c FFE01EE2 		ands	lr, lr, #255	@ _118, wave_word,
 650              	.LVL42:
 651              	@ armwave.c:137:                 wave_word >>= 8;
 137:armwave.c     **** 
 652              		.loc 1 137 27 view .LVU169
 653 0260 2288A0E1 		lsr	r8, r2, #16	@ wave_word, wave_word,
 654              	.LVL43:
 139:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 655              		.loc 1 139 17 is_stmt 1 view .LVU170
 656              	@ armwave.c:139:                 if(value != 0) {
 139:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 657              		.loc 1 139 19 is_stmt 0 view .LVU171
 658 0264 1C00000A 		beq	.L32		@,
 140:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 659              		.loc 1 140 21 is_stmt 1 view .LVU172
 660              	.LVL44:
 141:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 661              		.loc 1 141 21 view .LVU173
 142:armwave.c     **** 
 662              		.loc 1 142 21 view .LVU174
 144:armwave.c     ****                     g = MIN(gg, 255);
 663              		.loc 1 144 21 view .LVU175
 145:armwave.c     ****                     b = MIN(bb, 255);
 664              		.loc 1 145 21 view .LVU176
 146:armwave.c     **** 
 665              		.loc 1 146 21 view .LVU177
 149:armwave.c     **** 
 666              		.loc 1 149 21 view .LVU178
 152:armwave.c     ****                     xx = nsub & 0xff;
 667              		.loc 1 152 21 view .LVU179
 668              	@ armwave.c:142:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 142:armwave.c     **** 
 669              		.loc 1 142 55 is_stmt 0 view .LVU180
 670 0268 9E0B04E0 		mul	r4, lr, fp	@ tmp299, _118, _80
 671              	@ armwave.c:141:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 141:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 672              		.loc 1 141 55 view .LVU181
 673 026c 9E0907E0 		mul	r7, lr, r9	@ tmp303, _118, _76
 674              	@ armwave.c:142:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 142:armwave.c     **** 
 675              		.loc 1 142 24 view .LVU182
 676 0270 4444A0E1 		asr	r4, r4, #8	@ bb, tmp299,
 677              	.LVL45:
 678              	@ armwave.c:146:                     b = MIN(bb, 255);
 146:armwave.c     **** 
 679              		.loc 1 146 25 view .LVU183
 680 0274 FF0054E3 		cmp	r4, #255	@ bb,
 681 0278 FF40A0A3 		movge	r4, #255	@ bb,
 682              	.LVL46:
 683              	@ armwave.c:140:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 140:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 684              		.loc 1 140 55 view .LVU184
 685 027c 9E0A0EE0 		mul	lr, lr, r10	@ tmp309, _118, _70
 686              	.LVL47:
 687              	@ armwave.c:141:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 141:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 688              		.loc 1 141 24 view .LVU185
 689 0280 4774A0E1 		asr	r7, r7, #8	@ gg, tmp303,
 690              	.LVL48:
 691              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 692              		.loc 1 149 44 view .LVU186
 693 0284 0448A0E1 		lsl	r4, r4, #16	@ tmp300, bb,
 694              	@ armwave.c:145:                     g = MIN(gg, 255);
 145:armwave.c     ****                     b = MIN(bb, 255);
 695              		.loc 1 145 25 view .LVU187
 696 0288 FF0057E3 		cmp	r7, #255	@ gg,
 697 028c 016083E2 		add	r6, r3, #1	@ _158, n,
 153:armwave.c     ****                     yy = nsub >> 8;
 698              		.loc 1 153 21 is_stmt 1 view .LVU188
 154:armwave.c     ****                     offset = yy + (xx * g_armwave_state.target_width);
 699              		.loc 1 154 21 view .LVU189
 155:armwave.c     ****                     *(out_buffer_base + offset) = word;
 700              		.loc 1 155 21 view .LVU190
 156:armwave.c     ****                 }
 701              		.loc 1 156 21 view .LVU191
 702              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 703              		.loc 1 149 44 is_stmt 0 view .LVU192
 704 0290 FF4804E2 		and	r4, r4, #16711680	@ tmp301, tmp300,
 705              	@ armwave.c:145:                     g = MIN(gg, 255);
 145:armwave.c     ****                     b = MIN(bb, 255);
 706              		.loc 1 145 25 view .LVU193
 707 0294 FF70A0A3 		movge	r7, #255	@ gg,
 708              	.LVL49:
 709              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 710              		.loc 1 149 44 view .LVU194
 711 0298 04408DE5 		str	r4, [sp, #4]	@ tmp301, %sfp
 712              	@ armwave.c:156:                     *(out_buffer_base + offset) = word;
 156:armwave.c     ****                 }
 713              		.loc 1 156 39 view .LVU195
 714 029c 4C4095E5 		ldr	r4, [r5, #76]	@ tmp375, g_armwave_state.target_width
 715              	@ armwave.c:140:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 140:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 716              		.loc 1 140 24 view .LVU196
 717 02a0 4EE4A0E1 		asr	lr, lr, #8	@ rr, tmp309,
 718              	.LVL50:
 719              	@ armwave.c:153:                     xx = nsub & 0xff;
 153:armwave.c     ****                     yy = nsub >> 8;
 720              		.loc 1 153 24 view .LVU197
 721 02a4 7600EFE6 		uxtb	r0, r6	@ xx, _158
 722              	@ armwave.c:144:                     r = MIN(rr, 255);
 144:armwave.c     ****                     g = MIN(gg, 255);
 723              		.loc 1 144 25 view .LVU198
 724 02a8 FF005EE3 		cmp	lr, #255	@ rr,
 725              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 726              		.loc 1 149 56 view .LVU199
 727 02ac 0774A0E1 		lsl	r7, r7, #8	@ tmp304, gg,
 728              	@ armwave.c:154:                     yy = nsub >> 8;
 154:armwave.c     ****                     offset = yy + (xx * g_armwave_state.target_width);
 729              		.loc 1 154 31 view .LVU200
 730 02b0 4664A0E1 		asr	r6, r6, #8	@ yy, _158,
 731              	@ armwave.c:156:                     *(out_buffer_base + offset) = word;
 156:armwave.c     ****                 }
 732              		.loc 1 156 39 view .LVU201
 733 02b4 946026E0 		mla	r6, r4, r0, r6	@ tmp297, tmp375, xx, yy
 734              	@ armwave.c:144:                     r = MIN(rr, 255);
 144:armwave.c     ****                     g = MIN(gg, 255);
 735              		.loc 1 144 25 view .LVU202
 736 02b8 FFE0A0A3 		movge	lr, #255	@ rr,
 737              	.LVL51:
 738              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 739              		.loc 1 149 51 view .LVU203
 740 02bc 04009DE5 		ldr	r0, [sp, #4]	@ tmp301, %sfp
 741              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 742              		.loc 1 149 56 view .LVU204
 743 02c0 7770FFE6 		uxth	r7, r7	@ tmp305, tmp304
 744              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 745              		.loc 1 149 51 view .LVU205
 746 02c4 074080E1 		orr	r4, r0, r7	@ tmp307, tmp301, tmp305
 747              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 748              		.loc 1 149 62 view .LVU206
 749 02c8 7EE0EFE6 		uxtb	lr, lr	@ rr, rr
 750              	@ armwave.c:156:                     *(out_buffer_base + offset) = word;
 156:armwave.c     ****                 }
 751              		.loc 1 156 49 view .LVU207
 752 02cc 00009DE5 		ldr	r0, [sp]	@ out_buffer, %sfp
 753              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 754              		.loc 1 149 62 view .LVU208
 755 02d0 0EE084E1 		orr	lr, r4, lr	@ tmp311, tmp307, rr
 756              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 757              		.loc 1 149 26 view .LVU209
 758 02d4 FFE48EE3 		orr	lr, lr, #-16777216	@ word, tmp311,
 759              	@ armwave.c:156:                     *(out_buffer_base + offset) = word;
 156:armwave.c     ****                 }
 760              		.loc 1 156 49 view .LVU210
 761 02d8 06E180E7 		str	lr, [r0, r6, lsl #2]	@ word, *_152
 762              	.LVL52:
 763              	.L32:
 136:armwave.c     ****                 wave_word >>= 8;
 764              		.loc 1 136 17 is_stmt 1 view .LVU211
 137:armwave.c     **** 
 765              		.loc 1 137 17 view .LVU212
 766              	@ armwave.c:139:                 if(value != 0) {
 139:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 767              		.loc 1 139 19 is_stmt 0 view .LVU213
 768 02dc FFE018E2 		ands	lr, r8, #255	@ _164, wave_word,
 769              	@ armwave.c:137:                 wave_word >>= 8;
 137:armwave.c     **** 
 770              		.loc 1 137 27 view .LVU214
 771 02e0 222CA0E1 		lsr	r2, r2, #24	@ wave_word, wave_word,
 772              	.LVL53:
 139:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 773              		.loc 1 139 17 is_stmt 1 view .LVU215
 774              	@ armwave.c:139:                 if(value != 0) {
 139:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 775              		.loc 1 139 19 is_stmt 0 view .LVU216
 776 02e4 1A00000A 		beq	.L33		@,
 140:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 777              		.loc 1 140 21 is_stmt 1 view .LVU217
 778              	.LVL54:
 141:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 779              		.loc 1 141 21 view .LVU218
 142:armwave.c     **** 
 780              		.loc 1 142 21 view .LVU219
 144:armwave.c     ****                     g = MIN(gg, 255);
 781              		.loc 1 144 21 view .LVU220
 145:armwave.c     ****                     b = MIN(bb, 255);
 782              		.loc 1 145 21 view .LVU221
 146:armwave.c     **** 
 783              		.loc 1 146 21 view .LVU222
 149:armwave.c     **** 
 784              		.loc 1 149 21 view .LVU223
 152:armwave.c     ****                     xx = nsub & 0xff;
 785              		.loc 1 152 21 view .LVU224
 786              	@ armwave.c:142:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 142:armwave.c     **** 
 787              		.loc 1 142 55 is_stmt 0 view .LVU225
 788 02e8 9E0B04E0 		mul	r4, lr, fp	@ tmp322, _164, _80
 789              	@ armwave.c:141:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 141:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 790              		.loc 1 141 55 view .LVU226
 791 02ec 9E0906E0 		mul	r6, lr, r9	@ tmp326, _164, _76
 792              	@ armwave.c:142:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 142:armwave.c     **** 
 793              		.loc 1 142 24 view .LVU227
 794 02f0 4444A0E1 		asr	r4, r4, #8	@ bb, tmp322,
 795              	.LVL55:
 796              	@ armwave.c:140:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 140:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 797              		.loc 1 140 55 view .LVU228
 798 02f4 9E0A0EE0 		mul	lr, lr, r10	@ tmp332, _164, _70
 799              	.LVL56:
 800              	@ armwave.c:146:                     b = MIN(bb, 255);
 146:armwave.c     **** 
 801              		.loc 1 146 25 view .LVU229
 802 02f8 FF0054E3 		cmp	r4, #255	@ bb,
 803              	@ armwave.c:141:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 141:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 804              		.loc 1 141 24 view .LVU230
 805 02fc 4664A0E1 		asr	r6, r6, #8	@ gg, tmp326,
 806              	.LVL57:
 807              	@ armwave.c:146:                     b = MIN(bb, 255);
 146:armwave.c     **** 
 808              		.loc 1 146 25 view .LVU231
 809 0300 FF40A0A3 		movge	r4, #255	@ bb,
 810              	.LVL58:
 811              	@ armwave.c:145:                     g = MIN(gg, 255);
 145:armwave.c     ****                     b = MIN(bb, 255);
 812              		.loc 1 145 25 view .LVU232
 813 0304 FF0056E3 		cmp	r6, #255	@ gg,
 814 0308 FF60A0A3 		movge	r6, #255	@ gg,
 815              	.LVL59:
 145:armwave.c     ****                     b = MIN(bb, 255);
 816              		.loc 1 145 25 view .LVU233
 817 030c 027083E2 		add	r7, r3, #2	@ _66, n,
 153:armwave.c     ****                     yy = nsub >> 8;
 818              		.loc 1 153 21 is_stmt 1 view .LVU234
 154:armwave.c     ****                     offset = yy + (xx * g_armwave_state.target_width);
 819              		.loc 1 154 21 view .LVU235
 155:armwave.c     ****                     *(out_buffer_base + offset) = word;
 820              		.loc 1 155 21 view .LVU236
 156:armwave.c     ****                 }
 821              		.loc 1 156 21 view .LVU237
 822              	@ armwave.c:140:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 140:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 823              		.loc 1 140 24 is_stmt 0 view .LVU238
 824 0310 4EE4A0E1 		asr	lr, lr, #8	@ rr, tmp332,
 825              	.LVL60:
 826              	@ armwave.c:156:                     *(out_buffer_base + offset) = word;
 156:armwave.c     ****                 }
 827              		.loc 1 156 39 view .LVU239
 828 0314 4C0095E5 		ldr	r0, [r5, #76]	@ tmp376, g_armwave_state.target_width
 829              	@ armwave.c:144:                     r = MIN(rr, 255);
 144:armwave.c     ****                     g = MIN(gg, 255);
 830              		.loc 1 144 25 view .LVU240
 831 0318 FF005EE3 		cmp	lr, #255	@ rr,
 832              	@ armwave.c:153:                     xx = nsub & 0xff;
 153:armwave.c     ****                     yy = nsub >> 8;
 833              		.loc 1 153 24 view .LVU241
 834 031c 7780EFE6 		uxtb	r8, r7	@ xx, _66
 835              	.LVL61:
 836              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 837              		.loc 1 149 56 view .LVU242
 838 0320 0664A0E1 		lsl	r6, r6, #8	@ tmp327, gg,
 839              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 840              		.loc 1 149 44 view .LVU243
 841 0324 0448A0E1 		lsl	r4, r4, #16	@ tmp323, bb,
 842              	@ armwave.c:144:                     r = MIN(rr, 255);
 144:armwave.c     ****                     g = MIN(gg, 255);
 843              		.loc 1 144 25 view .LVU244
 844 0328 FFE0A0A3 		movge	lr, #255	@ rr,
 845              	.LVL62:
 846              	@ armwave.c:154:                     yy = nsub >> 8;
 154:armwave.c     ****                     offset = yy + (xx * g_armwave_state.target_width);
 847              		.loc 1 154 31 view .LVU245
 848 032c 4774A0E1 		asr	r7, r7, #8	@ yy, _66,
 849              	@ armwave.c:156:                     *(out_buffer_base + offset) = word;
 156:armwave.c     ****                 }
 850              		.loc 1 156 39 view .LVU246
 851 0330 907827E0 		mla	r7, r0, r8, r7	@ tmp320, tmp376, xx, yy
 852              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 853              		.loc 1 149 44 view .LVU247
 854 0334 FF4804E2 		and	r4, r4, #16711680	@ tmp324, tmp323,
 855              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 856              		.loc 1 149 56 view .LVU248
 857 0338 7660FFE6 		uxth	r6, r6	@ tmp328, tmp327
 858              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 859              		.loc 1 149 51 view .LVU249
 860 033c 066084E1 		orr	r6, r4, r6	@ tmp330, tmp324, tmp328
 861              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 862              		.loc 1 149 62 view .LVU250
 863 0340 7EE0EFE6 		uxtb	lr, lr	@ rr, rr
 864              	@ armwave.c:156:                     *(out_buffer_base + offset) = word;
 156:armwave.c     ****                 }
 865              		.loc 1 156 49 view .LVU251
 866 0344 00009DE5 		ldr	r0, [sp]	@ out_buffer, %sfp
 867              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 868              		.loc 1 149 62 view .LVU252
 869 0348 0EE086E1 		orr	lr, r6, lr	@ tmp334, tmp330, rr
 870              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 871              		.loc 1 149 26 view .LVU253
 872 034c FFE48EE3 		orr	lr, lr, #-16777216	@ word, tmp334,
 873              	@ armwave.c:156:                     *(out_buffer_base + offset) = word;
 156:armwave.c     ****                 }
 874              		.loc 1 156 49 view .LVU254
 875 0350 07E180E7 		str	lr, [r0, r7, lsl #2]	@ word, *_198
 876              	.L33:
 877              	.LVL63:
 136:armwave.c     ****                 wave_word >>= 8;
 878              		.loc 1 136 17 is_stmt 1 view .LVU255
 137:armwave.c     **** 
 879              		.loc 1 137 17 view .LVU256
 139:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 880              		.loc 1 139 17 view .LVU257
 881              	@ armwave.c:139:                 if(value != 0) {
 139:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 882              		.loc 1 139 19 is_stmt 0 view .LVU258
 883 0354 000052E3 		cmp	r2, #0	@ wave_word,
 884 0358 9DFFFF0A 		beq	.L30		@,
 140:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 885              		.loc 1 140 21 is_stmt 1 view .LVU259
 886              	.LVL64:
 141:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 887              		.loc 1 141 21 view .LVU260
 142:armwave.c     **** 
 888              		.loc 1 142 21 view .LVU261
 144:armwave.c     ****                     g = MIN(gg, 255);
 889              		.loc 1 144 21 view .LVU262
 145:armwave.c     ****                     b = MIN(bb, 255);
 890              		.loc 1 145 21 view .LVU263
 146:armwave.c     **** 
 891              		.loc 1 146 21 view .LVU264
 149:armwave.c     **** 
 892              		.loc 1 149 21 view .LVU265
 152:armwave.c     ****                     xx = nsub & 0xff;
 893              		.loc 1 152 21 view .LVU266
 894              	@ armwave.c:142:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 142:armwave.c     **** 
 895              		.loc 1 142 55 is_stmt 0 view .LVU267
 896 035c 920B0EE0 		mul	lr, r2, fp	@ tmp343, wave_word, _80
 897              	@ armwave.c:141:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 141:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 898              		.loc 1 141 55 view .LVU268
 899 0360 920904E0 		mul	r4, r2, r9	@ tmp347, wave_word, _76
 900              	@ armwave.c:142:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 142:armwave.c     **** 
 901              		.loc 1 142 24 view .LVU269
 902 0364 4EE4A0E1 		asr	lr, lr, #8	@ bb, tmp343,
 903              	.LVL65:
 904              	@ armwave.c:140:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 140:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 905              		.loc 1 140 55 view .LVU270
 906 0368 920A02E0 		mul	r2, r2, r10	@ tmp353, wave_word, _70
 907              	.LVL66:
 908              	@ armwave.c:146:                     b = MIN(bb, 255);
 146:armwave.c     **** 
 909              		.loc 1 146 25 view .LVU271
 910 036c FF005EE3 		cmp	lr, #255	@ bb,
 911              	@ armwave.c:141:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 141:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 912              		.loc 1 141 24 view .LVU272
 913 0370 4444A0E1 		asr	r4, r4, #8	@ gg, tmp347,
 914              	.LVL67:
 915              	@ armwave.c:146:                     b = MIN(bb, 255);
 146:armwave.c     **** 
 916              		.loc 1 146 25 view .LVU273
 917 0374 FFE0A0A3 		movge	lr, #255	@ bb,
 918              	.LVL68:
 919              	@ armwave.c:145:                     g = MIN(gg, 255);
 145:armwave.c     ****                     b = MIN(bb, 255);
 920              		.loc 1 145 25 view .LVU274
 921 0378 FF0054E3 		cmp	r4, #255	@ gg,
 922 037c FF40A0A3 		movge	r4, #255	@ gg,
 923              	.LVL69:
 145:armwave.c     ****                     b = MIN(bb, 255);
 924              		.loc 1 145 25 view .LVU275
 925 0380 036083E2 		add	r6, r3, #3	@ _59, n,
 153:armwave.c     ****                     yy = nsub >> 8;
 926              		.loc 1 153 21 is_stmt 1 view .LVU276
 154:armwave.c     ****                     offset = yy + (xx * g_armwave_state.target_width);
 927              		.loc 1 154 21 view .LVU277
 155:armwave.c     ****                     *(out_buffer_base + offset) = word;
 928              		.loc 1 155 21 view .LVU278
 156:armwave.c     ****                 }
 929              		.loc 1 156 21 view .LVU279
 930              	@ armwave.c:140:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 140:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 931              		.loc 1 140 24 is_stmt 0 view .LVU280
 932 0384 4224A0E1 		asr	r2, r2, #8	@ rr, tmp353,
 933              	.LVL70:
 934              	@ armwave.c:155:                     offset = yy + (xx * g_armwave_state.target_width);
 155:armwave.c     ****                     *(out_buffer_base + offset) = word;
 935              		.loc 1 155 39 view .LVU281
 936 0388 4C7095E5 		ldr	r7, [r5, #76]	@ g_armwave_state.target_width, g_armwave_state.target_width
 937              	@ armwave.c:144:                     r = MIN(rr, 255);
 144:armwave.c     ****                     g = MIN(gg, 255);
 938              		.loc 1 144 25 view .LVU282
 939 038c FF0052E3 		cmp	r2, #255	@ rr,
 940              	@ armwave.c:153:                     xx = nsub & 0xff;
 153:armwave.c     ****                     yy = nsub >> 8;
 941              		.loc 1 153 24 view .LVU283
 942 0390 7680EFE6 		uxtb	r8, r6	@ xx, _59
 943              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 944              		.loc 1 149 56 view .LVU284
 945 0394 0444A0E1 		lsl	r4, r4, #8	@ tmp348, gg,
 946              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 947              		.loc 1 149 44 view .LVU285
 948 0398 0EE8A0E1 		lsl	lr, lr, #16	@ tmp344, bb,
 949              	@ armwave.c:144:                     r = MIN(rr, 255);
 144:armwave.c     ****                     g = MIN(gg, 255);
 950              		.loc 1 144 25 view .LVU286
 951 039c FF20A0A3 		movge	r2, #255	@ rr,
 952              	.LVL71:
 953              	@ armwave.c:154:                     yy = nsub >> 8;
 154:armwave.c     ****                     offset = yy + (xx * g_armwave_state.target_width);
 954              		.loc 1 154 31 view .LVU287
 955 03a0 4664A0E1 		asr	r6, r6, #8	@ yy, _59,
 956              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 957              		.loc 1 149 44 view .LVU288
 958 03a4 FFE80EE2 		and	lr, lr, #16711680	@ tmp345, tmp344,
 959              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 960              		.loc 1 149 56 view .LVU289
 961 03a8 7440FFE6 		uxth	r4, r4	@ tmp349, tmp348
 962              	@ armwave.c:156:                     *(out_buffer_base + offset) = word;
 156:armwave.c     ****                 }
 963              		.loc 1 156 39 view .LVU290
 964 03ac 976826E0 		mla	r6, r7, r8, r6	@ tmp341, g_armwave_state.target_width, xx, yy
 965              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 966              		.loc 1 149 51 view .LVU291
 967 03b0 04E08EE1 		orr	lr, lr, r4	@ tmp351, tmp345, tmp349
 968              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 969              		.loc 1 149 62 view .LVU292
 970 03b4 7220EFE6 		uxtb	r2, r2	@ rr, rr
 971              	@ armwave.c:156:                     *(out_buffer_base + offset) = word;
 156:armwave.c     ****                 }
 972              		.loc 1 156 49 view .LVU293
 973 03b8 00009DE5 		ldr	r0, [sp]	@ out_buffer, %sfp
 974              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 975              		.loc 1 149 62 view .LVU294
 976 03bc 02208EE1 		orr	r2, lr, r2	@ tmp355, tmp351, rr
 977              	@ armwave.c:149:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 149:armwave.c     **** 
 978              		.loc 1 149 26 view .LVU295
 979 03c0 FF2482E3 		orr	r2, r2, #-16777216	@ word, tmp355,
 980              	@ armwave.c:156:                     *(out_buffer_base + offset) = word;
 156:armwave.c     ****                 }
 981              		.loc 1 156 49 view .LVU296
 982 03c4 062180E7 		str	r2, [r0, r6, lsl #2]	@ word, *_244
 983 03c8 81FFFFEA 		b	.L30		@
 984              	.LVL72:
 985              	.L51:
 122:armwave.c     **** 
 986              		.loc 1 122 5 is_stmt 1 discriminator 1 view .LVU297
 987 03cc 10309FE5 		ldr	r3, .L53+4	@,
 988 03d0 7A20A0E3 		mov	r2, #122	@,
 989 03d4 0C109FE5 		ldr	r1, .L53+8	@,
 990              	.LVL73:
 122:armwave.c     **** 
 991              		.loc 1 122 5 is_stmt 0 discriminator 1 view .LVU298
 992 03d8 0C009FE5 		ldr	r0, .L53+12	@,
 993              	.LVL74:
 122:armwave.c     **** 
 994              		.loc 1 122 5 discriminator 1 view .LVU299
 995 03dc FEFFFFEB 		bl	__assert_fail		@
 996              	.LVL75:
 997              	.L54:
 122:armwave.c     **** 
 998              		.loc 1 122 5 discriminator 1 view .LVU300
 999              		.align	2
 1000              	.L53:
 1001 03e0 00000000 		.word	g_armwave_state
 1002 03e4 00000000 		.word	.LANCHOR0
 1003 03e8 20000000 		.word	.LC2
 1004 03ec 2C000000 		.word	.LC3
 1005              		.cfi_endproc
 1006              	.LFE60:
 1008              		.align	2
 1009              		.global	armwave_fill_pixbuf_scaled
 1010              		.syntax unified
 1011              		.arm
 1012              		.fpu vfp
 1014              	armwave_fill_pixbuf_scaled:
 1015              	.LVL76:
 1016              	.LFB61:
 162:armwave.c     **** 
 163:armwave.c     **** /*
 164:armwave.c     ****  * Fill a pixbuf with a multiple of a 256-height waveform.
 165:armwave.c     ****  * Rows are repeated as necessary.
 166:armwave.c     ****  */
 167:armwave.c     **** void armwave_fill_pixbuf_scaled(uint32_t *out_buffer)
 168:armwave.c     **** {
 1017              		.loc 1 168 1 is_stmt 1 view -0
 1018              		.cfi_startproc
 1019              		@ args = 0, pretend = 0, frame = 8
 1020              		@ frame_needed = 0, uses_anonymous_args = 0
 169:armwave.c     ****     uint32_t xx, yy, ye, y, ysub, word, wave_word;
 1021              		.loc 1 169 5 view .LVU302
 170:armwave.c     ****     int rr, gg, bb, n, nsub, npix, w, vscale;
 1022              		.loc 1 170 5 view .LVU303
 171:armwave.c     ****     uint8_t r, g, b, value, row;
 1023              		.loc 1 171 5 view .LVU304
 172:armwave.c     ****     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 1024              		.loc 1 172 5 view .LVU305
 1025              	@ armwave.c:168: {
 168:armwave.c     ****     uint32_t xx, yy, ye, y, ysub, word, wave_word;
 1026              		.loc 1 168 1 is_stmt 0 view .LVU306
 1027 03f0 F04F2DE9 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}	@
 1028              		.cfi_def_cfa_offset 36
 1029              		.cfi_offset 4, -36
 1030              		.cfi_offset 5, -32
 1031              		.cfi_offset 6, -28
 1032              		.cfi_offset 7, -24
 1033              		.cfi_offset 8, -20
 1034              		.cfi_offset 9, -16
 1035              		.cfi_offset 10, -12
 1036              		.cfi_offset 11, -8
 1037              		.cfi_offset 14, -4
 1038              	@ armwave.c:176:     assert(out_buffer != NULL);
 173:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 174:armwave.c     ****     uint32_t offset;
 175:armwave.c     **** 
 176:armwave.c     ****     assert(out_buffer != NULL);
 1039              		.loc 1 176 5 view .LVU307
 1040 03f4 000050E3 		cmp	r0, #0	@ out_buffer
 1041              	@ armwave.c:172:     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 172:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 1042              		.loc 1 172 15 view .LVU308
 1043 03f8 44619FE5 		ldr	r6, .L77	@ tmp204,
 1044              	@ armwave.c:168: {
 168:armwave.c     ****     uint32_t xx, yy, ye, y, ysub, word, wave_word;
 1045              		.loc 1 168 1 view .LVU309
 1046 03fc 0CD04DE2 		sub	sp, sp, #12	@,,
 1047              		.cfi_def_cfa_offset 48
 1048              	@ armwave.c:172:     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 172:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 1049              		.loc 1 172 15 view .LVU310
 1050 0400 04E096E5 		ldr	lr, [r6, #4]	@ base_32ptr, g_armwave_state.ch1_buffer
 1051              	.LVL77:
 173:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 1052              		.loc 1 173 5 is_stmt 1 view .LVU311
 174:armwave.c     **** 
 1053              		.loc 1 174 5 view .LVU312
 1054              		.loc 1 176 5 view .LVU313
 1055 0404 4900000A 		beq	.L74		@,
 177:armwave.c     **** 
 178:armwave.c     ****     npix = g_armwave_state.target_width * 256; 
 1056              		.loc 1 178 5 view .LVU314
 1057              	@ armwave.c:178:     npix = g_armwave_state.target_width * 256; 
 1058              		.loc 1 178 41 is_stmt 0 view .LVU315
 1059 0408 4C8096E5 		ldr	r8, [r6, #76]	@ g_armwave_state.target_width, g_armwave_state.target_width
 1060 040c 0884A0E1 		lsl	r8, r8, #8	@ npix, g_armwave_state.target_width,
 1061              	.LVL78:
 179:armwave.c     ****     vscale = g_armwave_state.target_height >> 8;
 1062              		.loc 1 179 5 is_stmt 1 view .LVU316
 180:armwave.c     **** 
 181:armwave.c     ****     for(n = 0; n < npix; n += 4) {
 1063              		.loc 1 181 5 view .LVU317
 1064              		.loc 1 181 5 is_stmt 0 view .LVU318
 1065 0410 000058E3 		cmp	r8, #0	@ npix,
 1066 0414 0C0000DA 		ble	.L55		@,
 1067              	@ armwave.c:194:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 182:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 183:armwave.c     ****         // each byte.  We can afford to do this because most pixels will be blank for
 184:armwave.c     ****         // most normal waveforms.
 185:armwave.c     ****         wave_word = *base_32ptr++;
 186:armwave.c     **** 
 187:armwave.c     ****         if(COND_UNLIKELY(wave_word != 0)) {
 188:armwave.c     ****             for(w = 0; w < 4; w++) {
 189:armwave.c     ****                 value = wave_word & 0xff;
 190:armwave.c     ****                 wave_word >>= 8;
 191:armwave.c     **** 
 192:armwave.c     ****                 if(value != 0) {
 193:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 194:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 1068              		.loc 1 194 52 view .LVU319
 1069 0418 F236D6E1 		ldrsh	r3, [r6, #98]	@ _11, g_armwave_state.ch1_color.g
 1070              	@ armwave.c:193:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 193:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 1071              		.loc 1 193 52 view .LVU320
 1072 041c F0B6D6E1 		ldrsh	fp, [r6, #96]	@ _7, g_armwave_state.ch1_color.r
 1073              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 195:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 196:armwave.c     **** 
 197:armwave.c     ****                     r = MIN(rr, 255);
 198:armwave.c     ****                     g = MIN(gg, 255);
 199:armwave.c     ****                     b = MIN(bb, 255);
 200:armwave.c     **** 
 201:armwave.c     ****                     // Ensure 100% alpha channel, if it is used
 202:armwave.c     ****                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 203:armwave.c     **** 
 204:armwave.c     ****                     // Do line scaling as necessary.
 205:armwave.c     ****                     /*
 206:armwave.c     ****                     nsub = n + w;
 207:armwave.c     ****                     yy = (nsub & 0xff) * g_armwave_state.vscale;
 208:armwave.c     ****                     xx = (nsub >> 8);
 209:armwave.c     **** 
 210:armwave.c     ****                     for(row = 0; row < g_armwave_state.vscale; row++) {
 211:armwave.c     ****                         offset = (xx + ((yy + row) * g_armwave_state.target_width)); 
 212:armwave.c     ****                         *(out_buffer_base + offset) = word;
 213:armwave.c     ****                     }
 214:armwave.c     ****                     */
 215:armwave.c     **** 
 216:armwave.c     ****                     nsub = n + w;
 217:armwave.c     ****                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 1074              		.loc 1 217 57 view .LVU321
 1075 0420 076AD6ED 		vldr.32	s13, [r6, #28]	@ _28, g_armwave_state.vscale_frac
 1076              	@ armwave.c:194:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 194:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 1077              		.loc 1 194 52 view .LVU322
 1078 0424 00308DE5 		str	r3, [sp]	@ _11, %sfp
 1079              	@ armwave.c:195:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 195:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 1080              		.loc 1 195 52 view .LVU323
 1081 0428 F436D6E1 		ldrsh	r3, [r6, #100]	@ _14, g_armwave_state.ch1_color.b
 1082              	@ armwave.c:181:     for(n = 0; n < npix; n += 4) {
 181:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 1083              		.loc 1 181 11 view .LVU324
 1084 042c 0010A0E3 		mov	r1, #0	@ n,
 1085              	@ armwave.c:195:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 195:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 1086              		.loc 1 195 52 view .LVU325
 1087 0430 04308DE5 		str	r3, [sp, #4]	@ _14, %sfp
 1088              	.LVL79:
 1089              	.L62:
 185:armwave.c     **** 
 1090              		.loc 1 185 9 is_stmt 1 view .LVU326
 1091              	@ armwave.c:185:         wave_word = *base_32ptr++;
 185:armwave.c     **** 
 1092              		.loc 1 185 19 is_stmt 0 view .LVU327
 1093 0434 04309EE4 		ldr	r3, [lr], #4	@ wave_word, MEM[base: base_32ptr_54, offset: 4294967292B]
 1094              	.LVL80:
 187:armwave.c     ****             for(w = 0; w < 4; w++) {
 1095              		.loc 1 187 9 is_stmt 1 view .LVU328
 1096              	@ armwave.c:187:         if(COND_UNLIKELY(wave_word != 0)) {
 187:armwave.c     ****             for(w = 0; w < 4; w++) {
 1097              		.loc 1 187 11 is_stmt 0 view .LVU329
 1098 0438 000053E3 		cmp	r3, #0	@ wave_word,
 1099 043c 0400001A 		bne	.L75		@,
 1100              	.L58:
 1101              	@ armwave.c:181:     for(n = 0; n < npix; n += 4) {
 181:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 1102              		.loc 1 181 28 view .LVU330
 1103 0440 041081E2 		add	r1, r1, #4	@ n, n,
 1104              	.LVL81:
 1105              	@ armwave.c:181:     for(n = 0; n < npix; n += 4) {
 181:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 1106              		.loc 1 181 5 view .LVU331
 1107 0444 010058E1 		cmp	r8, r1	@ npix, n
 1108 0448 F9FFFFCA 		bgt	.L62		@,
 1109              	.LVL82:
 1110              	.L55:
 1111              	@ armwave.c:229: }
 218:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 219:armwave.c     ****                     xx = (nsub >> 8);
 220:armwave.c     **** 
 221:armwave.c     ****                     for(y = yy; y < ye; y++) {
 222:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 223:armwave.c     ****                         *(out_buffer_base + offset) = word;
 224:armwave.c     ****                     }
 225:armwave.c     ****                 }
 226:armwave.c     ****             }
 227:armwave.c     ****         }
 228:armwave.c     ****     }
 229:armwave.c     **** }
 1112              		.loc 1 229 1 view .LVU332
 1113 044c 0CD08DE2 		add	sp, sp, #12	@,,
 1114              		.cfi_remember_state
 1115              		.cfi_def_cfa_offset 36
 1116              		@ sp needed	@
 1117 0450 F08FBDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}	@
 1118              	.LVL83:
 1119              	.L75:
 1120              		.cfi_restore_state
 1121              	@ armwave.c:192:                 if(value != 0) {
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 1122              		.loc 1 192 19 view .LVU333
 1123 0454 FF2013E2 		ands	r2, r3, #255	@ _8, wave_word,
 1124              	@ armwave.c:188:             for(w = 0; w < 4; w++) {
 188:armwave.c     ****                 value = wave_word & 0xff;
 1125              		.loc 1 188 19 view .LVU334
 1126 0458 0070A0E3 		mov	r7, #0	@ w,
 1127              	.LVL84:
 189:armwave.c     ****                 wave_word >>= 8;
 1128              		.loc 1 189 17 is_stmt 1 view .LVU335
 190:armwave.c     **** 
 1129              		.loc 1 190 17 view .LVU336
 1130              	@ armwave.c:190:                 wave_word >>= 8;
 190:armwave.c     **** 
 1131              		.loc 1 190 27 is_stmt 0 view .LVU337
 1132 045c 2334A0E1 		lsr	r3, r3, #8	@ wave_word, wave_word,
 1133              	.LVL85:
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 1134              		.loc 1 192 17 is_stmt 1 view .LVU338
 1135              	@ armwave.c:192:                 if(value != 0) {
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 1136              		.loc 1 192 19 is_stmt 0 view .LVU339
 1137 0460 0500001A 		bne	.L76		@,
 1138              	.L59:
 1139              	@ armwave.c:188:             for(w = 0; w < 4; w++) {
 188:armwave.c     ****                 value = wave_word & 0xff;
 1140              		.loc 1 188 32 view .LVU340
 1141 0464 017087E2 		add	r7, r7, #1	@ w, w,
 1142              	.LVL86:
 1143              	@ armwave.c:188:             for(w = 0; w < 4; w++) {
 188:armwave.c     ****                 value = wave_word & 0xff;
 1144              		.loc 1 188 13 view .LVU341
 1145 0468 040057E3 		cmp	r7, #4	@ w,
 1146 046c F3FFFF0A 		beq	.L58		@,
 189:armwave.c     ****                 wave_word >>= 8;
 1147              		.loc 1 189 17 is_stmt 1 view .LVU342
 1148              	.LVL87:
 190:armwave.c     **** 
 1149              		.loc 1 190 17 view .LVU343
 1150              	@ armwave.c:192:                 if(value != 0) {
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 1151              		.loc 1 192 19 is_stmt 0 view .LVU344
 1152 0470 FF2013E2 		ands	r2, r3, #255	@ _8, wave_word,
 1153              	@ armwave.c:190:                 wave_word >>= 8;
 190:armwave.c     **** 
 1154              		.loc 1 190 27 view .LVU345
 1155 0474 2334A0E1 		lsr	r3, r3, #8	@ wave_word, wave_word,
 1156              	.LVL88:
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 1157              		.loc 1 192 17 is_stmt 1 view .LVU346
 1158              	@ armwave.c:192:                 if(value != 0) {
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 1159              		.loc 1 192 19 is_stmt 0 view .LVU347
 1160 0478 F9FFFF0A 		beq	.L59		@,
 1161              	.L76:
 193:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 1162              		.loc 1 193 21 is_stmt 1 view .LVU348
 1163              	.LVL89:
 194:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 1164              		.loc 1 194 21 view .LVU349
 195:armwave.c     **** 
 1165              		.loc 1 195 21 view .LVU350
 197:armwave.c     ****                     g = MIN(gg, 255);
 1166              		.loc 1 197 21 view .LVU351
 198:armwave.c     ****                     b = MIN(bb, 255);
 1167              		.loc 1 198 21 view .LVU352
 199:armwave.c     **** 
 1168              		.loc 1 199 21 view .LVU353
 202:armwave.c     **** 
 1169              		.loc 1 202 21 view .LVU354
 1170              	@ armwave.c:195:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 195:armwave.c     **** 
 1171              		.loc 1 195 55 is_stmt 0 view .LVU355
 1172 047c 04C09DE5 		ldr	ip, [sp, #4]	@ _14, %sfp
 1173 0480 075081E0 		add	r5, r1, r7	@ _117, n, w
 1174 0484 9C020AE0 		mul	r10, ip, r2	@ tmp182, _14, _8
 1175              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 1176              		.loc 1 217 32 view .LVU356
 1177 0488 75C0EFE6 		uxtb	ip, r5	@ _26, _117
 1178              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 1179              		.loc 1 218 41 view .LVU357
 1180 048c 01408CE2 		add	r4, ip, #1	@ tmp197, _26,
 1181              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 1182              		.loc 1 217 40 view .LVU358
 1183 0490 90CA07EE 		vmov	s15, ip	@ int	@ _26, _26
 1184              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 1185              		.loc 1 218 41 view .LVU359
 1186 0494 104A07EE 		vmov	s14, r4	@ int	@ tmp197, tmp197
 1187              	@ armwave.c:194:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 194:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 1188              		.loc 1 194 55 view .LVU360
 1189 0498 00C09DE5 		ldr	ip, [sp]	@ _11, %sfp
 1190              	@ armwave.c:195:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 195:armwave.c     **** 
 1191              		.loc 1 195 24 view .LVU361
 1192 049c 4AA4A0E1 		asr	r10, r10, #8	@ bb, tmp182,
 1193              	.LVL90:
 1194              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 1195              		.loc 1 217 40 view .LVU362
 1196 04a0 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp195, _26
 1197              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 1198              		.loc 1 218 46 view .LVU363
 1199 04a4 C77AB8EE 		vcvt.f32.s32	s14, s14	@ tmp198, tmp197
 1200              	@ armwave.c:194:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 194:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 1201              		.loc 1 194 55 view .LVU364
 1202 04a8 9C0204E0 		mul	r4, ip, r2	@ tmp186, _11, _8
 1203              	@ armwave.c:193:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 193:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 1204              		.loc 1 193 55 view .LVU365
 1205 04ac 920B02E0 		mul	r2, r2, fp	@ tmp192, _8, _7
 1206              	.LVL91:
 1207              	@ armwave.c:199:                     b = MIN(bb, 255);
 199:armwave.c     **** 
 1208              		.loc 1 199 25 view .LVU366
 1209 04b0 FF005AE3 		cmp	r10, #255	@ bb,
 1210              	@ armwave.c:194:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 194:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 1211              		.loc 1 194 24 view .LVU367
 1212 04b4 4444A0E1 		asr	r4, r4, #8	@ gg, tmp186,
 1213              	.LVL92:
 1214              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 1215              		.loc 1 217 40 view .LVU368
 1216 04b8 A67A67EE 		vmul.f32	s15, s15, s13	@ tmp196, tmp195, _28
 1217              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 1218              		.loc 1 218 46 view .LVU369
 1219 04bc 267A27EE 		vmul.f32	s14, s14, s13	@ tmp199, tmp198, _28
 1220              	@ armwave.c:193:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 193:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 1221              		.loc 1 193 24 view .LVU370
 1222 04c0 42C4A0E1 		asr	ip, r2, #8	@ rr, tmp192,
 1223              	.LVL93:
 1224              	@ armwave.c:199:                     b = MIN(bb, 255);
 199:armwave.c     **** 
 1225              		.loc 1 199 25 view .LVU371
 1226 04c4 FFA0A0A3 		movge	r10, #255	@ bb,
 1227              	.LVL94:
 1228              	@ armwave.c:198:                     g = MIN(gg, 255);
 198:armwave.c     ****                     b = MIN(bb, 255);
 1229              		.loc 1 198 25 view .LVU372
 1230 04c8 FF0054E3 		cmp	r4, #255	@ gg,
 1231 04cc FF40A0A3 		movge	r4, #255	@ gg,
 1232              	.LVL95:
 1233              	@ armwave.c:197:                     r = MIN(rr, 255);
 197:armwave.c     ****                     g = MIN(gg, 255);
 1234              		.loc 1 197 25 view .LVU373
 1235 04d0 FF005CE3 		cmp	ip, #255	@ rr,
 1236              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 1237              		.loc 1 202 56 view .LVU374
 1238 04d4 0444A0E1 		lsl	r4, r4, #8	@ tmp187, gg,
 1239              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 1240              		.loc 1 217 24 view .LVU375
 1241 04d8 E77AFCEE 		vcvt.u32.f32	s15, s15	@ yy, tmp196
 1242              	@ armwave.c:197:                     r = MIN(rr, 255);
 197:armwave.c     ****                     g = MIN(gg, 255);
 1243              		.loc 1 197 25 view .LVU376
 1244 04dc FFC0A0A3 		movge	ip, #255	@ rr,
 1245              	.LVL96:
 1246              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 1247              		.loc 1 202 44 view .LVU377
 1248 04e0 0AA8A0E1 		lsl	r10, r10, #16	@ tmp183, bb,
 1249 04e4 FFA80AE2 		and	r10, r10, #16711680	@ tmp184, tmp183,
 1250              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 1251              		.loc 1 202 56 view .LVU378
 1252 04e8 7440FFE6 		uxth	r4, r4	@ tmp188, tmp187
 1253              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 1254              		.loc 1 202 51 view .LVU379
 1255 04ec 04408AE1 		orr	r4, r10, r4	@ tmp190, tmp184, tmp188
 1256              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 1257              		.loc 1 202 62 view .LVU380
 1258 04f0 7CC0EFE6 		uxtb	ip, ip	@ rr, rr
 1259 04f4 0CC084E1 		orr	ip, r4, ip	@ tmp194, tmp190, rr
 1260              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 1261              		.loc 1 217 24 view .LVU381
 1262 04f8 902A17EE 		vmov	r2, s15	@ int	@ yy, yy
 1263              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 1264              		.loc 1 218 24 view .LVU382
 1265 04fc C77AFCEE 		vcvt.u32.f32	s15, s14	@ ye, tmp199
 1266              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 1267              		.loc 1 202 26 view .LVU383
 1268 0500 FF448CE3 		orr	r4, ip, #-16777216	@ word, tmp194,
 1269              	.LVL97:
 216:armwave.c     ****                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 1270              		.loc 1 216 21 is_stmt 1 view .LVU384
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 1271              		.loc 1 217 21 view .LVU385
 218:armwave.c     ****                     xx = (nsub >> 8);
 1272              		.loc 1 218 21 view .LVU386
 1273              	@ armwave.c:219:                     xx = (nsub >> 8);
 219:armwave.c     **** 
 1274              		.loc 1 219 32 is_stmt 0 view .LVU387
 1275 0504 4554A0E1 		asr	r5, r5, #8	@ xx, _117,
 1276              	.LVL98:
 1277              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 1278              		.loc 1 218 24 view .LVU388
 1279 0508 909A17EE 		vmov	r9, s15	@ int	@ ye, ye
 1280              	.LVL99:
 219:armwave.c     **** 
 1281              		.loc 1 219 21 is_stmt 1 view .LVU389
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 1282              		.loc 1 221 21 view .LVU390
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 1283              		.loc 1 221 21 is_stmt 0 view .LVU391
 1284 050c 090052E1 		cmp	r2, r9	@ yy, ye
 1285 0510 D3FFFF2A 		bcs	.L59		@,
 1286              	.LVL100:
 1287              	.L60:
 222:armwave.c     ****                         *(out_buffer_base + offset) = word;
 1288              		.loc 1 222 25 is_stmt 1 discriminator 3 view .LVU392
 223:armwave.c     ****                     }
 1289              		.loc 1 223 25 discriminator 3 view .LVU393
 1290              	@ armwave.c:222:                         offset = (xx + (y * g_armwave_state.target_width)); 
 222:armwave.c     ****                         *(out_buffer_base + offset) = word;
 1291              		.loc 1 222 43 is_stmt 0 discriminator 3 view .LVU394
 1292 0514 4CC096E5 		ldr	ip, [r6, #76]	@ g_armwave_state.target_width, g_armwave_state.target_width
 1293              	@ armwave.c:223:                         *(out_buffer_base + offset) = word;
 223:armwave.c     ****                     }
 1294              		.loc 1 223 43 discriminator 3 view .LVU395
 1295 0518 9C522CE0 		mla	ip, ip, r2, r5	@ tmp203, g_armwave_state.target_width, yy, xx
 1296              	.LVL101:
 1297              	@ armwave.c:221:                     for(y = yy; y < ye; y++) {
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 1298              		.loc 1 221 42 discriminator 3 view .LVU396
 1299 051c 012082E2 		add	r2, r2, #1	@ yy, yy,
 1300              	.LVL102:
 1301              	@ armwave.c:221:                     for(y = yy; y < ye; y++) {
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 1302              		.loc 1 221 21 discriminator 3 view .LVU397
 1303 0520 020059E1 		cmp	r9, r2	@ ye, yy
 1304              	@ armwave.c:223:                         *(out_buffer_base + offset) = word;
 223:armwave.c     ****                     }
 1305              		.loc 1 223 53 discriminator 3 view .LVU398
 1306 0524 0C4180E7 		str	r4, [r0, ip, lsl #2]	@ word, *_37
 1307              	@ armwave.c:221:                     for(y = yy; y < ye; y++) {
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 1308              		.loc 1 221 21 discriminator 3 view .LVU399
 1309 0528 F9FFFF1A 		bne	.L60		@,
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 1310              		.loc 1 221 21 discriminator 3 view .LVU400
 1311 052c CCFFFFEA 		b	.L59		@
 1312              	.LVL103:
 1313              	.L74:
 176:armwave.c     **** 
 1314              		.loc 1 176 5 is_stmt 1 discriminator 1 view .LVU401
 1315 0530 10309FE5 		ldr	r3, .L77+4	@,
 1316 0534 B020A0E3 		mov	r2, #176	@,
 1317 0538 0C109FE5 		ldr	r1, .L77+8	@,
 1318 053c 0C009FE5 		ldr	r0, .L77+12	@,
 1319              	.LVL104:
 176:armwave.c     **** 
 1320              		.loc 1 176 5 is_stmt 0 discriminator 1 view .LVU402
 1321 0540 FEFFFFEB 		bl	__assert_fail		@
 1322              	.LVL105:
 1323              	.L78:
 176:armwave.c     **** 
 1324              		.loc 1 176 5 discriminator 1 view .LVU403
 1325              		.align	2
 1326              	.L77:
 1327 0544 00000000 		.word	g_armwave_state
 1328 0548 18000000 		.word	.LANCHOR0+24
 1329 054c 20000000 		.word	.LC2
 1330 0550 2C000000 		.word	.LC3
 1331              		.cfi_endproc
 1332              	.LFE61:
 1334              		.align	2
 1335              		.global	armwave_setup_render
 1336              		.syntax unified
 1337              		.arm
 1338              		.fpu vfp
 1340              	armwave_setup_render:
 1341              	.LVL106:
 1342              	.LFB62:
 230:armwave.c     **** 
 231:armwave.c     **** /*
 232:armwave.c     ****  * Setup the renderer with passed parameters.
 233:armwave.c     ****  */
 234:armwave.c     **** void armwave_setup_render(uint32_t start_point, uint32_t end_point, uint32_t waves_max, uint32_t wa
 235:armwave.c     **** {
 1343              		.loc 1 235 1 is_stmt 1 view -0
 1344              		.cfi_startproc
 1345              		@ args = 12, pretend = 0, frame = 0
 1346              		@ frame_needed = 0, uses_anonymous_args = 0
 236:armwave.c     ****     uint32_t length, xx;
 1347              		.loc 1 236 5 view .LVU405
 237:armwave.c     ****     float points_per_pixel;
 1348              		.loc 1 237 5 view .LVU406
 238:armwave.c     **** 
 239:armwave.c     ****     printf("s=%d e=%d w=%d ws=%d tw=%d th=%d rf=0x%08x\n", start_point, end_point, waves_max, wave_
 1349              		.loc 1 239 5 view .LVU407
 1350              	@ armwave.c:235: {
 235:armwave.c     ****     uint32_t length, xx;
 1351              		.loc 1 235 1 is_stmt 0 view .LVU408
 1352 0554 F0472DE9 		push	{r4, r5, r6, r7, r8, r9, r10, lr}	@
 1353              		.cfi_def_cfa_offset 32
 1354              		.cfi_offset 4, -32
 1355              		.cfi_offset 5, -28
 1356              		.cfi_offset 6, -24
 1357              		.cfi_offset 7, -20
 1358              		.cfi_offset 8, -16
 1359              		.cfi_offset 9, -12
 1360              		.cfi_offset 10, -8
 1361              		.cfi_offset 14, -4
 1362 0558 028B2DED 		vpush.64	{d8}	@
 1363              		.cfi_def_cfa_offset 40
 1364              		.cfi_offset 80, -40
 1365              		.cfi_offset 81, -36
 1366 055c 0050A0E1 		mov	r5, r0	@ start_point, start_point
 1367 0560 0190A0E1 		mov	r9, r1	@ end_point, end_point
 1368 0564 0280A0E1 		mov	r8, r2	@ waves_max, waves_max
 1369 0568 10D04DE2 		sub	sp, sp, #16	@,,
 1370              		.cfi_def_cfa_offset 56
 1371              	@ armwave.c:235: {
 235:armwave.c     ****     uint32_t length, xx;
 1372              		.loc 1 235 1 view .LVU409
 1373 056c 03A0A0E1 		mov	r10, r3	@ wave_stride, wave_stride
 1374 0570 D863CDE1 		ldrd	r6, [sp, #56]	@,,
 1375 0574 40C09DE5 		ldr	ip, [sp, #64]	@ render_flags, render_flags
 1376              	@ armwave.c:239:     printf("s=%d e=%d w=%d ws=%d tw=%d th=%d rf=0x%08x\n", start_point, end_point,
 1377              		.loc 1 239 5 view .LVU410
 1378 0578 00308DE5 		str	r3, [sp]	@ wave_stride,
 1379 057c F460CDE1 		strd	r6, [sp, #4]	@,,
 1380 0580 0230A0E1 		mov	r3, r2	@, waves_max
 1381              	.LVL107:
 1382              		.loc 1 239 5 view .LVU411
 1383 0584 0CC08DE5 		str	ip, [sp, #12]	@ render_flags,
 1384 0588 0120A0E1 		mov	r2, r1	@, end_point
 1385              	.LVL108:
 1386              		.loc 1 239 5 view .LVU412
 1387 058c 0010A0E1 		mov	r1, r0	@, start_point
 1388              	.LVL109:
 1389              		.loc 1 239 5 view .LVU413
 1390 0590 94019FE5 		ldr	r0, .L93+8	@,
 1391              	.LVL110:
 1392              		.loc 1 239 5 view .LVU414
 1393 0594 FEFFFFEB 		bl	printf		@
 1394              	.LVL111:
 240:armwave.c     **** 
 241:armwave.c     ****     // TODO these asserts should instead raise PyExc
 242:armwave.c     ****     assert(start_point < end_point);
 1395              		.loc 1 242 5 is_stmt 1 view .LVU415
 1396 0598 090055E1 		cmp	r5, r9	@ start_point, end_point
 1397 059c 5100002A 		bcs	.L90		@,
 243:armwave.c     **** 
 244:armwave.c     ****     /*
 245:armwave.c     ****     // target_height must be a power of two.  Only 256, 512, 1024 and 2048 height buffers are suppo
 246:armwave.c     ****     assert(target_height == 256 || target_height == 512 || target_height == 1024 || target_height =
 247:armwave.c     **** 
 248:armwave.c     ****     if(target_height == 256) {
 249:armwave.c     ****         g_armwave_state.row_shift = 8;
 250:armwave.c     ****         g_armwave_state.row_mask = 0x0ff;
 251:armwave.c     ****     } else if(target_height == 512) {
 252:armwave.c     ****         g_armwave_state.row_shift = 9;
 253:armwave.c     ****         g_armwave_state.row_mask = 0x1ff;
 254:armwave.c     ****     } else if(target_height == 1024) {
 255:armwave.c     ****         g_armwave_state.row_shift = 10;
 256:armwave.c     ****         g_armwave_state.row_mask = 0x3ff;
 257:armwave.c     ****     } else if(target_height == 2048) {
 258:armwave.c     ****         g_armwave_state.row_shift = 11;
 259:armwave.c     ****         g_armwave_state.row_mask = 0x7ff;
 260:armwave.c     ****     }
 261:armwave.c     ****     */
 262:armwave.c     **** 
 263:armwave.c     ****     // Calculate the size of each buffer.  Buffers are rotated by 90 degrees to improve cache coher
 264:armwave.c     ****     g_armwave_state.xstride = target_height;
 1398              		.loc 1 264 5 view .LVU416
 1399              	@ armwave.c:265:     g_armwave_state.vscale_frac = target_height / 255.0f;
 265:armwave.c     ****     g_armwave_state.vscale_frac = target_height / 255.0f;
 1400              		.loc 1 265 49 is_stmt 0 view .LVU417
 1401 05a0 907A07EE 		vmov	s15, r7	@ int	@ target_height, target_height
 1402 05a4 5E7A9FED 		vldr.32	s14, .L93	@ tmp156,
 1403              	@ armwave.c:264:     g_armwave_state.xstride = target_height;
 264:armwave.c     ****     g_armwave_state.vscale_frac = target_height / 255.0f;
 1404              		.loc 1 264 29 view .LVU418
 1405 05a8 80419FE5 		ldr	r4, .L93+12	@ tmp212,
 1406              	@ armwave.c:270:     g_armwave_state.size = target_height * target_width;
 266:armwave.c     ****     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 267:armwave.c     ****     g_armwave_state.wave_stride = wave_stride;
 268:armwave.c     ****     g_armwave_state.waves_max = waves_max;
 269:armwave.c     ****     g_armwave_state.waves = waves_max;  // Need a function to be able to change this on the fly
 270:armwave.c     ****     g_armwave_state.size = target_height * target_width;
 1407              		.loc 1 270 42 view .LVU419
 1408 05ac 970600E0 		mul	r0, r7, r6	@ tmp164, target_height, target_width
 1409              	@ armwave.c:265:     g_armwave_state.vscale_frac = target_height / 255.0f;
 265:armwave.c     ****     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 1410              		.loc 1 265 49 view .LVU420
 1411 05b0 676AF8EE 		vcvt.f32.u32	s13, s15	@ tmp155, target_height
 1412              	@ armwave.c:272:     g_armwave_state.ch_buff_size = g_armwave_state.bitdepth_height * target_width;
 271:armwave.c     ****     g_armwave_state.bitdepth_height = 256;  // Always 256 possible levels in 8-bit mode
 272:armwave.c     ****     g_armwave_state.ch_buff_size = g_armwave_state.bitdepth_height * target_width;
 1413              		.loc 1 272 68 view .LVU421
 1414 05b4 0634A0E1 		lsl	r3, r6, #8	@ _6, target_width,
 1415              	@ armwave.c:271:     g_armwave_state.bitdepth_height = 256;  // Always 256 possible levels in 8-bit
 271:armwave.c     ****     g_armwave_state.bitdepth_height = 256;  // Always 256 possible levels in 8-bit mode
 1416              		.loc 1 271 37 view .LVU422
 1417 05b8 012CA0E3 		mov	r2, #256	@ tmp166,
 1418              	@ armwave.c:277:     printf("ch_buff_size=%d\n", g_armwave_state.ch_buff_size);
 273:armwave.c     ****     g_armwave_state.target_width = target_width;
 274:armwave.c     ****     g_armwave_state.target_height = target_height;
 275:armwave.c     ****     g_armwave_state.wave_length = end_point - start_point;
 276:armwave.c     **** 
 277:armwave.c     ****     printf("ch_buff_size=%d\n", g_armwave_state.ch_buff_size);
 1419              		.loc 1 277 5 view .LVU423
 1420 05bc 0310A0E1 		mov	r1, r3	@, _6
 1421              	@ armwave.c:270:     g_armwave_state.size = target_height * target_width;
 270:armwave.c     ****     g_armwave_state.bitdepth_height = 256;  // Always 256 possible levels in 8-bit mode
 1422              		.loc 1 270 26 view .LVU424
 1423 05c0 480084E5 		str	r0, [r4, #72]	@ tmp164, g_armwave_state.size
 1424              	@ armwave.c:275:     g_armwave_state.wave_length = end_point - start_point;
 275:armwave.c     **** 
 1425              		.loc 1 275 45 view .LVU425
 1426 05c4 055049E0 		sub	r5, r9, r5	@ _7, end_point, start_point
 1427              	.LVL112:
 1428              	@ armwave.c:277:     printf("ch_buff_size=%d\n", g_armwave_state.ch_buff_size);
 1429              		.loc 1 277 5 view .LVU426
 1430 05c8 64019FE5 		ldr	r0, .L93+16	@,
 1431              	@ armwave.c:272:     g_armwave_state.ch_buff_size = g_armwave_state.bitdepth_height * target_width;
 272:armwave.c     ****     g_armwave_state.target_width = target_width;
 1432              		.loc 1 272 34 view .LVU427
 1433 05cc 443084E5 		str	r3, [r4, #68]	@ _6, g_armwave_state.ch_buff_size
 1434              	@ armwave.c:265:     g_armwave_state.vscale_frac = target_height / 255.0f;
 265:armwave.c     ****     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 1435              		.loc 1 265 49 view .LVU428
 1436 05d0 877AC6EE 		vdiv.f32	s15, s13, s14	@ _2, tmp155, tmp156
 1437              	@ armwave.c:264:     g_armwave_state.xstride = target_height;
 264:armwave.c     ****     g_armwave_state.vscale_frac = target_height / 255.0f;
 1438              		.loc 1 264 29 view .LVU429
 1439 05d4 207084E5 		str	r7, [r4, #32]	@ target_height, g_armwave_state.xstride
 265:armwave.c     ****     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 1440              		.loc 1 265 5 is_stmt 1 view .LVU430
 1441              	@ armwave.c:267:     g_armwave_state.wave_stride = wave_stride;
 267:armwave.c     ****     g_armwave_state.waves_max = waves_max;
 1442              		.loc 1 267 33 is_stmt 0 view .LVU431
 1443 05d8 28A084E5 		str	r10, [r4, #40]	@ wave_stride, g_armwave_state.wave_stride
 1444              	@ armwave.c:268:     g_armwave_state.waves_max = waves_max;
 268:armwave.c     ****     g_armwave_state.waves = waves_max;  // Need a function to be able to change this on the fly
 1445              		.loc 1 268 31 view .LVU432
 1446 05dc 308084E5 		str	r8, [r4, #48]	@ waves_max, g_armwave_state.waves_max
 1447              	@ armwave.c:269:     g_armwave_state.waves = waves_max;  // Need a function to be able to change th
 269:armwave.c     ****     g_armwave_state.size = target_height * target_width;
 1448              		.loc 1 269 27 view .LVU433
 1449 05e0 2C8084E5 		str	r8, [r4, #44]	@ waves_max, g_armwave_state.waves
 1450              	@ armwave.c:274:     g_armwave_state.target_height = target_height;
 274:armwave.c     ****     g_armwave_state.wave_length = end_point - start_point;
 1451              		.loc 1 274 35 view .LVU434
 1452 05e4 FC64C4E1 		strd	r6, [r4, #76]	@, tmp212,
 1453              	@ armwave.c:275:     g_armwave_state.wave_length = end_point - start_point;
 275:armwave.c     **** 
 1454              		.loc 1 275 33 view .LVU435
 1455 05e8 405084E5 		str	r5, [r4, #64]	@ _7, g_armwave_state.wave_length
 1456              	@ armwave.c:271:     g_armwave_state.bitdepth_height = 256;  // Always 256 possible levels in 8-bit
 271:armwave.c     ****     g_armwave_state.ch_buff_size = g_armwave_state.bitdepth_height * target_width;
 1457              		.loc 1 271 37 view .LVU436
 1458 05ec 342084E5 		str	r2, [r4, #52]	@ tmp166, g_armwave_state.bitdepth_height
 1459              	@ armwave.c:266:     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 266:armwave.c     ****     g_armwave_state.wave_stride = wave_stride;
 1460              		.loc 1 266 30 view .LVU437
 1461 05f0 E77ABDEE 		vcvt.s32.f32	s14, s15	@ tmp159, _2
 1462              	@ armwave.c:265:     g_armwave_state.vscale_frac = target_height / 255.0f;
 265:armwave.c     ****     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 1463              		.loc 1 265 33 view .LVU438
 1464 05f4 077AC4ED 		vstr.32	s15, [r4, #28]	@ _2, g_armwave_state.vscale_frac
 266:armwave.c     ****     g_armwave_state.wave_stride = wave_stride;
 1465              		.loc 1 266 5 is_stmt 1 view .LVU439
 1466              	@ armwave.c:266:     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 266:armwave.c     ****     g_armwave_state.wave_stride = wave_stride;
 1467              		.loc 1 266 30 is_stmt 0 view .LVU440
 1468 05f8 097A84ED 		vstr.32	s14, [r4, #36]	@ int	@ tmp159, g_armwave_state.vscale
 267:armwave.c     ****     g_armwave_state.waves_max = waves_max;
 1469              		.loc 1 267 5 is_stmt 1 view .LVU441
 268:armwave.c     ****     g_armwave_state.waves = waves_max;  // Need a function to be able to change this on the fly
 1470              		.loc 1 268 5 view .LVU442
 269:armwave.c     ****     g_armwave_state.size = target_height * target_width;
 1471              		.loc 1 269 5 view .LVU443
 270:armwave.c     ****     g_armwave_state.bitdepth_height = 256;  // Always 256 possible levels in 8-bit mode
 1472              		.loc 1 270 5 view .LVU444
 271:armwave.c     ****     g_armwave_state.ch_buff_size = g_armwave_state.bitdepth_height * target_width;
 1473              		.loc 1 271 5 view .LVU445
 272:armwave.c     ****     g_armwave_state.target_width = target_width;
 1474              		.loc 1 272 5 view .LVU446
 273:armwave.c     ****     g_armwave_state.target_height = target_height;
 1475              		.loc 1 273 5 view .LVU447
 274:armwave.c     ****     g_armwave_state.wave_length = end_point - start_point;
 1476              		.loc 1 274 5 view .LVU448
 275:armwave.c     **** 
 1477              		.loc 1 275 5 view .LVU449
 1478              		.loc 1 277 5 view .LVU450
 1479 05fc FEFFFFEB 		bl	printf		@
 1480              	.LVL113:
 278:armwave.c     **** 
 279:armwave.c     ****     // In 1ch mode, target 1024 x 16 render buffer, reading 16 bytes at a time from each wave, reta
 280:armwave.c     ****     // In 2ch mode, target two 1024 x 8 render buffers, reading 16 bytes at a time from each wave
 281:armwave.c     ****     // In 4ch mode, target four 1024 x 4 render buffers, reading 16 bytes at a time from each wave
 282:armwave.c     ****     g_armwave_state.slice_height = 64;  
 1481              		.loc 1 282 5 view .LVU451
 1482              	@ armwave.c:284:     if(g_armwave_state.ch1_buffer != NULL)
 283:armwave.c     **** 
 284:armwave.c     ****     if(g_armwave_state.ch1_buffer != NULL)
 1483              		.loc 1 284 23 is_stmt 0 view .LVU452
 1484 0600 040094E5 		ldr	r0, [r4, #4]	@ _8, g_armwave_state.ch1_buffer
 1485              	@ armwave.c:282:     g_armwave_state.slice_height = 64;  
 282:armwave.c     **** 
 1486              		.loc 1 282 34 view .LVU453
 1487 0604 4030A0E3 		mov	r3, #64	@ tmp173,
 1488              	@ armwave.c:284:     if(g_armwave_state.ch1_buffer != NULL)
 1489              		.loc 1 284 7 view .LVU454
 1490 0608 000050E3 		cmp	r0, #0	@ _8,
 1491              	@ armwave.c:282:     g_armwave_state.slice_height = 64;  
 282:armwave.c     **** 
 1492              		.loc 1 282 34 view .LVU455
 1493 060c 383084E5 		str	r3, [r4, #56]	@ tmp173, g_armwave_state.slice_height
 1494              		.loc 1 284 5 is_stmt 1 view .LVU456
 1495              	@ armwave.c:284:     if(g_armwave_state.ch1_buffer != NULL)
 1496              		.loc 1 284 7 is_stmt 0 view .LVU457
 1497 0610 0000000A 		beq	.L81		@,
 285:armwave.c     ****         free(g_armwave_state.ch1_buffer);
 1498              		.loc 1 285 9 is_stmt 1 view .LVU458
 1499 0614 FEFFFFEB 		bl	free		@
 1500              	.LVL114:
 1501              	.L81:
 286:armwave.c     **** 
 287:armwave.c     ****     g_armwave_state.ch1_buffer = calloc(g_armwave_state.ch_buff_size, 1);
 1502              		.loc 1 287 5 view .LVU459
 1503              	@ armwave.c:287:     g_armwave_state.ch1_buffer = calloc(g_armwave_state.ch_buff_size, 1);
 1504              		.loc 1 287 34 is_stmt 0 view .LVU460
 1505 0618 0110A0E3 		mov	r1, #1	@,
 1506 061c 440094E5 		ldr	r0, [r4, #68]	@, g_armwave_state.ch_buff_size
 1507 0620 FEFFFFEB 		bl	calloc		@
 1508              	.LVL115:
 1509              	@ armwave.c:289:     assert(g_armwave_state.ch1_buffer != NULL);
 288:armwave.c     **** 
 289:armwave.c     ****     assert(g_armwave_state.ch1_buffer != NULL);
 1510              		.loc 1 289 5 view .LVU461
 1511 0624 000050E3 		cmp	r0, #0	@ _10,
 1512              	@ armwave.c:287:     g_armwave_state.ch1_buffer = calloc(g_armwave_state.ch_buff_size, 1);
 287:armwave.c     **** 
 1513              		.loc 1 287 34 view .LVU462
 1514 0628 0070A0E1 		mov	r7, r0	@ _10,
 1515              	@ armwave.c:287:     g_armwave_state.ch1_buffer = calloc(g_armwave_state.ch_buff_size, 1);
 287:armwave.c     **** 
 1516              		.loc 1 287 32 view .LVU463
 1517 062c 040084E5 		str	r0, [r4, #4]	@ _10, g_armwave_state.ch1_buffer
 1518              		.loc 1 289 5 is_stmt 1 view .LVU464
 1519 0630 3600000A 		beq	.L91		@,
 290:armwave.c     **** 
 291:armwave.c     ****     // Precompute the x-coord to pixel lookup to reduce ALU load
 292:armwave.c     ****     length = end_point - start_point;
 1520              		.loc 1 292 5 view .LVU465
 1521              	.LVL116:
 293:armwave.c     ****     points_per_pixel = length / ((float)(target_width));
 1522              		.loc 1 293 5 view .LVU466
 1523              	@ armwave.c:293:     points_per_pixel = length / ((float)(target_width));
 1524              		.loc 1 293 34 is_stmt 0 view .LVU467
 1525 0634 906A07EE 		vmov	s15, r6	@ int	@ target_width, target_width
 1526              	@ armwave.c:293:     points_per_pixel = length / ((float)(target_width));
 1527              		.loc 1 293 22 view .LVU468
 1528 0638 905A06EE 		vmov	s13, r5	@ int	@ _7, _7
 1529              	@ armwave.c:295:     g_armwave_state.xcoord_to_xpixel = malloc(length * sizeof(uint16_t));
 294:armwave.c     ****     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice_height;
 295:armwave.c     ****     g_armwave_state.xcoord_to_xpixel = malloc(length * sizeof(uint16_t));
 1530              		.loc 1 295 40 view .LVU469
 1531 063c 8500A0E1 		lsl	r0, r5, #1	@, _7,
 1532              	@ armwave.c:293:     points_per_pixel = length / ((float)(target_width));
 293:armwave.c     ****     points_per_pixel = length / ((float)(target_width));
 1533              		.loc 1 293 34 view .LVU470
 1534 0640 677AB8EE 		vcvt.f32.u32	s14, s15	@ tmp185, target_width
 1535              	@ armwave.c:293:     points_per_pixel = length / ((float)(target_width));
 293:armwave.c     ****     points_per_pixel = length / ((float)(target_width));
 1536              		.loc 1 293 22 view .LVU471
 1537 0644 666AF8EE 		vcvt.f32.u32	s13, s13	@ tmp184, _7
 1538              	@ armwave.c:294:     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice
 294:armwave.c     ****     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice_height;
 1539              		.loc 1 294 60 view .LVU472
 1540 0648 0E7AD4ED 		vldr.32	s15, [r4, #56]	@ int	@ tmp218, g_armwave_state.slice_height
 1541 064c 677AF8EE 		vcvt.f32.u32	s15, s15	@ tmp188, tmp218
 1542              	@ armwave.c:293:     points_per_pixel = length / ((float)(target_width));
 293:armwave.c     ****     points_per_pixel = length / ((float)(target_width));
 1543              		.loc 1 293 22 view .LVU473
 1544 0650 878A86EE 		vdiv.f32	s16, s13, s14	@ points_per_pixel, tmp184, tmp185
 1545              	.LVL117:
 294:armwave.c     ****     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice_height;
 1546              		.loc 1 294 5 is_stmt 1 view .LVU474
 1547              	@ armwave.c:294:     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice
 294:armwave.c     ****     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice_height;
 1548              		.loc 1 294 60 is_stmt 0 view .LVU475
 1549 0654 887A67EE 		vmul.f32	s15, s15, s16	@ tmp190, tmp188, points_per_pixel
 1550              	@ armwave.c:294:     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice
 294:armwave.c     ****     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice_height;
 1551              		.loc 1 294 41 view .LVU476
 1552 0658 E77AFCEE 		vcvt.u32.f32	s15, s15	@ tmp191, tmp190
 1553 065c 0F7AC4ED 		vstr.32	s15, [r4, #60]	@ int	@ tmp191, g_armwave_state.slice_record_height
 1554              		.loc 1 295 5 is_stmt 1 view .LVU477
 1555              	@ armwave.c:295:     g_armwave_state.xcoord_to_xpixel = malloc(length * sizeof(uint16_t));
 1556              		.loc 1 295 40 is_stmt 0 view .LVU478
 1557 0660 FEFFFFEB 		bl	malloc		@
 1558              	.LVL118:
 1559              	@ armwave.c:297:     assert(g_armwave_state.xcoord_to_xpixel != NULL);
 296:armwave.c     **** 
 297:armwave.c     ****     assert(g_armwave_state.xcoord_to_xpixel != NULL);
 1560              		.loc 1 297 5 view .LVU479
 1561 0664 000050E3 		cmp	r0, #0	@ _18,
 1562              	@ armwave.c:295:     g_armwave_state.xcoord_to_xpixel = malloc(length * sizeof(uint16_t));
 295:armwave.c     **** 
 1563              		.loc 1 295 40 view .LVU480
 1564 0668 0060A0E1 		mov	r6, r0	@ _18,
 1565              	@ armwave.c:295:     g_armwave_state.xcoord_to_xpixel = malloc(length * sizeof(uint16_t));
 295:armwave.c     **** 
 1566              		.loc 1 295 38 view .LVU481
 1567 066c 780084E5 		str	r0, [r4, #120]	@ _18, g_armwave_state.xcoord_to_xpixel
 1568              		.loc 1 297 5 is_stmt 1 view .LVU482
 1569 0670 2100000A 		beq	.L92		@,
 1570              	@ armwave.c:300:         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 298:armwave.c     **** 
 299:armwave.c     ****     for(xx = 0; xx < length; xx++) {
 300:armwave.c     ****         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1571              		.loc 1 300 54 is_stmt 0 view .LVU483
 1572 0674 2B7ADFED 		vldr.32	s15, .L93+4	@ tmp200,
 1573 0678 02C040E2 		sub	ip, r0, #2	@ ivtmp.84, _18,
 1574              	@ armwave.c:299:     for(xx = 0; xx < length; xx++) {
 299:armwave.c     ****         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1575              		.loc 1 299 12 view .LVU484
 1576 067c 0030A0E3 		mov	r3, #0	@ xx,
 1577              	@ armwave.c:300:         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1578              		.loc 1 300 54 view .LVU485
 1579 0680 887A87EE 		vdiv.f32	s14, s15, s16	@ _19, tmp200, points_per_pixel
 1580              	.L84:
 1581              	.LVL119:
 1582              		.loc 1 300 9 is_stmt 1 discriminator 3 view .LVU486
 1583              	@ armwave.c:300:         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1584              		.loc 1 300 74 is_stmt 0 discriminator 3 view .LVU487
 1585 0684 903A07EE 		vmov	s15, r3	@ int	@ xx, xx
 1586              	@ armwave.c:299:     for(xx = 0; xx < length; xx++) {
 299:armwave.c     ****         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1587              		.loc 1 299 32 discriminator 3 view .LVU488
 1588 0688 013083E2 		add	r3, r3, #1	@ xx, xx,
 1589              	.LVL120:
 1590              	@ armwave.c:299:     for(xx = 0; xx < length; xx++) {
 299:armwave.c     ****         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1591              		.loc 1 299 5 discriminator 3 view .LVU489
 1592 068c 030055E1 		cmp	r5, r3	@ _7, xx
 1593              	@ armwave.c:300:         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1594              		.loc 1 300 74 discriminator 3 view .LVU490
 1595 0690 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp201, xx
 1596 0694 877A67EE 		vmul.f32	s15, s15, s14	@ tmp202, tmp201, _19
 1597              	@ armwave.c:300:         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1598              		.loc 1 300 46 discriminator 3 view .LVU491
 1599 0698 E77AFCEE 		vcvt.u32.f32	s15, s15	@ tmp203, tmp202
 1600 069c 902A17EE 		vmov	r2, s15	@ int	@ tmp203, tmp203
 1601 06a0 B220ECE1 		strh	r2, [ip, #2]!	@ movhi	@ tmp203, MEM[base: _74, offset: 0B]
 1602              	@ armwave.c:299:     for(xx = 0; xx < length; xx++) {
 299:armwave.c     ****         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1603              		.loc 1 299 5 discriminator 3 view .LVU492
 1604 06a4 F6FFFF1A 		bne	.L84		@,
 301:armwave.c     **** 
 302:armwave.c     ****         // printf("xcoord_to_xpixel[%5d] = %5d (scale:%8.3f)\n", xx, g_armwave_state.xcoord_to_xpix
 303:armwave.c     ****     }
 304:armwave.c     **** 
 305:armwave.c     ****     g_armwave_state.out_pixbuf = malloc(sizeof(uint32_t) * g_armwave_state.size);
 1605              		.loc 1 305 5 is_stmt 1 view .LVU493
 1606              	@ armwave.c:305:     g_armwave_state.out_pixbuf = malloc(sizeof(uint32_t) * g_armwave_state.size);
 1607              		.loc 1 305 34 is_stmt 0 view .LVU494
 1608 06a8 480094E5 		ldr	r0, [r4, #72]	@ g_armwave_state.size, g_armwave_state.size
 1609 06ac 0001A0E1 		lsl	r0, r0, #2	@, g_armwave_state.size,
 1610 06b0 FEFFFFEB 		bl	malloc		@
 1611              	.LVL121:
 1612              	@ armwave.c:307:     printf("Ptrs: 0x%08x 0x%08x 0x%08x 0x%08x \n", \
 306:armwave.c     **** 
 307:armwave.c     ****     printf("Ptrs: 0x%08x 0x%08x 0x%08x 0x%08x \n", \
 1613              		.loc 1 307 5 view .LVU495
 1614 06b4 183094E5 		ldr	r3, [r4, #24]	@ g_armwave_state.test_wave_buffer, g_armwave_state.test_wave_buffer
 1615 06b8 0620A0E1 		mov	r2, r6	@, _18
 1616 06bc 00308DE5 		str	r3, [sp]	@ g_armwave_state.test_wave_buffer,
 1617 06c0 0710A0E1 		mov	r1, r7	@, _10
 1618              	@ armwave.c:305:     g_armwave_state.out_pixbuf = malloc(sizeof(uint32_t) * g_armwave_state.size);
 305:armwave.c     **** 
 1619              		.loc 1 305 34 view .LVU496
 1620 06c4 00C0A0E1 		mov	ip, r0	@ tmp207,
 1621              	@ armwave.c:307:     printf("Ptrs: 0x%08x 0x%08x 0x%08x 0x%08x \n", \
 1622              		.loc 1 307 5 view .LVU497
 1623 06c8 0030A0E1 		mov	r3, r0	@, tmp207
 1624 06cc 64009FE5 		ldr	r0, .L93+20	@,
 1625              	@ armwave.c:305:     g_armwave_state.out_pixbuf = malloc(sizeof(uint32_t) * g_armwave_state.size);
 305:armwave.c     **** 
 1626              		.loc 1 305 32 view .LVU498
 1627 06d0 5CC084E5 		str	ip, [r4, #92]	@ tmp207, g_armwave_state.out_pixbuf
 1628              		.loc 1 307 5 is_stmt 1 view .LVU499
 1629 06d4 FEFFFFEB 		bl	printf		@
 1630              	.LVL122:
 308:armwave.c     ****         g_armwave_state.ch1_buffer, g_armwave_state.xcoord_to_xpixel, g_armwave_state.out_pixbuf, g
 309:armwave.c     **** 
 310:armwave.c     ****     malloc_stats();
 1631              		.loc 1 310 5 view .LVU500
 1632              	@ armwave.c:311: }
 311:armwave.c     **** }
 1633              		.loc 1 311 1 is_stmt 0 view .LVU501
 1634 06d8 10D08DE2 		add	sp, sp, #16	@,,
 1635              		.cfi_remember_state
 1636              		.cfi_def_cfa_offset 40
 1637              		@ sp needed	@
 1638 06dc 028BBDEC 		vldm	sp!, {d8}	@
 1639              		.cfi_restore 80
 1640              		.cfi_restore 81
 1641              		.cfi_def_cfa_offset 32
 1642              	.LVL123:
 1643              		.loc 1 311 1 view .LVU502
 1644 06e0 F047BDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, lr}	@
 1645              		.cfi_restore 14
 1646              		.cfi_restore 10
 1647              		.cfi_restore 9
 1648              		.cfi_restore 8
 1649              		.cfi_restore 7
 1650              		.cfi_restore 6
 1651              		.cfi_restore 5
 1652              		.cfi_restore 4
 1653              		.cfi_def_cfa_offset 0
 1654              	.LVL124:
 1655              	@ armwave.c:310:     malloc_stats();
 310:armwave.c     **** }
 1656              		.loc 1 310 5 view .LVU503
 1657 06e4 FEFFFFEA 		b	malloc_stats		@
 1658              	.LVL125:
 1659              	.L90:
 1660              		.cfi_restore_state
 242:armwave.c     **** 
 1661              		.loc 1 242 5 is_stmt 1 discriminator 1 view .LVU504
 1662 06e8 4C309FE5 		ldr	r3, .L93+24	@,
 1663 06ec F220A0E3 		mov	r2, #242	@,
 1664 06f0 48109FE5 		ldr	r1, .L93+28	@,
 1665 06f4 48009FE5 		ldr	r0, .L93+32	@,
 1666 06f8 FEFFFFEB 		bl	__assert_fail		@
 1667              	.LVL126:
 1668              	.L92:
 297:armwave.c     **** 
 1669              		.loc 1 297 5 discriminator 1 view .LVU505
 1670 06fc 38309FE5 		ldr	r3, .L93+24	@,
 1671 0700 40209FE5 		ldr	r2, .L93+36	@,
 1672 0704 34109FE5 		ldr	r1, .L93+28	@,
 1673 0708 3C009FE5 		ldr	r0, .L93+40	@,
 1674 070c FEFFFFEB 		bl	__assert_fail		@
 1675              	.LVL127:
 1676              	.L91:
 289:armwave.c     **** 
 1677              		.loc 1 289 5 discriminator 1 view .LVU506
 1678 0710 24309FE5 		ldr	r3, .L93+24	@,
 1679 0714 34209FE5 		ldr	r2, .L93+44	@,
 1680 0718 20109FE5 		ldr	r1, .L93+28	@,
 1681 071c 30009FE5 		ldr	r0, .L93+48	@,
 1682 0720 FEFFFFEB 		bl	__assert_fail		@
 1683              	.LVL128:
 1684              	.L94:
 1685              		.align	2
 1686              	.L93:
 1687 0724 00007F43 		.word	1132396544
 1688 0728 0000803F 		.word	1065353216
 1689 072c 40000000 		.word	.LC4
 1690 0730 00000000 		.word	g_armwave_state
 1691 0734 84000000 		.word	.LC6
 1692 0738 E8000000 		.word	.LC9
 1693 073c 34000000 		.word	.LANCHOR0+52
 1694 0740 20000000 		.word	.LC2
 1695 0744 6C000000 		.word	.LC5
 1696 0748 29010000 		.word	297
 1697 074c BC000000 		.word	.LC8
 1698 0750 21010000 		.word	289
 1699 0754 98000000 		.word	.LC7
 1700              		.cfi_endproc
 1701              	.LFE62:
 1703              		.align	2
 1704              		.global	armwave_set_wave_pointer
 1705              		.syntax unified
 1706              		.arm
 1707              		.fpu vfp
 1709              	armwave_set_wave_pointer:
 1710              	.LVL129:
 1711              	.LFB63:
 312:armwave.c     **** 
 313:armwave.c     **** /*
 314:armwave.c     ****  * Set wave buffer pointer.  This needs to be changed to support disjointed buffers
 315:armwave.c     ****  * in the future.
 316:armwave.c     ****  */
 317:armwave.c     **** void armwave_set_wave_pointer(uint8_t *wave_buffer)
 318:armwave.c     **** {
 1712              		.loc 1 318 1 view -0
 1713              		.cfi_startproc
 1714              		@ args = 0, pretend = 0, frame = 0
 1715              		@ frame_needed = 0, uses_anonymous_args = 0
 319:armwave.c     ****     assert(wave_buffer != NULL);
 1716              		.loc 1 319 5 view .LVU508
 1717 0758 000050E3 		cmp	r0, #0	@ wave_buffer
 1718              		.loc 1 319 5 is_stmt 0 view .LVU509
 1719 075c 0200000A 		beq	.L100		@,
 320:armwave.c     ****     g_armwave_state.wave_buffer = wave_buffer;
 1720              		.loc 1 320 5 is_stmt 1 view .LVU510
 1721              	@ armwave.c:320:     g_armwave_state.wave_buffer = wave_buffer;
 1722              		.loc 1 320 33 is_stmt 0 view .LVU511
 1723 0760 1C309FE5 		ldr	r3, .L101	@ tmp116,
 1724 0764 140083E5 		str	r0, [r3, #20]	@ wave_buffer, g_armwave_state.wave_buffer
 1725 0768 1EFF2FE1 		bx	lr	@
 1726              	.L100:
 319:armwave.c     ****     assert(wave_buffer != NULL);
 1727              		.loc 1 319 5 is_stmt 1 discriminator 1 view .LVU512
 1728              	@ armwave.c:318: {
 318:armwave.c     ****     assert(wave_buffer != NULL);
 1729              		.loc 1 318 1 is_stmt 0 discriminator 1 view .LVU513
 1730 076c 10402DE9 		push	{r4, lr}	@
 1731              		.cfi_def_cfa_offset 8
 1732              		.cfi_offset 4, -8
 1733              		.cfi_offset 14, -4
 1734              	@ armwave.c:319:     assert(wave_buffer != NULL);
 319:armwave.c     ****     assert(wave_buffer != NULL);
 1735              		.loc 1 319 5 discriminator 1 view .LVU514
 1736 0770 10309FE5 		ldr	r3, .L101+4	@,
 1737 0774 10209FE5 		ldr	r2, .L101+8	@,
 1738 0778 10109FE5 		ldr	r1, .L101+12	@,
 1739 077c 10009FE5 		ldr	r0, .L101+16	@,
 1740              	.LVL130:
 319:armwave.c     ****     assert(wave_buffer != NULL);
 1741              		.loc 1 319 5 discriminator 1 view .LVU515
 1742 0780 FEFFFFEB 		bl	__assert_fail		@
 1743              	.LVL131:
 1744              	.L102:
 1745              		.align	2
 1746              	.L101:
 1747 0784 00000000 		.word	g_armwave_state
 1748 0788 4C000000 		.word	.LANCHOR0+76
 1749 078c 3F010000 		.word	319
 1750 0790 20000000 		.word	.LC2
 1751 0794 0C010000 		.word	.LC10
 1752              		.cfi_endproc
 1753              	.LFE63:
 1755              		.align	2
 1756              		.global	armwave_set_wave_pointer_as_testbuf
 1757              		.syntax unified
 1758              		.arm
 1759              		.fpu vfp
 1761              	armwave_set_wave_pointer_as_testbuf:
 1762              	.LFB64:
 321:armwave.c     **** }
 322:armwave.c     **** 
 323:armwave.c     **** /*
 324:armwave.c     ****  * Set the wave buffer pointer as the test waveform buffer filled by such functions
 325:armwave.c     ****  * as `armwave_test_create_square` and `armwave_test_create_am_sine`.
 326:armwave.c     ****  */
 327:armwave.c     **** void armwave_set_wave_pointer_as_testbuf()
 328:armwave.c     **** {
 1763              		.loc 1 328 1 is_stmt 1 view -0
 1764              		.cfi_startproc
 1765              		@ args = 0, pretend = 0, frame = 0
 1766              		@ frame_needed = 0, uses_anonymous_args = 0
 1767              		@ link register save eliminated.
 329:armwave.c     ****     g_armwave_state.wave_buffer = g_armwave_state.test_wave_buffer;
 1768              		.loc 1 329 5 view .LVU517
 1769              	@ armwave.c:329:     g_armwave_state.wave_buffer = g_armwave_state.test_wave_buffer;
 1770              		.loc 1 329 33 is_stmt 0 view .LVU518
 1771 0798 08309FE5 		ldr	r3, .L104	@ tmp111,
 1772 079c 182093E5 		ldr	r2, [r3, #24]	@ g_armwave_state.test_wave_buffer, g_armwave_state.test_wave_buffer
 1773 07a0 142083E5 		str	r2, [r3, #20]	@ g_armwave_state.test_wave_buffer, g_armwave_state.wave_buffer
 1774              	@ armwave.c:330: }
 330:armwave.c     **** }
 1775              		.loc 1 330 1 view .LVU519
 1776 07a4 1EFF2FE1 		bx	lr	@
 1777              	.L105:
 1778              		.align	2
 1779              	.L104:
 1780 07a8 00000000 		.word	g_armwave_state
 1781              		.cfi_endproc
 1782              	.LFE64:
 1784              		.align	2
 1785              		.global	armwave_set_wave_pointer_u32
 1786              		.syntax unified
 1787              		.arm
 1788              		.fpu vfp
 1790              	armwave_set_wave_pointer_u32:
 1791              	.LVL132:
 1792              	.LFB65:
 331:armwave.c     **** 
 332:armwave.c     **** /*
 333:armwave.c     ****  * Set wave buffer pointer from a 32-bit uint.  This needs to be changed to support 
 334:armwave.c     ****  * disjointed buffers in the future.
 335:armwave.c     ****  */
 336:armwave.c     **** void armwave_set_wave_pointer_u32(uint32_t wave_buffer_ptr)
 337:armwave.c     **** {
 1793              		.loc 1 337 1 is_stmt 1 view -0
 1794              		.cfi_startproc
 1795              		@ args = 0, pretend = 0, frame = 0
 1796              		@ frame_needed = 0, uses_anonymous_args = 0
 338:armwave.c     ****     assert(wave_buffer_ptr != 0);
 1797              		.loc 1 338 5 view .LVU521
 1798 07ac 000050E3 		cmp	r0, #0	@ wave_buffer_ptr
 1799              		.loc 1 338 5 is_stmt 0 view .LVU522
 1800 07b0 0200000A 		beq	.L111		@,
 339:armwave.c     ****     g_armwave_state.wave_buffer = (uint8_t*)wave_buffer_ptr;
 1801              		.loc 1 339 5 is_stmt 1 view .LVU523
 1802              	@ armwave.c:339:     g_armwave_state.wave_buffer = (uint8_t*)wave_buffer_ptr;
 1803              		.loc 1 339 33 is_stmt 0 view .LVU524
 1804 07b4 1C309FE5 		ldr	r3, .L112	@ tmp117,
 1805 07b8 140083E5 		str	r0, [r3, #20]	@ wave_buffer_ptr, g_armwave_state.wave_buffer
 1806 07bc 1EFF2FE1 		bx	lr	@
 1807              	.L111:
 338:armwave.c     ****     assert(wave_buffer_ptr != 0);
 1808              		.loc 1 338 5 is_stmt 1 discriminator 1 view .LVU525
 1809              	@ armwave.c:337: {
 337:armwave.c     ****     assert(wave_buffer_ptr != 0);
 1810              		.loc 1 337 1 is_stmt 0 discriminator 1 view .LVU526
 1811 07c0 10402DE9 		push	{r4, lr}	@
 1812              		.cfi_def_cfa_offset 8
 1813              		.cfi_offset 4, -8
 1814              		.cfi_offset 14, -4
 1815              	@ armwave.c:338:     assert(wave_buffer_ptr != 0);
 338:armwave.c     ****     assert(wave_buffer_ptr != 0);
 1816              		.loc 1 338 5 discriminator 1 view .LVU527
 1817 07c4 10309FE5 		ldr	r3, .L112+4	@,
 1818 07c8 10209FE5 		ldr	r2, .L112+8	@,
 1819 07cc 10109FE5 		ldr	r1, .L112+12	@,
 1820 07d0 10009FE5 		ldr	r0, .L112+16	@,
 1821              	.LVL133:
 338:armwave.c     ****     assert(wave_buffer_ptr != 0);
 1822              		.loc 1 338 5 discriminator 1 view .LVU528
 1823 07d4 FEFFFFEB 		bl	__assert_fail		@
 1824              	.LVL134:
 1825              	.L113:
 1826              		.align	2
 1827              	.L112:
 1828 07d8 00000000 		.word	g_armwave_state
 1829 07dc 68000000 		.word	.LANCHOR0+104
 1830 07e0 52010000 		.word	338
 1831 07e4 20000000 		.word	.LC2
 1832 07e8 20010000 		.word	.LC11
 1833              		.cfi_endproc
 1834              	.LFE65:
 1836              		.align	2
 1837              		.global	armwave_clear_buffer
 1838              		.syntax unified
 1839              		.arm
 1840              		.fpu vfp
 1842              	armwave_clear_buffer:
 1843              	.LVL135:
 1844              	.LFB66:
 340:armwave.c     **** }
 341:armwave.c     **** 
 342:armwave.c     **** /*
 343:armwave.c     ****  * Clear the working buffer (fill it with all zeros.)
 344:armwave.c     ****  */
 345:armwave.c     **** void armwave_clear_buffer(uint32_t flags)
 346:armwave.c     **** {
 1845              		.loc 1 346 1 is_stmt 1 view -0
 1846              		.cfi_startproc
 1847              		@ args = 0, pretend = 0, frame = 0
 1848              		@ frame_needed = 0, uses_anonymous_args = 0
 1849              		@ link register save eliminated.
 347:armwave.c     ****     // Flags ignored, only one buffer cleared
 348:armwave.c     ****     memset(g_armwave_state.ch1_buffer, 0, g_armwave_state.ch_buff_size);
 1850              		.loc 1 348 5 view .LVU530
 1851 07ec 0C309FE5 		ldr	r3, .L115	@ tmp113,
 1852 07f0 0010A0E3 		mov	r1, #0	@,
 1853 07f4 442093E5 		ldr	r2, [r3, #68]	@, g_armwave_state.ch_buff_size
 1854 07f8 040093E5 		ldr	r0, [r3, #4]	@, g_armwave_state.ch1_buffer
 1855              	.LVL136:
 1856              		.loc 1 348 5 is_stmt 0 view .LVU531
 1857 07fc FEFFFFEA 		b	memset		@
 1858              	.LVL137:
 1859              	.L116:
 1860              		.align	2
 1861              	.L115:
 1862 0800 00000000 		.word	g_armwave_state
 1863              		.cfi_endproc
 1864              	.LFE66:
 1866              		.align	2
 1867              		.global	armwave_set_channel_colour
 1868              		.syntax unified
 1869              		.arm
 1870              		.fpu vfp
 1872              	armwave_set_channel_colour:
 1873              	.LVL138:
 1874              	.LFB67:
 349:armwave.c     **** }
 350:armwave.c     **** 
 351:armwave.c     **** /*
 352:armwave.c     ****  * Set the render colour for a channel.  R/G/B may exceed 255 for saturation effects.
 353:armwave.c     ****  */
 354:armwave.c     **** void armwave_set_channel_colour(int ch, int r, int g, int b)
 355:armwave.c     **** {
 1875              		.loc 1 355 1 is_stmt 1 view -0
 1876              		.cfi_startproc
 1877              		@ args = 0, pretend = 0, frame = 0
 1878              		@ frame_needed = 0, uses_anonymous_args = 0
 1879              		@ link register save eliminated.
 356:armwave.c     ****     // Only 1ch supported for now
 357:armwave.c     ****     switch(ch) {
 1880              		.loc 1 357 5 view .LVU533
 1881 0804 010050E3 		cmp	r0, #1	@ ch,
 358:armwave.c     ****         case 1:
 359:armwave.c     ****             g_armwave_state.ch1_color.r = r;
 1882              		.loc 1 359 13 view .LVU534
 1883              	@ armwave.c:359:             g_armwave_state.ch1_color.r = r;
 1884              		.loc 1 359 41 is_stmt 0 view .LVU535
 1885 0808 0C009F05 		ldreq	r0, .L119	@ tmp117,
 1886              	.LVL139:
 1887              		.loc 1 359 41 view .LVU536
 1888 080c B016C001 		strheq	r1, [r0, #96]	@ movhi	@ r, g_armwave_state.ch1_color.r
 360:armwave.c     ****             g_armwave_state.ch1_color.g = g;
 1889              		.loc 1 360 13 is_stmt 1 view .LVU537
 1890              	@ armwave.c:360:             g_armwave_state.ch1_color.g = g;
 1891              		.loc 1 360 41 is_stmt 0 view .LVU538
 1892 0810 B226C001 		strheq	r2, [r0, #98]	@ movhi	@ g, g_armwave_state.ch1_color.g
 361:armwave.c     ****             g_armwave_state.ch1_color.b = b;
 1893              		.loc 1 361 13 is_stmt 1 view .LVU539
 1894              	@ armwave.c:361:             g_armwave_state.ch1_color.b = b;
 1895              		.loc 1 361 41 is_stmt 0 view .LVU540
 1896 0814 B436C001 		strheq	r3, [r0, #100]	@ movhi	@ b, g_armwave_state.ch1_color.b
 362:armwave.c     ****             break;
 1897              		.loc 1 362 13 is_stmt 1 view .LVU541
 1898              	@ armwave.c:364: }
 363:armwave.c     ****     }
 364:armwave.c     **** }
 1899              		.loc 1 364 1 is_stmt 0 view .LVU542
 1900 0818 1EFF2FE1 		bx	lr	@
 1901              	.L120:
 1902              		.align	2
 1903              	.L119:
 1904 081c 00000000 		.word	g_armwave_state
 1905              		.cfi_endproc
 1906              	.LFE67:
 1908              		.align	2
 1909              		.global	armwave_dump_ppm_debug
 1910              		.syntax unified
 1911              		.arm
 1912              		.fpu vfp
 1914              	armwave_dump_ppm_debug:
 1915              	.LVL140:
 1916              	.LFB68:
 365:armwave.c     **** 
 366:armwave.c     **** /*
 367:armwave.c     ****  * Dump a ppm of a buffer to a file.
 368:armwave.c     ****  */
 369:armwave.c     **** void armwave_dump_ppm_debug(uint32_t *buffer, char *fn)
 370:armwave.c     **** {
 1917              		.loc 1 370 1 is_stmt 1 view -0
 1918              		.cfi_startproc
 1919              		@ args = 0, pretend = 0, frame = 0
 1920              		@ frame_needed = 0, uses_anonymous_args = 0
 371:armwave.c     ****     FILE *fp = fopen(fn, "wb");
 1921              		.loc 1 371 5 view .LVU544
 1922              	@ armwave.c:370: {
 370:armwave.c     ****     FILE *fp = fopen(fn, "wb");
 1923              		.loc 1 370 1 is_stmt 0 view .LVU545
 1924 0820 0130A0E1 		mov	r3, r1	@ fn, fn
 1925 0824 F0432DE9 		push	{r4, r5, r6, r7, r8, r9, lr}	@
 1926              		.cfi_def_cfa_offset 28
 1927              		.cfi_offset 4, -28
 1928              		.cfi_offset 5, -24
 1929              		.cfi_offset 6, -20
 1930              		.cfi_offset 7, -16
 1931              		.cfi_offset 8, -12
 1932              		.cfi_offset 9, -8
 1933              		.cfi_offset 14, -4
 1934 0828 0080A0E1 		mov	r8, r0	@ buffer, buffer
 1935 082c 0CD04DE2 		sub	sp, sp, #12	@,,
 1936              		.cfi_def_cfa_offset 40
 1937              	@ armwave.c:371:     FILE *fp = fopen(fn, "wb");
 1938              		.loc 1 371 16 view .LVU546
 1939 0830 D4109FE5 		ldr	r1, .L133	@,
 1940              	.LVL141:
 1941              		.loc 1 371 16 view .LVU547
 1942 0834 0300A0E1 		mov	r0, r3	@, fn
 1943              	.LVL142:
 1944              		.loc 1 371 16 view .LVU548
 1945 0838 FEFFFFEB 		bl	fopen64		@
 1946              	.LVL143:
 1947              	@ armwave.c:378:     fprintf(fp, "%d %d\n", g_armwave_state.target_width, g_armwave_state.target_he
 372:armwave.c     ****     uint32_t data;
 373:armwave.c     ****     int xx, yy;
 374:armwave.c     **** 
 375:armwave.c     ****     //printf("in_buffer=0x%08x\n", buffer);
 376:armwave.c     **** 
 377:armwave.c     ****     fputs("P3\n", fp);
 378:armwave.c     ****     fprintf(fp, "%d %d\n", g_armwave_state.target_width, g_armwave_state.target_height);
 1948              		.loc 1 378 5 view .LVU549
 1949 083c CC609FE5 		ldr	r6, .L133+4	@ tmp154,
 1950              	@ armwave.c:377:     fputs("P3\n", fp);
 377:armwave.c     ****     fprintf(fp, "%d %d\n", g_armwave_state.target_width, g_armwave_state.target_height);
 1951              		.loc 1 377 5 view .LVU550
 1952 0840 0320A0E3 		mov	r2, #3	@,
 1953 0844 0110A0E3 		mov	r1, #1	@,
 1954              	@ armwave.c:371:     FILE *fp = fopen(fn, "wb");
 371:armwave.c     ****     uint32_t data;
 1955              		.loc 1 371 16 view .LVU551
 1956 0848 0070A0E1 		mov	r7, r0	@ fp,
 1957              	.LVL144:
 372:armwave.c     ****     uint32_t data;
 1958              		.loc 1 372 5 is_stmt 1 view .LVU552
 373:armwave.c     **** 
 1959              		.loc 1 373 5 view .LVU553
 377:armwave.c     ****     fprintf(fp, "%d %d\n", g_armwave_state.target_width, g_armwave_state.target_height);
 1960              		.loc 1 377 5 view .LVU554
 1961 084c 0030A0E1 		mov	r3, r0	@, fp
 1962 0850 BC009FE5 		ldr	r0, .L133+8	@,
 1963              	.LVL145:
 377:armwave.c     ****     fprintf(fp, "%d %d\n", g_armwave_state.target_width, g_armwave_state.target_height);
 1964              		.loc 1 377 5 is_stmt 0 view .LVU555
 1965 0854 FEFFFFEB 		bl	fwrite		@
 1966              	.LVL146:
 1967              		.loc 1 378 5 is_stmt 1 view .LVU556
 1968 0858 DC24C6E1 		ldrd	r2, [r6, #76]	@, tmp154,
 1969 085c B4109FE5 		ldr	r1, .L133+12	@,
 1970 0860 0700A0E1 		mov	r0, r7	@, fp
 1971 0864 FEFFFFEB 		bl	fprintf		@
 1972              	.LVL147:
 379:armwave.c     ****     fputs("255\n", fp);
 1973              		.loc 1 379 5 view .LVU557
 1974 0868 0420A0E3 		mov	r2, #4	@,
 1975 086c 0730A0E1 		mov	r3, r7	@, fp
 1976 0870 0110A0E3 		mov	r1, #1	@,
 1977 0874 A0009FE5 		ldr	r0, .L133+16	@,
 1978 0878 FEFFFFEB 		bl	fwrite		@
 1979              	.LVL148:
 380:armwave.c     **** 
 381:armwave.c     ****     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 1980              		.loc 1 381 5 view .LVU558
 1981              	@ armwave.c:381:     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 1982              		.loc 1 381 37 is_stmt 0 view .LVU559
 1983 087c 502096E5 		ldr	r2, [r6, #80]	@ prephitmp_57, g_armwave_state.target_height
 1984              	@ armwave.c:381:     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 1985              		.loc 1 381 5 view .LVU560
 1986 0880 000052E3 		cmp	r2, #0	@ prephitmp_57,
 1987 0884 1800000A 		beq	.L122		@,
 1988 0888 4C3096E5 		ldr	r3, [r6, #76]	@ _12, g_armwave_state.target_width
 1989              	@ armwave.c:386:             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >>
 382:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 383:armwave.c     ****             data = *(buffer + (xx + (yy * g_armwave_state.target_width)));
 384:armwave.c     ****             //printf("xx,yy=%4d,%4d, word=0x%08x\n", xx, yy, data);
 385:armwave.c     **** 
 386:armwave.c     ****             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >> 16) & 0xff);
 1990              		.loc 1 386 13 view .LVU561
 1991 088c 8C909FE5 		ldr	r9, .L133+20	@ tmp156,
 1992              	@ armwave.c:381:     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 381:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1993              		.loc 1 381 12 view .LVU562
 1994 0890 0050A0E3 		mov	r5, #0	@ yy,
 1995              	.LVL149:
 1996              	.L123:
 1997              	@ armwave.c:382:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 382:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1998              		.loc 1 382 9 view .LVU563
 1999 0894 000053E3 		cmp	r3, #0	@ _12,
 2000              	@ armwave.c:382:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 382:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 2001              		.loc 1 382 16 view .LVU564
 2002 0898 0040A013 		movne	r4, #0	@ xx,
 2003              	@ armwave.c:382:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 382:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 2004              		.loc 1 382 9 view .LVU565
 2005 089c 1600000A 		beq	.L132		@,
 2006              	.LVL150:
 2007              	.L124:
 383:armwave.c     ****             //printf("xx,yy=%4d,%4d, word=0x%08x\n", xx, yy, data);
 2008              		.loc 1 383 13 is_stmt 1 discriminator 3 view .LVU566
 2009              	@ armwave.c:383:             data = *(buffer + (xx + (yy * g_armwave_state.target_width)));
 383:armwave.c     ****             //printf("xx,yy=%4d,%4d, word=0x%08x\n", xx, yy, data);
 2010              		.loc 1 383 29 is_stmt 0 discriminator 3 view .LVU567
 2011 08a0 954323E0 		mla	r3, r5, r3, r4	@ tmp145, yy, _12, xx
 2012              	@ armwave.c:386:             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >>
 2013              		.loc 1 386 13 discriminator 3 view .LVU568
 2014 08a4 0910A0E1 		mov	r1, r9	@, tmp156
 2015 08a8 0700A0E1 		mov	r0, r7	@, fp
 2016              	@ armwave.c:383:             data = *(buffer + (xx + (yy * g_armwave_state.target_width)));
 383:armwave.c     ****             //printf("xx,yy=%4d,%4d, word=0x%08x\n", xx, yy, data);
 2017              		.loc 1 383 18 discriminator 3 view .LVU569
 2018 08ac 032198E7 		ldr	r2, [r8, r3, lsl #2]	@ data, *_6
 2019              	.LVL151:
 2020              		.loc 1 386 13 is_stmt 1 discriminator 3 view .LVU570
 2021              	@ armwave.c:382:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 382:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 2022              		.loc 1 382 58 is_stmt 0 discriminator 3 view .LVU571
 2023 08b0 014084E2 		add	r4, r4, #1	@ xx, xx,
 2024              	.LVL152:
 2025              	@ armwave.c:386:             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >>
 2026              		.loc 1 386 81 discriminator 3 view .LVU572
 2027 08b4 22C8A0E1 		lsr	ip, r2, #16	@ tmp150, data,
 2028              	@ armwave.c:386:             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >>
 2029              		.loc 1 386 61 discriminator 3 view .LVU573
 2030 08b8 2234A0E1 		lsr	r3, r2, #8	@ tmp146, data,
 2031              	@ armwave.c:386:             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >>
 2032              		.loc 1 386 13 discriminator 3 view .LVU574
 2033 08bc 7CC0EFE6 		uxtb	ip, ip	@ tmp151, tmp150
 2034 08c0 7330EFE6 		uxtb	r3, r3	@, tmp146
 2035 08c4 00C08DE5 		str	ip, [sp]	@ tmp151,
 2036 08c8 7220EFE6 		uxtb	r2, r2	@, data
 2037              	.LVL153:
 2038              		.loc 1 386 13 discriminator 3 view .LVU575
 2039 08cc FEFFFFEB 		bl	fprintf		@
 2040              	.LVL154:
 2041              	@ armwave.c:382:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 382:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 2042              		.loc 1 382 41 discriminator 3 view .LVU576
 2043 08d0 4C3096E5 		ldr	r3, [r6, #76]	@ _12, g_armwave_state.target_width
 2044              	@ armwave.c:382:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 382:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 2045              		.loc 1 382 9 discriminator 3 view .LVU577
 2046 08d4 040053E1 		cmp	r3, r4	@ _12, xx
 2047 08d8 F0FFFF8A 		bhi	.L124		@,
 2048 08dc 502096E5 		ldr	r2, [r6, #80]	@ prephitmp_57, g_armwave_state.target_height
 2049              	.LVL155:
 2050              	.L125:
 2051              	@ armwave.c:381:     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 381:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 2052              		.loc 1 381 55 discriminator 2 view .LVU578
 2053 08e0 015085E2 		add	r5, r5, #1	@ yy, yy,
 2054              	.LVL156:
 2055              	@ armwave.c:381:     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 381:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 2056              		.loc 1 381 5 discriminator 2 view .LVU579
 2057 08e4 020055E1 		cmp	r5, r2	@ yy, prephitmp_57
 2058 08e8 E9FFFF3A 		bcc	.L123		@,
 2059              	.LVL157:
 2060              	.L122:
 387:armwave.c     ****         }
 388:armwave.c     ****     }
 389:armwave.c     **** 
 390:armwave.c     ****     fclose(fp);
 2061              		.loc 1 390 5 is_stmt 1 view .LVU580
 2062 08ec 0700A0E1 		mov	r0, r7	@, fp
 2063              	@ armwave.c:391: }
 391:armwave.c     **** }
 2064              		.loc 1 391 1 is_stmt 0 view .LVU581
 2065 08f0 0CD08DE2 		add	sp, sp, #12	@,,
 2066              		.cfi_remember_state
 2067              		.cfi_def_cfa_offset 28
 2068              		@ sp needed	@
 2069 08f4 F043BDE8 		pop	{r4, r5, r6, r7, r8, r9, lr}	@
 2070              		.cfi_restore 14
 2071              		.cfi_restore 9
 2072              		.cfi_restore 8
 2073              		.cfi_restore 7
 2074              		.cfi_restore 6
 2075              		.cfi_restore 5
 2076              		.cfi_restore 4
 2077              		.cfi_def_cfa_offset 0
 2078              	.LVL158:
 2079              	@ armwave.c:390:     fclose(fp);
 390:armwave.c     **** }
 2080              		.loc 1 390 5 view .LVU582
 2081 08f8 FEFFFFEA 		b	fclose		@
 2082              	.LVL159:
 2083              	.L132:
 2084              		.cfi_restore_state
 2085              	@ armwave.c:381:     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 381:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 2086              		.loc 1 381 55 view .LVU583
 2087 08fc 015085E2 		add	r5, r5, #1	@ yy, yy,
 2088              	.LVL160:
 2089              	@ armwave.c:381:     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 381:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 2090              		.loc 1 381 5 view .LVU584
 2091 0900 050052E1 		cmp	r2, r5	@ prephitmp_57, yy
 2092 0904 F5FFFF8A 		bhi	.L125		@,
 2093 0908 F7FFFFEA 		b	.L122		@
 2094              	.L134:
 2095              		.align	2
 2096              	.L133:
 2097 090c 38010000 		.word	.LC12
 2098 0910 00000000 		.word	g_armwave_state
 2099 0914 3C010000 		.word	.LC13
 2100 0918 40010000 		.word	.LC14
 2101 091c 48010000 		.word	.LC15
 2102 0920 50010000 		.word	.LC16
 2103              		.cfi_endproc
 2104              	.LFE68:
 2106              		.align	2
 2107              		.global	armwave_test_init
 2108              		.syntax unified
 2109              		.arm
 2110              		.fpu vfp
 2112              	armwave_test_init:
 2113              	.LVL161:
 2114              	.LFB69:
 392:armwave.c     **** 
 393:armwave.c     **** /*
 394:armwave.c     ****  * Initialise some test functionry.
 395:armwave.c     ****  */
 396:armwave.c     **** void armwave_test_init(int wave_size, int nwaves, int render_width, int render_height)
 397:armwave.c     **** {
 2115              		.loc 1 397 1 is_stmt 1 view -0
 2116              		.cfi_startproc
 2117              		@ args = 0, pretend = 0, frame = 0
 2118              		@ frame_needed = 0, uses_anonymous_args = 0
 398:armwave.c     ****     test_create_gamma();
 2119              		.loc 1 398 5 view .LVU586
 2120              	.LBB12:
 2121              	.LBI12:
  45:armwave.c     **** {
 2122              		.loc 1 45 6 view .LVU587
  45:armwave.c     **** {
 2123              		.loc 1 45 6 is_stmt 0 view .LVU588
 2124              	.LBE12:
 2125              	@ armwave.c:397: {
 397:armwave.c     ****     test_create_gamma();
 2126              		.loc 1 397 1 view .LVU589
 2127 0924 F0472DE9 		push	{r4, r5, r6, r7, r8, r9, r10, lr}	@
 2128              		.cfi_def_cfa_offset 32
 2129              		.cfi_offset 4, -32
 2130              		.cfi_offset 5, -28
 2131              		.cfi_offset 6, -24
 2132              		.cfi_offset 7, -20
 2133              		.cfi_offset 8, -16
 2134              		.cfi_offset 9, -12
 2135              		.cfi_offset 10, -8
 2136              		.cfi_offset 14, -4
 2137 0928 068B2DED 		vpush.64	{d8, d9, d10}	@
 2138              		.cfi_def_cfa_offset 56
 2139              		.cfi_offset 80, -56
 2140              		.cfi_offset 81, -52
 2141              		.cfi_offset 82, -48
 2142              		.cfi_offset 83, -44
 2143              		.cfi_offset 84, -40
 2144              		.cfi_offset 85, -36
 2145 092c C0409FE5 		ldr	r4, .L139+20	@ ivtmp.98,
 2146              	.LBB15:
 2147              	.LBB13:
 2148              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  51:armwave.c     ****     }
 2149              		.loc 1 51 32 view .LVU590
 2150 0930 2EAA9FED 		vldr.32	s20, .L139+16	@ tmp136,
 2151              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  51:armwave.c     ****     }
 2152              		.loc 1 51 26 view .LVU591
 2153 0934 299B9FED 		vldr.64	d9, .L139	@ tmp151,
 2154              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  51:armwave.c     ****     }
 2155              		.loc 1 51 49 view .LVU592
 2156 0938 2A8B9FED 		vldr.64	d8, .L139+8	@ tmp139,
 2157 093c 01C084E2 		add	ip, r4, #1	@ _38, ivtmp.98,
 2158              	.LBE13:
 2159              	.LBE15:
 2160              	@ armwave.c:397: {
 397:armwave.c     ****     test_create_gamma();
 2161              		.loc 1 397 1 view .LVU593
 2162 0940 10D04DE2 		sub	sp, sp, #16	@,,
 2163              		.cfi_def_cfa_offset 72
 2164              	@ armwave.c:397: {
 397:armwave.c     ****     test_create_gamma();
 2165              		.loc 1 397 1 view .LVU594
 2166 0944 0060A0E1 		mov	r6, r0	@ wave_size, wave_size
 2167 0948 0170A0E1 		mov	r7, r1	@ nwaves, nwaves
 2168 094c 0280A0E1 		mov	r8, r2	@ render_width, render_width
 2169 0950 0390A0E1 		mov	r9, r3	@ render_height, render_height
 2170 0954 01AC84E2 		add	r10, r4, #256	@ _39, ivtmp.98,
 2171 0958 01506CE2 		rsb	r5, ip, #1	@ tmp150, _38,
 2172              	.LVL162:
 2173              	.L136:
 2174              	.LBB16:
 2175              	.LBB14:
  51:armwave.c     ****     }
 2176              		.loc 1 51 9 is_stmt 1 view .LVU595
 2177              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  51:armwave.c     ****     }
 2178              		.loc 1 51 32 is_stmt 0 view .LVU596
 2179 095c 043085E0 		add	r3, r5, r4	@ tmp133, tmp150, ivtmp.98
 2180              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  51:armwave.c     ****     }
 2181              		.loc 1 51 26 view .LVU597
 2182 0960 491BB0EE 		vmov.f64	d1, d9	@, tmp151
 2183              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  51:armwave.c     ****     }
 2184              		.loc 1 51 32 view .LVU598
 2185 0964 903A07EE 		vmov	s15, r3	@ int	@ tmp133, tmp133
 2186 0968 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp134, tmp133
 2187 096c 8A0A87EE 		vdiv.f32	s0, s15, s20	@ tmp135, tmp134, tmp136
 2188              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  51:armwave.c     ****     }
 2189              		.loc 1 51 26 view .LVU599
 2190 0970 C00AB7EE 		vcvt.f64.f32	d0, s0	@, tmp135
 2191 0974 FEFFFFEB 		bl	pow		@
 2192              	.LVL163:
 2193              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  51:armwave.c     ****     }
 2194              		.loc 1 51 49 view .LVU600
 2195 0978 080B20EE 		vmul.f64	d0, d0, d8	@ tmp138,, tmp139
 2196              	@ armwave.c:51:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  51:armwave.c     ****     }
 2197              		.loc 1 51 24 view .LVU601
 2198 097c C07BFCEE 		vcvt.u32.f64	s15, d0	@ tmp140, tmp138
 2199 0980 900A17EE 		vmov	r0, s15	@ int	@ tmp140, tmp140
 2200 0984 0100E4E5 		strb	r0, [r4, #1]!	@ tmp140, MEM[base: _37, offset: 0B]
 2201              	.LVL164:
 2202              	@ armwave.c:50:     for(i = 0; i < 256; i++) {
  50:armwave.c     ****         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 2203              		.loc 1 50 5 view .LVU602
 2204 0988 0A0054E1 		cmp	r4, r10	@ ivtmp.98, _39
 2205 098c F2FFFF1A 		bne	.L136		@,
 2206              	.LVL165:
  50:armwave.c     ****         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 2207              		.loc 1 50 5 view .LVU603
 2208              	.LBE14:
 2209              	.LBE16:
 399:armwave.c     **** 
 400:armwave.c     ****     // make ch1 yellowish by default
 401:armwave.c     ****     armwave_set_channel_colour(1, 2550, 1780, 250);
 2210              		.loc 1 401 5 is_stmt 1 view .LVU604
 2211              	.LBB17:
 2212              	.LBI17:
 354:armwave.c     **** {
 2213              		.loc 1 354 6 view .LVU605
 2214              	.LBB18:
 357:armwave.c     ****         case 1:
 2215              		.loc 1 357 5 view .LVU606
 359:armwave.c     ****             g_armwave_state.ch1_color.g = g;
 2216              		.loc 1 359 13 view .LVU607
 360:armwave.c     ****             g_armwave_state.ch1_color.b = b;
 2217              		.loc 1 360 13 view .LVU608
 2218              	@ armwave.c:359:             g_armwave_state.ch1_color.r = r;
 359:armwave.c     ****             g_armwave_state.ch1_color.g = g;
 2219              		.loc 1 359 41 is_stmt 0 view .LVU609
 2220 0990 60C09FE5 		ldr	ip, .L139+24	@ tmp142,
 2221 0994 60409FE5 		ldr	r4, .L139+28	@ tmp143,
 2222              	.LBE18:
 2223              	.LBE17:
 2224              	@ armwave.c:403:     armwave_setup_render(0, wave_size, nwaves, wave_size, render_width, render_hei
 402:armwave.c     **** 
 403:armwave.c     ****     armwave_setup_render(0, wave_size, nwaves, wave_size, render_width, render_height, 0x00000000);
 2225              		.loc 1 403 5 view .LVU610
 2226 0998 0000A0E3 		mov	r0, #0	@ tmp147,
 2227              	.LBB22:
 2228              	.LBB19:
 2229              	@ armwave.c:361:             g_armwave_state.ch1_color.b = b;
 361:armwave.c     ****             break;
 2230              		.loc 1 361 41 view .LVU611
 2231 099c FAE0A0E3 		mov	lr, #250	@ tmp146,
 2232              	.LBE19:
 2233              	.LBE22:
 2234              	@ armwave.c:403:     armwave_setup_render(0, wave_size, nwaves, wave_size, render_width, render_hei
 2235              		.loc 1 403 5 view .LVU612
 2236 09a0 08008DE5 		str	r0, [sp, #8]	@ tmp147,
 2237 09a4 04908DE5 		str	r9, [sp, #4]	@ render_height,
 2238 09a8 00808DE5 		str	r8, [sp]	@ render_width,
 2239 09ac 0610A0E1 		mov	r1, r6	@, tmp3
 2240 09b0 0720A0E1 		mov	r2, r7	@, nwaves
 2241              	.LBB23:
 2242              	.LBB20:
 2243              	@ armwave.c:359:             g_armwave_state.ch1_color.r = r;
 359:armwave.c     ****             g_armwave_state.ch1_color.g = g;
 2244              		.loc 1 359 41 view .LVU613
 2245 09b4 60408CE5 		str	r4, [ip, #96]	@ tmp143, MEM[(short int *)&g_armwave_state + 96B]
 361:armwave.c     ****             break;
 2246              		.loc 1 361 13 is_stmt 1 view .LVU614
 2247              	.LBE20:
 2248              	.LBE23:
 2249              	@ armwave.c:403:     armwave_setup_render(0, wave_size, nwaves, wave_size, render_width, render_hei
 2250              		.loc 1 403 5 is_stmt 0 view .LVU615
 2251 09b8 0630A0E1 		mov	r3, r6	@, wave_size
 2252              	.LBB24:
 2253              	.LBB21:
 2254              	@ armwave.c:361:             g_armwave_state.ch1_color.b = b;
 361:armwave.c     ****             break;
 2255              		.loc 1 361 41 view .LVU616
 2256 09bc B4E6CCE1 		strh	lr, [ip, #100]	@ movhi	@ tmp146, g_armwave_state.ch1_color.b
 362:armwave.c     ****     }
 2257              		.loc 1 362 13 is_stmt 1 view .LVU617
 2258              	.LVL166:
 362:armwave.c     ****     }
 2259              		.loc 1 362 13 is_stmt 0 view .LVU618
 2260              	.LBE21:
 2261              	.LBE24:
 2262              		.loc 1 403 5 is_stmt 1 view .LVU619
 2263 09c0 FEFFFFEB 		bl	armwave_setup_render		@
 2264              	.LVL167:
 404:armwave.c     **** 
 405:armwave.c     ****     printf("armwave version: %s\n", ARMWAVE_VER);
 2265              		.loc 1 405 5 view .LVU620
 2266 09c4 34109FE5 		ldr	r1, .L139+32	@,
 2267 09c8 34009FE5 		ldr	r0, .L139+36	@,
 2268              	@ armwave.c:406: }
 406:armwave.c     **** }
 2269              		.loc 1 406 1 is_stmt 0 view .LVU621
 2270 09cc 10D08DE2 		add	sp, sp, #16	@,,
 2271              		.cfi_def_cfa_offset 56
 2272              		@ sp needed	@
 2273 09d0 068BBDEC 		vldm	sp!, {d8-d10}	@,
 2274              		.cfi_restore 84
 2275              		.cfi_restore 85
 2276              		.cfi_restore 82
 2277              		.cfi_restore 83
 2278              		.cfi_restore 80
 2279              		.cfi_restore 81
 2280              		.cfi_def_cfa_offset 32
 2281 09d4 F047BDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, lr}	@
 2282              		.cfi_restore 14
 2283              		.cfi_restore 10
 2284              		.cfi_restore 9
 2285              		.cfi_restore 8
 2286              		.cfi_restore 7
 2287              		.cfi_restore 6
 2288              		.cfi_restore 5
 2289              		.cfi_restore 4
 2290              		.cfi_def_cfa_offset 0
 2291              	.LVL168:
 2292              	@ armwave.c:405:     printf("armwave version: %s\n", ARMWAVE_VER);
 405:armwave.c     **** }
 2293              		.loc 1 405 5 view .LVU622
 2294 09d8 FEFFFFEA 		b	printf		@
 2295              	.LVL169:
 2296              	.L140:
 2297 09dc 0000A0E1 		.align	3
 2298              	.L139:
 2299 09e0 000000C0 		.word	-1073741824
 2300 09e4 CCCCEC3F 		.word	1072483532
 2301 09e8 00000000 		.word	0
 2302 09ec 00E06F40 		.word	1081073664
 2303 09f0 00007F43 		.word	1132396544
 2304 09f4 FFFFFFFF 		.word	gamma_table-1
 2305 09f8 00000000 		.word	g_armwave_state
 2306 09fc F609F406 		.word	116656630
 2307 0a00 00000000 		.word	.LC0
 2308 0a04 08000000 		.word	.LC1
 2309              		.cfi_endproc
 2310              	.LFE69:
 2312              		.global	__aeabi_uidiv
 2313              		.align	2
 2314              		.global	armwave_test_generate
 2315              		.syntax unified
 2316              		.arm
 2317              		.fpu vfp
 2319              	armwave_test_generate:
 2320              	.LFB70:
 407:armwave.c     **** 
 408:armwave.c     **** /*
 409:armwave.c     ****  * Fill buffers with test funtionry.
 410:armwave.c     ****  */
 411:armwave.c     **** void armwave_test_generate()
 412:armwave.c     **** {
 2321              		.loc 1 412 1 is_stmt 1 view -0
 2322              		.cfi_startproc
 2323              		@ args = 0, pretend = 0, frame = 8
 2324              		@ frame_needed = 0, uses_anonymous_args = 0
 413:armwave.c     ****     uint32_t yy;
 2325              		.loc 1 413 5 view .LVU624
 414:armwave.c     ****     uint32_t xx_rem = g_armwave_state.target_width, ypos = 0;
 2326              		.loc 1 414 5 view .LVU625
 2327              	@ armwave.c:412: {
 412:armwave.c     ****     uint32_t yy;
 2328              		.loc 1 412 1 is_stmt 0 view .LVU626
 2329 0a08 F04F2DE9 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}	@
 2330              		.cfi_def_cfa_offset 36
 2331              		.cfi_offset 4, -36
 2332              		.cfi_offset 5, -32
 2333              		.cfi_offset 6, -28
 2334              		.cfi_offset 7, -24
 2335              		.cfi_offset 8, -20
 2336              		.cfi_offset 9, -16
 2337              		.cfi_offset 10, -12
 2338              		.cfi_offset 11, -8
 2339              		.cfi_offset 14, -4
 2340 0a0c 0CD04DE2 		sub	sp, sp, #12	@,,
 2341              		.cfi_def_cfa_offset 48
 2342              	@ armwave.c:414:     uint32_t xx_rem = g_armwave_state.target_width, ypos = 0;
 2343              		.loc 1 414 14 view .LVU627
 2344 0a10 64419FE5 		ldr	r4, .L160	@ tmp270,
 2345              	@ armwave.c:416:     memset(g_armwave_state.ch1_buffer, 0, g_armwave_state.ch_buff_size);
 415:armwave.c     **** 
 416:armwave.c     ****     memset(g_armwave_state.ch1_buffer, 0, g_armwave_state.ch_buff_size);
 2346              		.loc 1 416 5 view .LVU628
 2347 0a14 0010A0E3 		mov	r1, #0	@,
 2348              	@ armwave.c:414:     uint32_t xx_rem = g_armwave_state.target_width, ypos = 0;
 414:armwave.c     **** 
 2349              		.loc 1 414 14 view .LVU629
 2350 0a18 4C3094E5 		ldr	r3, [r4, #76]	@ xx_rem, g_armwave_state.target_width
 2351              	@ armwave.c:416:     memset(g_armwave_state.ch1_buffer, 0, g_armwave_state.ch_buff_size);
 2352              		.loc 1 416 5 view .LVU630
 2353 0a1c 442094E5 		ldr	r2, [r4, #68]	@, g_armwave_state.ch_buff_size
 2354 0a20 040094E5 		ldr	r0, [r4, #4]	@, g_armwave_state.ch1_buffer
 2355              	@ armwave.c:414:     uint32_t xx_rem = g_armwave_state.target_width, ypos = 0;
 414:armwave.c     **** 
 2356              		.loc 1 414 14 view .LVU631
 2357 0a24 00308DE5 		str	r3, [sp]	@ xx_rem, %sfp
 2358              	.LVL170:
 2359              		.loc 1 416 5 is_stmt 1 view .LVU632
 2360 0a28 FEFFFFEB 		bl	memset		@
 2361              	.LVL171:
 417:armwave.c     **** 
 418:armwave.c     ****     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height); yy++) {
 2362              		.loc 1 418 5 view .LVU633
 2363              	@ armwave.c:418:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 2364              		.loc 1 418 38 is_stmt 0 view .LVU634
 2365 0a2c 4C7094E5 		ldr	r7, [r4, #76]	@ prephitmp_101, g_armwave_state.target_width
 2366              	@ armwave.c:418:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 2367              		.loc 1 418 69 view .LVU635
 2368 0a30 385094E5 		ldr	r5, [r4, #56]	@ _159, g_armwave_state.slice_height
 2369              	@ armwave.c:414:     uint32_t xx_rem = g_armwave_state.target_width, ypos = 0;
 414:armwave.c     **** 
 2370              		.loc 1 414 53 view .LVU636
 2371 0a34 0030A0E3 		mov	r3, #0	@ ypos,
 2372              	@ armwave.c:418:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 2373              		.loc 1 418 5 view .LVU637
 2374 0a38 070055E1 		cmp	r5, r7	@ _159, prephitmp_101
 2375              	@ armwave.c:414:     uint32_t xx_rem = g_armwave_state.target_width, ypos = 0;
 414:armwave.c     **** 
 2376              		.loc 1 414 53 view .LVU638
 2377 0a3c 04308DE5 		str	r3, [sp, #4]	@ ypos, %sfp
 2378              	@ armwave.c:418:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 2379              		.loc 1 418 5 view .LVU639
 2380 0a40 4800008A 		bhi	.L149		@,
 2381 0a44 2CA094E5 		ldr	r10, [r4, #44]	@ prephitmp_47, g_armwave_state.waves
 2382              	@ armwave.c:418:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 2383              		.loc 1 418 12 view .LVU640
 2384 0a48 0360A0E1 		mov	r6, r3	@ yy, ypos
 2385              	.LVL172:
 2386              	.L148:
 419:armwave.c     ****         //printf("armwave_test_generate: slice %d (y=%d, h=%d)\n", yy, yy * g_armwave_state.slice_h
 420:armwave.c     **** 
 421:armwave.c     ****         render_nonaa_to_buffer_1ch_slice(yy * g_armwave_state.slice_height, g_armwave_state.slice_r
 2387              		.loc 1 421 9 is_stmt 1 discriminator 3 view .LVU641
 2388 0a4c 950608E0 		mul	r8, r5, r6	@ _4, _159, yy
 2389              	.LBB27:
 2390              	.LBB28:
 2391              	@ armwave.c:82:     write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.bit
  82:armwave.c     **** 
 2392              		.loc 1 82 63 is_stmt 0 discriminator 3 view .LVU642
 2393 0a50 34E094E5 		ldr	lr, [r4, #52]	@ g_armwave_state.bitdepth_height, g_armwave_state.bitdepth_height
 2394              	@ armwave.c:85:     for(w = 0; w < g_armwave_state.waves; w++) {
  85:armwave.c     ****         //printf("wave_buffer=0x%08x\n", g_armwave_state.wave_buffer);
 2395              		.loc 1 85 5 discriminator 3 view .LVU643
 2396 0a54 00005AE3 		cmp	r10, #0	@ prephitmp_47,
 2397              	.LBE28:
 2398              	.LBE27:
 2399              	@ armwave.c:421:         render_nonaa_to_buffer_1ch_slice(yy * g_armwave_state.slice_height, g_armw
 2400              		.loc 1 421 9 discriminator 3 view .LVU644
 2401 0a58 3C9094E5 		ldr	r9, [r4, #60]	@ _5, g_armwave_state.slice_record_height
 2402              	.LVL173:
 2403              	.LBB30:
 2404              	.LBI27:
  73:armwave.c     **** {
 2405              		.loc 1 73 6 is_stmt 1 discriminator 3 view .LVU645
 2406              	.LBB29:
  75:armwave.c     ****     uint32_t value, word;
 2407              		.loc 1 75 5 discriminator 3 view .LVU646
  76:armwave.c     ****     uint8_t *wave_base;
 2408              		.loc 1 76 5 discriminator 3 view .LVU647
  77:armwave.c     ****     uint8_t *write_buffer_base;
 2409              		.loc 1 77 5 discriminator 3 view .LVU648
  78:armwave.c     ****     uint8_t *write_buffer;
 2410              		.loc 1 78 5 discriminator 3 view .LVU649
  79:armwave.c     **** 
 2411              		.loc 1 79 5 discriminator 3 view .LVU650
  82:armwave.c     **** 
 2412              		.loc 1 82 5 discriminator 3 view .LVU651
 2413              	@ armwave.c:82:     write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.bit
  82:armwave.c     **** 
 2414              		.loc 1 82 63 is_stmt 0 discriminator 3 view .LVU652
 2415 0a5c 9E080EE0 		mul	lr, lr, r8	@ _25, g_armwave_state.bitdepth_height, _4
 2416              	@ armwave.c:82:     write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.bit
  82:armwave.c     **** 
 2417              		.loc 1 82 40 discriminator 3 view .LVU653
 2418 0a60 043094E5 		ldr	r3, [r4, #4]	@ _23, g_armwave_state.ch1_buffer
 2419              	.LVL174:
  85:armwave.c     ****         //printf("wave_buffer=0x%08x\n", g_armwave_state.wave_buffer);
 2420              		.loc 1 85 5 is_stmt 1 discriminator 3 view .LVU654
  85:armwave.c     ****         //printf("wave_buffer=0x%08x\n", g_armwave_state.wave_buffer);
 2421              		.loc 1 85 5 is_stmt 0 discriminator 3 view .LVU655
 2422 0a64 3300000A 		beq	.L143		@,
 2423 0a68 048048E2 		sub	r8, r8, #4	@ _96, _4,
 2424              	.LVL175:
 2425              	@ armwave.c:85:     for(w = 0; w < g_armwave_state.waves; w++) {
  85:armwave.c     ****         //printf("wave_buffer=0x%08x\n", g_armwave_state.wave_buffer);
 2426              		.loc 1 85 11 view .LVU656
 2427 0a6c 0070A0E3 		mov	r7, #0	@ w,
 2428              	.LVL176:
 2429              	.L147:
  87:armwave.c     **** 
 2430              		.loc 1 87 9 is_stmt 1 view .LVU657
 2431              	@ armwave.c:87:         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wa
  87:armwave.c     **** 
 2432              		.loc 1 87 64 is_stmt 0 view .LVU658
 2433 0a70 282094E5 		ldr	r2, [r4, #40]	@ g_armwave_state.wave_stride, g_armwave_state.wave_stride
 2434              	@ armwave.c:91:         for(yy = 0; yy < height; yy += 4) {
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2435              		.loc 1 91 9 view .LVU659
 2436 0a74 000059E3 		cmp	r9, #0	@ _5,
 2437              	@ armwave.c:87:         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wa
  87:armwave.c     **** 
 2438              		.loc 1 87 36 view .LVU660
 2439 0a78 140094E5 		ldr	r0, [r4, #20]	@ _26, g_armwave_state.wave_buffer
 2440              	@ armwave.c:87:         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wa
  87:armwave.c     **** 
 2441              		.loc 1 87 64 view .LVU661
 2442 0a7c 920702E0 		mul	r2, r2, r7	@ _29, g_armwave_state.wave_stride, w
 2443              	.LVL177:
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2444              		.loc 1 91 9 is_stmt 1 view .LVU662
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2445              		.loc 1 91 9 is_stmt 0 view .LVU663
 2446 0a80 2700000A 		beq	.L144		@,
 2447 0a84 0110A0E3 		mov	r1, #1	@ tmp293,
 2448 0a88 000051E3 		cmp	r1, #0	@ tmp293,
 2449 0a8c 2300001A 		bne	.L145		@,
 2450 0a90 082082E0 		add	r2, r2, r8	@ tmp217, _29, _96
 2451              	.LVL178:
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2452              		.loc 1 91 9 view .LVU664
 2453 0a94 020080E0 		add	r0, r0, r2	@ ivtmp.104, _26, tmp217
 2454              	.LVL179:
 2455              	@ armwave.c:91:         for(yy = 0; yy < height; yy += 4) {
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2456              		.loc 1 91 16 view .LVU665
 2457 0a98 0120A0E1 		mov	r2, r1	@ yy, tmp293
 2458              	.LVL180:
 2459              	.L146:
  92:armwave.c     **** 
 2460              		.loc 1 92 13 is_stmt 1 view .LVU666
 2461              	@ armwave.c:92:             word = *(uint32_t*)(wave_base + yy);
  92:armwave.c     **** 
 2462              		.loc 1 92 18 is_stmt 0 view .LVU667
 2463 0a9c 0410B0E5 		ldr	r1, [r0, #4]!	@ word, MEM[base: _34, offset: 0B]
 2464              	.LVL181:
  94:armwave.c     ****                 //printf("write %d,%d ht %d\n", yy, ys, g_armwave_state.bitdepth_height);
 2465              		.loc 1 94 13 is_stmt 1 view .LVU668
  96:armwave.c     ****                 
 2466              		.loc 1 96 17 view .LVU669
  99:armwave.c     ****                     continue;
 2467              		.loc 1 99 17 view .LVU670
 102:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2468              		.loc 1 102 17 view .LVU671
 103:armwave.c     ****                 word >>= 8;
 2469              		.loc 1 103 17 view .LVU672
 2470              	@ armwave.c:102:                 write_buffer = write_buffer_base + ((yy + ys) * g_armwave_state.bi
 102:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2471              		.loc 1 102 63 is_stmt 0 view .LVU673
 2472 0aa0 345094E5 		ldr	r5, [r4, #52]	@ g_armwave_state.bitdepth_height, g_armwave_state.bitdepth_height
 2473 0aa4 01B082E2 		add	fp, r2, #1	@ tmp228, yy,
 2474              	@ armwave.c:103:                 *(write_buffer + scale_value) += 1;
 103:armwave.c     ****                 word >>= 8;
 2475              		.loc 1 103 47 view .LVU674
 2476 0aa8 71C0EEE6 		uxtab	ip, lr, r1	@ tmp222, _25, word
 2477 0aac 95C225E0 		mla	r5, r5, r2, ip	@ tmp223, g_armwave_state.bitdepth_height, yy, tmp222
 2478              	@ armwave.c:104:                 word >>= 8;
 104:armwave.c     ****             }
 2479              		.loc 1 104 22 view .LVU675
 2480 0ab0 21A4A0E1 		lsr	r10, r1, #8	@ word, word,
 2481              	@ armwave.c:103:                 *(write_buffer + scale_value) += 1;
 103:armwave.c     ****                 word >>= 8;
 2482              		.loc 1 103 47 view .LVU676
 2483 0ab4 05C0D3E7 		ldrb	ip, [r3, r5]	@ zero_extendqisi2	@ *_130, *_130
 2484 0ab8 7AA0EEE6 		uxtab	r10, lr, r10	@ tmp234, _25, word
 2485 0abc 01C08CE2 		add	ip, ip, #1	@ tmp226, *_130,
 2486 0ac0 05C0C3E7 		strb	ip, [r3, r5]	@ tmp226, *_130
 2487              	.LVL182:
 104:armwave.c     ****             }
 2488              		.loc 1 104 17 is_stmt 1 view .LVU677
  96:armwave.c     ****                 
 2489              		.loc 1 96 17 view .LVU678
  99:armwave.c     ****                     continue;
 2490              		.loc 1 99 17 view .LVU679
 102:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2491              		.loc 1 102 17 view .LVU680
 103:armwave.c     ****                 word >>= 8;
 2492              		.loc 1 103 17 view .LVU681
 2493              	@ armwave.c:102:                 write_buffer = write_buffer_base + ((yy + ys) * g_armwave_state.bi
 102:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2494              		.loc 1 102 63 is_stmt 0 view .LVU682
 2495 0ac4 34C094E5 		ldr	ip, [r4, #52]	@ g_armwave_state.bitdepth_height, g_armwave_state.bitdepth_height
 2496              	@ armwave.c:104:                 word >>= 8;
 104:armwave.c     ****             }
 2497              		.loc 1 104 22 view .LVU683
 2498 0ac8 2158A0E1 		lsr	r5, r1, #16	@ word, word,
 2499              	@ armwave.c:103:                 *(write_buffer + scale_value) += 1;
 103:armwave.c     ****                 word >>= 8;
 2500              		.loc 1 103 47 view .LVU684
 2501 0acc 211C8EE0 		add	r1, lr, r1, lsr #24	@ tmp257, _25, word,
 2502              	.LVL183:
 103:armwave.c     ****                 word >>= 8;
 2503              		.loc 1 103 47 view .LVU685
 2504 0ad0 9CAB2CE0 		mla	ip, ip, fp, r10	@ tmp235, g_armwave_state.bitdepth_height, tmp228, tmp234
 2505 0ad4 75A0EEE6 		uxtab	r10, lr, r5	@ tmp246, _25, word
 2506 0ad8 0CB0D3E7 		ldrb	fp, [r3, ip]	@ zero_extendqisi2	@ *_68, *_68
 2507              	@ armwave.c:102:                 write_buffer = write_buffer_base + ((yy + ys) * g_armwave_state.bi
 102:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2508              		.loc 1 102 63 view .LVU686
 2509 0adc 025082E2 		add	r5, r2, #2	@ tmp241, yy,
 2510              	@ armwave.c:103:                 *(write_buffer + scale_value) += 1;
 103:armwave.c     ****                 word >>= 8;
 2511              		.loc 1 103 47 view .LVU687
 2512 0ae0 01B08BE2 		add	fp, fp, #1	@ tmp238, *_68,
 2513 0ae4 0CB0C3E7 		strb	fp, [r3, ip]	@ tmp238, *_68
 2514              	.LVL184:
 104:armwave.c     ****             }
 2515              		.loc 1 104 17 is_stmt 1 view .LVU688
  96:armwave.c     ****                 
 2516              		.loc 1 96 17 view .LVU689
  99:armwave.c     ****                     continue;
 2517              		.loc 1 99 17 view .LVU690
 102:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2518              		.loc 1 102 17 view .LVU691
 103:armwave.c     ****                 word >>= 8;
 2519              		.loc 1 103 17 view .LVU692
 2520              	@ armwave.c:102:                 write_buffer = write_buffer_base + ((yy + ys) * g_armwave_state.bi
 102:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2521              		.loc 1 102 63 is_stmt 0 view .LVU693
 2522 0ae8 34B094E5 		ldr	fp, [r4, #52]	@ g_armwave_state.bitdepth_height, g_armwave_state.bitdepth_height
 2523 0aec 03C082E2 		add	ip, r2, #3	@ tmp253, yy,
 2524              	@ armwave.c:91:         for(yy = 0; yy < height; yy += 4) {
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2525              		.loc 1 91 37 view .LVU694
 2526 0af0 042082E2 		add	r2, r2, #4	@ yy, yy,
 2527              	.LVL185:
 2528              	@ armwave.c:103:                 *(write_buffer + scale_value) += 1;
 103:armwave.c     ****                 word >>= 8;
 2529              		.loc 1 103 47 view .LVU695
 2530 0af4 9BA525E0 		mla	r5, fp, r5, r10	@ tmp247, g_armwave_state.bitdepth_height, tmp241, tmp246
 2531              	@ armwave.c:91:         for(yy = 0; yy < height; yy += 4) {
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2532              		.loc 1 91 9 view .LVU696
 2533 0af8 020059E1 		cmp	r9, r2	@ _5, yy
 2534              	@ armwave.c:103:                 *(write_buffer + scale_value) += 1;
 103:armwave.c     ****                 word >>= 8;
 2535              		.loc 1 103 47 view .LVU697
 2536 0afc 05A0D3E7 		ldrb	r10, [r3, r5]	@ zero_extendqisi2	@ *_41, *_41
 2537 0b00 01A08AE2 		add	r10, r10, #1	@ tmp250, *_41,
 2538 0b04 05A0C3E7 		strb	r10, [r3, r5]	@ tmp250, *_41
 2539              	.LVL186:
 104:armwave.c     ****             }
 2540              		.loc 1 104 17 is_stmt 1 view .LVU698
  96:armwave.c     ****                 
 2541              		.loc 1 96 17 view .LVU699
  99:armwave.c     ****                     continue;
 2542              		.loc 1 99 17 view .LVU700
 102:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2543              		.loc 1 102 17 view .LVU701
 103:armwave.c     ****                 word >>= 8;
 2544              		.loc 1 103 17 view .LVU702
 2545              	@ armwave.c:102:                 write_buffer = write_buffer_base + ((yy + ys) * g_armwave_state.bi
 102:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2546              		.loc 1 102 63 is_stmt 0 view .LVU703
 2547 0b08 345094E5 		ldr	r5, [r4, #52]	@ g_armwave_state.bitdepth_height, g_armwave_state.bitdepth_height
 2548              	@ armwave.c:103:                 *(write_buffer + scale_value) += 1;
 103:armwave.c     ****                 word >>= 8;
 2549              		.loc 1 103 47 view .LVU704
 2550 0b0c 951C21E0 		mla	r1, r5, ip, r1	@ tmp258, g_armwave_state.bitdepth_height, tmp253, tmp257
 2551 0b10 01C0D3E7 		ldrb	ip, [r3, r1]	@ zero_extendqisi2	@ *_103, *_103
 2552 0b14 01C08CE2 		add	ip, ip, #1	@ tmp261, *_103,
 2553 0b18 01C0C3E7 		strb	ip, [r3, r1]	@ tmp261, *_103
 104:armwave.c     ****             }
 2554              		.loc 1 104 17 is_stmt 1 view .LVU705
 2555              	.LVL187:
 2556              	@ armwave.c:91:         for(yy = 0; yy < height; yy += 4) {
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2557              		.loc 1 91 9 is_stmt 0 view .LVU706
 2558 0b1c DEFFFF8A 		bhi	.L146		@,
 2559              	.LVL188:
 2560              	.L145:
  91:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2561              		.loc 1 91 9 view .LVU707
 2562 0b20 2CA094E5 		ldr	r10, [r4, #44]	@ prephitmp_47, g_armwave_state.waves
 2563              	.L144:
 2564              	@ armwave.c:85:     for(w = 0; w < g_armwave_state.waves; w++) {
  85:armwave.c     ****         //printf("wave_buffer=0x%08x\n", g_armwave_state.wave_buffer);
 2565              		.loc 1 85 44 view .LVU708
 2566 0b24 017087E2 		add	r7, r7, #1	@ w, w,
 2567              	.LVL189:
 2568              	@ armwave.c:85:     for(w = 0; w < g_armwave_state.waves; w++) {
  85:armwave.c     ****         //printf("wave_buffer=0x%08x\n", g_armwave_state.wave_buffer);
 2569              		.loc 1 85 5 view .LVU709
 2570 0b28 0A0057E1 		cmp	r7, r10	@ w, prephitmp_47
 2571 0b2c CFFFFF3A 		bcc	.L147		@,
 2572 0b30 385094E5 		ldr	r5, [r4, #56]	@ _159, g_armwave_state.slice_height
 2573 0b34 4C7094E5 		ldr	r7, [r4, #76]	@ prephitmp_101, g_armwave_state.target_width
 2574              	.LVL190:
 2575              	.L143:
  85:armwave.c     ****         //printf("wave_buffer=0x%08x\n", g_armwave_state.wave_buffer);
 2576              		.loc 1 85 5 view .LVU710
 2577              	.LBE29:
 2578              	.LBE30:
 422:armwave.c     ****         xx_rem -= g_armwave_state.slice_height;
 2579              		.loc 1 422 9 is_stmt 1 discriminator 3 view .LVU711
 2580              	@ armwave.c:418:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 418:armwave.c     ****         //printf("armwave_test_generate: slice %d (y=%d, h=%d)\n", yy, yy * g_armwave_state.slice_h
 2581              		.loc 1 418 52 is_stmt 0 discriminator 3 view .LVU712
 2582 0b38 0510A0E1 		mov	r1, r5	@, _159
 2583 0b3c 0700A0E1 		mov	r0, r7	@, prephitmp_101
 2584 0b40 FEFFFFEB 		bl	__aeabi_uidiv		@
 2585              	.LVL191:
 2586              	@ armwave.c:422:         xx_rem -= g_armwave_state.slice_height;
 2587              		.loc 1 422 16 discriminator 3 view .LVU713
 2588 0b44 00309DE5 		ldr	r3, [sp]	@ xx_rem, %sfp
 2589              	@ armwave.c:418:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 418:armwave.c     ****         //printf("armwave_test_generate: slice %d (y=%d, h=%d)\n", yy, yy * g_armwave_state.slice_h
 2590              		.loc 1 418 87 discriminator 3 view .LVU714
 2591 0b48 016086E2 		add	r6, r6, #1	@ yy, yy,
 2592              	.LVL192:
 2593              	@ armwave.c:422:         xx_rem -= g_armwave_state.slice_height;
 2594              		.loc 1 422 16 discriminator 3 view .LVU715
 2595 0b4c 053043E0 		sub	r3, r3, r5	@ xx_rem, xx_rem, _159
 2596 0b50 00308DE5 		str	r3, [sp]	@ xx_rem, %sfp
 2597              	.LVL193:
 423:armwave.c     ****         ypos += g_armwave_state.slice_height;
 2598              		.loc 1 423 9 is_stmt 1 discriminator 3 view .LVU716
 2599              	@ armwave.c:423:         ypos += g_armwave_state.slice_height;
 2600              		.loc 1 423 14 is_stmt 0 discriminator 3 view .LVU717
 2601 0b54 04309DE5 		ldr	r3, [sp, #4]	@ ypos, %sfp
 2602              	.LVL194:
 2603              		.loc 1 423 14 discriminator 3 view .LVU718
 2604 0b58 053083E0 		add	r3, r3, r5	@ ypos, ypos, _159
 2605 0b5c 04308DE5 		str	r3, [sp, #4]	@ ypos, %sfp
 2606              	.LVL195:
 2607              	@ armwave.c:418:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 418:armwave.c     ****         //printf("armwave_test_generate: slice %d (y=%d, h=%d)\n", yy, yy * g_armwave_state.slice_h
 2608              		.loc 1 418 5 discriminator 3 view .LVU719
 2609 0b60 060050E1 		cmp	r0, r6	@, yy
 2610 0b64 B8FFFF8A 		bhi	.L148		@,
 2611              	.LVL196:
 2612              	.L149:
 418:armwave.c     ****         //printf("armwave_test_generate: slice %d (y=%d, h=%d)\n", yy, yy * g_armwave_state.slice_h
 2613              		.loc 1 418 5 discriminator 3 view .LVU720
 2614 0b68 0300A0E1 		mov	r0, r3	@, ypos
 424:armwave.c     ****     }
 425:armwave.c     **** 
 426:armwave.c     ****     render_nonaa_to_buffer_1ch_slice(ypos, xx_rem);
 2615              		.loc 1 426 5 is_stmt 1 view .LVU721
 2616 0b6c 00109DE5 		ldr	r1, [sp]	@, %sfp
 2617              	@ armwave.c:427: }
 427:armwave.c     **** }
 2618              		.loc 1 427 1 is_stmt 0 view .LVU722
 2619 0b70 0CD08DE2 		add	sp, sp, #12	@,,
 2620              		.cfi_def_cfa_offset 36
 2621              	.LVL197:
 2622              		.loc 1 427 1 view .LVU723
 2623              		@ sp needed	@
 2624 0b74 F04FBDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, lr}	@
 2625              		.cfi_restore 14
 2626              		.cfi_restore 11
 2627              		.cfi_restore 10
 2628              		.cfi_restore 9
 2629              		.cfi_restore 8
 2630              		.cfi_restore 7
 2631              		.cfi_restore 6
 2632              		.cfi_restore 5
 2633              		.cfi_restore 4
 2634              		.cfi_def_cfa_offset 0
 2635              	@ armwave.c:426:     render_nonaa_to_buffer_1ch_slice(ypos, xx_rem);
 426:armwave.c     **** }
 2636              		.loc 1 426 5 view .LVU724
 2637 0b78 FEFFFFEA 		b	render_nonaa_to_buffer_1ch_slice		@
 2638              	.LVL198:
 2639              	.L161:
 2640              		.align	2
 2641              	.L160:
 2642 0b7c 00000000 		.word	g_armwave_state
 2643              		.cfi_endproc
 2644              	.LFE70:
 2646              		.align	2
 2647              		.global	armwave_test_fill_outbuf
 2648              		.syntax unified
 2649              		.arm
 2650              		.fpu vfp
 2652              	armwave_test_fill_outbuf:
 2653              	.LFB71:
 428:armwave.c     **** 
 429:armwave.c     **** /*
 430:armwave.c     ****  * Render image to the local allocated buffer.
 431:armwave.c     ****  */
 432:armwave.c     **** void armwave_test_fill_outbuf()
 433:armwave.c     **** {
 2654              		.loc 1 433 1 is_stmt 1 view -0
 2655              		.cfi_startproc
 2656              		@ args = 0, pretend = 0, frame = 8
 2657              		@ frame_needed = 0, uses_anonymous_args = 0
 434:armwave.c     ****     armwave_fill_pixbuf_scaled(g_armwave_state.out_pixbuf);
 2658              		.loc 1 434 5 view .LVU726
 2659 0b80 50C19FE5 		ldr	ip, .L183	@ tmp205,
 2660              	@ armwave.c:433: {
 433:armwave.c     ****     armwave_fill_pixbuf_scaled(g_armwave_state.out_pixbuf);
 2661              		.loc 1 433 1 is_stmt 0 view .LVU727
 2662 0b84 F04F2DE9 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}	@
 2663              		.cfi_def_cfa_offset 36
 2664              		.cfi_offset 4, -36
 2665              		.cfi_offset 5, -32
 2666              		.cfi_offset 6, -28
 2667              		.cfi_offset 7, -24
 2668              		.cfi_offset 8, -20
 2669              		.cfi_offset 9, -16
 2670              		.cfi_offset 10, -12
 2671              		.cfi_offset 11, -8
 2672              		.cfi_offset 14, -4
 2673 0b88 0CD04DE2 		sub	sp, sp, #12	@,,
 2674              		.cfi_def_cfa_offset 48
 2675              	@ armwave.c:434:     armwave_fill_pixbuf_scaled(g_armwave_state.out_pixbuf);
 2676              		.loc 1 434 5 view .LVU728
 2677 0b8c 5C809CE5 		ldr	r8, [ip, #92]	@ _1, g_armwave_state.out_pixbuf
 2678              	.LVL199:
 2679              	.LBB33:
 2680              	.LBI33:
 167:armwave.c     **** {
 2681              		.loc 1 167 6 is_stmt 1 view .LVU729
 2682              	.LBB34:
 169:armwave.c     ****     int rr, gg, bb, n, nsub, npix, w, vscale;
 2683              		.loc 1 169 5 view .LVU730
 170:armwave.c     ****     uint8_t r, g, b, value, row;
 2684              		.loc 1 170 5 view .LVU731
 171:armwave.c     ****     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 2685              		.loc 1 171 5 view .LVU732
 172:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 2686              		.loc 1 172 5 view .LVU733
 2687              	@ armwave.c:172:     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 172:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 2688              		.loc 1 172 15 is_stmt 0 view .LVU734
 2689 0b90 04909CE5 		ldr	r9, [ip, #4]	@ base_32ptr, g_armwave_state.ch1_buffer
 2690              	.LVL200:
 173:armwave.c     ****     uint32_t offset;
 2691              		.loc 1 173 5 is_stmt 1 view .LVU735
 174:armwave.c     **** 
 2692              		.loc 1 174 5 view .LVU736
 176:armwave.c     **** 
 2693              		.loc 1 176 5 view .LVU737
 2694 0b94 000058E3 		cmp	r8, #0	@ _1,
 2695 0b98 4900000A 		beq	.L181		@,
 178:armwave.c     ****     vscale = g_armwave_state.target_height >> 8;
 2696              		.loc 1 178 5 view .LVU738
 2697              	@ armwave.c:178:     npix = g_armwave_state.target_width * 256; 
 178:armwave.c     ****     vscale = g_armwave_state.target_height >> 8;
 2698              		.loc 1 178 41 is_stmt 0 view .LVU739
 2699 0b9c 4C709CE5 		ldr	r7, [ip, #76]	@ g_armwave_state.target_width, g_armwave_state.target_width
 2700 0ba0 0774A0E1 		lsl	r7, r7, #8	@ npix, g_armwave_state.target_width,
 2701              	.LVL201:
 179:armwave.c     **** 
 2702              		.loc 1 179 5 is_stmt 1 view .LVU740
 181:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 2703              		.loc 1 181 5 view .LVU741
 181:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 2704              		.loc 1 181 5 is_stmt 0 view .LVU742
 2705 0ba4 000057E3 		cmp	r7, #0	@ npix,
 2706 0ba8 0A0000DA 		ble	.L162		@,
 2707              	@ armwave.c:193:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 193:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 2708              		.loc 1 193 52 view .LVU743
 2709 0bac F0B6DCE1 		ldrsh	fp, [ip, #96]	@ _18, g_armwave_state.ch1_color.r
 2710              	@ armwave.c:194:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 194:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 2711              		.loc 1 194 52 view .LVU744
 2712 0bb0 F2A6DCE1 		ldrsh	r10, [ip, #98]	@ _24, g_armwave_state.ch1_color.g
 2713              	@ armwave.c:195:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 195:armwave.c     **** 
 2714              		.loc 1 195 52 view .LVU745
 2715 0bb4 F456DCE1 		ldrsh	r5, [ip, #100]	@ _28, g_armwave_state.ch1_color.b
 2716              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2717              		.loc 1 217 57 view .LVU746
 2718 0bb8 076ADCED 		vldr.32	s13, [ip, #28]	@ _50, g_armwave_state.vscale_frac
 2719              	@ armwave.c:181:     for(n = 0; n < npix; n += 4) {
 181:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 2720              		.loc 1 181 11 view .LVU747
 2721 0bbc 00E0A0E3 		mov	lr, #0	@ n,
 2722              	.LVL202:
 2723              	.L169:
 185:armwave.c     **** 
 2724              		.loc 1 185 9 is_stmt 1 view .LVU748
 2725              	@ armwave.c:185:         wave_word = *base_32ptr++;
 185:armwave.c     **** 
 2726              		.loc 1 185 19 is_stmt 0 view .LVU749
 2727 0bc0 040099E4 		ldr	r0, [r9], #4	@ wave_word, MEM[base: base_32ptr_9, offset: 4294967292B]
 2728              	.LVL203:
 187:armwave.c     ****             for(w = 0; w < 4; w++) {
 2729              		.loc 1 187 9 is_stmt 1 view .LVU750
 2730              	@ armwave.c:187:         if(COND_UNLIKELY(wave_word != 0)) {
 187:armwave.c     ****             for(w = 0; w < 4; w++) {
 2731              		.loc 1 187 11 is_stmt 0 view .LVU751
 2732 0bc4 000050E3 		cmp	r0, #0	@ wave_word,
 2733 0bc8 0400001A 		bne	.L178		@,
 2734 0bcc 04E08EE2 		add	lr, lr, #4	@ n, n,
 2735              	.L165:
 2736              	.LVL204:
 2737              	@ armwave.c:181:     for(n = 0; n < npix; n += 4) {
 181:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 2738              		.loc 1 181 5 view .LVU752
 2739 0bd0 0E0057E1 		cmp	r7, lr	@ npix, n
 2740 0bd4 F9FFFFCA 		bgt	.L169		@,
 2741              	.LVL205:
 2742              	.L162:
 181:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 2743              		.loc 1 181 5 view .LVU753
 2744              	.LBE34:
 2745              	.LBE33:
 2746              	@ armwave.c:435: }
 435:armwave.c     **** }
 2747              		.loc 1 435 1 view .LVU754
 2748 0bd8 0CD08DE2 		add	sp, sp, #12	@,,
 2749              		.cfi_remember_state
 2750              		.cfi_def_cfa_offset 36
 2751              		@ sp needed	@
 2752 0bdc F08FBDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}	@
 2753              	.LVL206:
 2754              	.L178:
 2755              		.cfi_restore_state
 2756              	.LBB36:
 2757              	.LBB35:
 2758              	@ armwave.c:192:                 if(value != 0) {
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2759              		.loc 1 192 19 view .LVU755
 2760 0be0 FF1010E2 		ands	r1, r0, #255	@ _20, wave_word,
 2761              	@ armwave.c:187:         if(COND_UNLIKELY(wave_word != 0)) {
 187:armwave.c     ****             for(w = 0; w < 4; w++) {
 2762              		.loc 1 187 11 view .LVU756
 2763 0be4 0E60A0E1 		mov	r6, lr	@ ivtmp.121, n
 2764              	.LVL207:
 189:armwave.c     ****                 wave_word >>= 8;
 2765              		.loc 1 189 17 is_stmt 1 view .LVU757
 190:armwave.c     **** 
 2766              		.loc 1 190 17 view .LVU758
 2767              	@ armwave.c:190:                 wave_word >>= 8;
 190:armwave.c     **** 
 2768              		.loc 1 190 27 is_stmt 0 view .LVU759
 2769 0be8 2004A0E1 		lsr	r0, r0, #8	@ wave_word, wave_word,
 2770              	.LVL208:
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2771              		.loc 1 192 17 is_stmt 1 view .LVU760
 2772 0bec 04E08EE2 		add	lr, lr, #4	@ n, ivtmp.121,
 2773              	@ armwave.c:192:                 if(value != 0) {
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2774              		.loc 1 192 19 is_stmt 0 view .LVU761
 2775 0bf0 0500001A 		bne	.L182		@,
 2776              	.LVL209:
 2777              	.L166:
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2778              		.loc 1 192 19 view .LVU762
 2779 0bf4 016086E2 		add	r6, r6, #1	@ ivtmp.121, ivtmp.121,
 2780              	@ armwave.c:188:             for(w = 0; w < 4; w++) {
 188:armwave.c     ****                 value = wave_word & 0xff;
 2781              		.loc 1 188 13 view .LVU763
 2782 0bf8 06005EE1 		cmp	lr, r6	@ n, ivtmp.121
 2783 0bfc F3FFFF0A 		beq	.L165		@,
 189:armwave.c     ****                 wave_word >>= 8;
 2784              		.loc 1 189 17 is_stmt 1 view .LVU764
 2785              	.LVL210:
 190:armwave.c     **** 
 2786              		.loc 1 190 17 view .LVU765
 2787              	@ armwave.c:192:                 if(value != 0) {
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2788              		.loc 1 192 19 is_stmt 0 view .LVU766
 2789 0c00 FF1010E2 		ands	r1, r0, #255	@ _20, wave_word,
 2790              	@ armwave.c:190:                 wave_word >>= 8;
 190:armwave.c     **** 
 2791              		.loc 1 190 27 view .LVU767
 2792 0c04 2004A0E1 		lsr	r0, r0, #8	@ wave_word, wave_word,
 2793              	.LVL211:
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2794              		.loc 1 192 17 is_stmt 1 view .LVU768
 2795              	@ armwave.c:192:                 if(value != 0) {
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2796              		.loc 1 192 19 is_stmt 0 view .LVU769
 2797 0c08 F9FFFF0A 		beq	.L166		@,
 2798              	.L182:
 193:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 2799              		.loc 1 193 21 is_stmt 1 view .LVU770
 2800              	.LVL212:
 194:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 2801              		.loc 1 194 21 view .LVU771
 195:armwave.c     **** 
 2802              		.loc 1 195 21 view .LVU772
 197:armwave.c     ****                     g = MIN(gg, 255);
 2803              		.loc 1 197 21 view .LVU773
 198:armwave.c     ****                     b = MIN(bb, 255);
 2804              		.loc 1 198 21 view .LVU774
 199:armwave.c     **** 
 2805              		.loc 1 199 21 view .LVU775
 202:armwave.c     **** 
 2806              		.loc 1 202 21 view .LVU776
 2807              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2808              		.loc 1 217 32 is_stmt 0 view .LVU777
 2809 0c0c 7630EFE6 		uxtb	r3, r6	@ _48, ivtmp.121
 2810              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 2811              		.loc 1 218 41 view .LVU778
 2812 0c10 012083E2 		add	r2, r3, #1	@ tmp197, _48,
 2813              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2814              		.loc 1 217 40 view .LVU779
 2815 0c14 903A07EE 		vmov	s15, r3	@ int	@ _48, _48
 2816              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 2817              		.loc 1 218 41 view .LVU780
 2818 0c18 102A07EE 		vmov	s14, r2	@ int	@ tmp197, tmp197
 2819              	@ armwave.c:195:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 195:armwave.c     **** 
 2820              		.loc 1 195 55 view .LVU781
 2821 0c1c 950103E0 		mul	r3, r5, r1	@ tmp182, _28, _20
 2822              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2823              		.loc 1 217 40 view .LVU782
 2824 0c20 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp195, _48
 2825              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 2826              		.loc 1 218 46 view .LVU783
 2827 0c24 C77AB8EE 		vcvt.f32.s32	s14, s14	@ tmp198, tmp197
 2828              	@ armwave.c:194:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 194:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 2829              		.loc 1 194 55 view .LVU784
 2830 0c28 9A0102E0 		mul	r2, r10, r1	@ tmp186, _24, _20
 2831              	@ armwave.c:195:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 195:armwave.c     **** 
 2832              		.loc 1 195 24 view .LVU785
 2833 0c2c 4334A0E1 		asr	r3, r3, #8	@ bb, tmp182,
 2834              	.LVL213:
 2835              	@ armwave.c:199:                     b = MIN(bb, 255);
 199:armwave.c     **** 
 2836              		.loc 1 199 25 view .LVU786
 2837 0c30 FF0053E3 		cmp	r3, #255	@ bb,
 2838              	@ armwave.c:194:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 194:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 2839              		.loc 1 194 24 view .LVU787
 2840 0c34 4224A0E1 		asr	r2, r2, #8	@ gg, tmp186,
 2841              	.LVL214:
 2842              	@ armwave.c:199:                     b = MIN(bb, 255);
 199:armwave.c     **** 
 2843              		.loc 1 199 25 view .LVU788
 2844 0c38 FF30A0A3 		movge	r3, #255	@ bb,
 2845              	.LVL215:
 2846              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2847              		.loc 1 217 40 view .LVU789
 2848 0c3c A67A67EE 		vmul.f32	s15, s15, s13	@ tmp196, tmp195, _50
 2849              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 2850              		.loc 1 218 46 view .LVU790
 2851 0c40 267A27EE 		vmul.f32	s14, s14, s13	@ tmp199, tmp198, _50
 2852              	@ armwave.c:198:                     g = MIN(gg, 255);
 198:armwave.c     ****                     b = MIN(bb, 255);
 2853              		.loc 1 198 25 view .LVU791
 2854 0c44 FF0052E3 		cmp	r2, #255	@ gg,
 2855 0c48 FF20A0A3 		movge	r2, #255	@ gg,
 2856              	.LVL216:
 2857              	@ armwave.c:193:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 193:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 2858              		.loc 1 193 55 view .LVU792
 2859 0c4c 910B01E0 		mul	r1, r1, fp	@ tmp192, _20, _18
 2860              	.LVL217:
 2861              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 2862              		.loc 1 202 56 view .LVU793
 2863 0c50 0224A0E1 		lsl	r2, r2, #8	@ tmp187, gg,
 2864              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 2865              		.loc 1 202 44 view .LVU794
 2866 0c54 0338A0E1 		lsl	r3, r3, #16	@ tmp183, bb,
 2867              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2868              		.loc 1 217 24 view .LVU795
 2869 0c58 E77AFCEE 		vcvt.u32.f32	s15, s15	@ yy, tmp196
 2870              	@ armwave.c:193:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 193:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 2871              		.loc 1 193 24 view .LVU796
 2872 0c5c 4114A0E1 		asr	r1, r1, #8	@ rr, tmp192,
 2873              	.LVL218:
 2874              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 2875              		.loc 1 202 56 view .LVU797
 2876 0c60 7220FFE6 		uxth	r2, r2	@ tmp188, tmp187
 2877              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 2878              		.loc 1 202 44 view .LVU798
 2879 0c64 FF3803E2 		and	r3, r3, #16711680	@ tmp184, tmp183,
 2880              	@ armwave.c:197:                     r = MIN(rr, 255);
 197:armwave.c     ****                     g = MIN(gg, 255);
 2881              		.loc 1 197 25 view .LVU799
 2882 0c68 FF0051E3 		cmp	r1, #255	@ rr,
 2883              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 2884              		.loc 1 202 51 view .LVU800
 2885 0c6c 023083E1 		orr	r3, r3, r2	@ tmp190, tmp184, tmp188
 2886              	@ armwave.c:197:                     r = MIN(rr, 255);
 197:armwave.c     ****                     g = MIN(gg, 255);
 2887              		.loc 1 197 25 view .LVU801
 2888 0c70 FF10A0A3 		movge	r1, #255	@ rr,
 2889              	.LVL219:
 2890              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2891              		.loc 1 217 24 view .LVU802
 2892 0c74 904A17EE 		vmov	r4, s15	@ int	@ yy, yy
 2893              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 2894              		.loc 1 218 24 view .LVU803
 2895 0c78 C77AFCEE 		vcvt.u32.f32	s15, s14	@ ye, tmp199
 2896              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 2897              		.loc 1 202 62 view .LVU804
 2898 0c7c 7110EFE6 		uxtb	r1, r1	@ rr, rr
 2899 0c80 013083E1 		orr	r3, r3, r1	@ tmp194, tmp190, rr
 2900              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 2901              		.loc 1 202 26 view .LVU805
 2902 0c84 FF3483E3 		orr	r3, r3, #-16777216	@ word, tmp194,
 2903              	.LVL220:
 216:armwave.c     ****                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 2904              		.loc 1 216 21 is_stmt 1 view .LVU806
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2905              		.loc 1 217 21 view .LVU807
 218:armwave.c     ****                     xx = (nsub >> 8);
 2906              		.loc 1 218 21 view .LVU808
 219:armwave.c     **** 
 2907              		.loc 1 219 21 view .LVU809
 2908              	@ armwave.c:219:                     xx = (nsub >> 8);
 219:armwave.c     **** 
 2909              		.loc 1 219 32 is_stmt 0 view .LVU810
 2910 0c88 4614A0E1 		asr	r1, r6, #8	@ xx, ivtmp.121,
 2911              	.LVL221:
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2912              		.loc 1 221 21 is_stmt 1 view .LVU811
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2913              		.loc 1 221 21 is_stmt 0 view .LVU812
 2914 0c8c 902A17EE 		vmov	r2, s15	@ int	@ ye,
 2915              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 2916              		.loc 1 218 24 view .LVU813
 2917 0c90 007ACDED 		vstr.32	s15, [sp]	@ int	@ ye, %sfp
 2918              	.LVL222:
 2919              	@ armwave.c:221:                     for(y = yy; y < ye; y++) {
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2920              		.loc 1 221 21 view .LVU814
 2921 0c94 020054E1 		cmp	r4, r2	@ yy, ye
 2922 0c98 D5FFFF2A 		bcs	.L166		@,
 2923 0c9c 04008DE5 		str	r0, [sp, #4]	@ wave_word, %sfp
 2924              	.LVL223:
 2925              	.L167:
 222:armwave.c     ****                         *(out_buffer_base + offset) = word;
 2926              		.loc 1 222 25 is_stmt 1 view .LVU815
 223:armwave.c     ****                     }
 2927              		.loc 1 223 25 view .LVU816
 2928              	@ armwave.c:222:                         offset = (xx + (y * g_armwave_state.target_width)); 
 222:armwave.c     ****                         *(out_buffer_base + offset) = word;
 2929              		.loc 1 222 43 is_stmt 0 view .LVU817
 2930 0ca0 4C209CE5 		ldr	r2, [ip, #76]	@ g_armwave_state.target_width, g_armwave_state.target_width
 2931              	@ armwave.c:221:                     for(y = yy; y < ye; y++) {
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2932              		.loc 1 221 21 view .LVU818
 2933 0ca4 00009DE5 		ldr	r0, [sp]	@ ye, %sfp
 2934              	@ armwave.c:223:                         *(out_buffer_base + offset) = word;
 223:armwave.c     ****                     }
 2935              		.loc 1 223 43 view .LVU819
 2936 0ca8 921422E0 		mla	r2, r2, r4, r1	@ tmp203, g_armwave_state.target_width, yy, xx
 2937              	.LVL224:
 2938              	@ armwave.c:221:                     for(y = yy; y < ye; y++) {
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2939              		.loc 1 221 42 view .LVU820
 2940 0cac 014084E2 		add	r4, r4, #1	@ yy, yy,
 2941              	.LVL225:
 2942              	@ armwave.c:221:                     for(y = yy; y < ye; y++) {
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2943              		.loc 1 221 21 view .LVU821
 2944 0cb0 040050E1 		cmp	r0, r4	@ ye, yy
 2945              	@ armwave.c:223:                         *(out_buffer_base + offset) = word;
 223:armwave.c     ****                     }
 2946              		.loc 1 223 53 view .LVU822
 2947 0cb4 023188E7 		str	r3, [r8, r2, lsl #2]	@ word, *_64
 2948              	@ armwave.c:221:                     for(y = yy; y < ye; y++) {
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2949              		.loc 1 221 21 view .LVU823
 2950 0cb8 F8FFFF1A 		bne	.L167		@,
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2951              		.loc 1 221 21 view .LVU824
 2952 0cbc 04009DE5 		ldr	r0, [sp, #4]	@ wave_word, %sfp
 2953 0cc0 CBFFFFEA 		b	.L166		@
 2954              	.LVL226:
 2955              	.L181:
 176:armwave.c     **** 
 2956              		.loc 1 176 5 is_stmt 1 view .LVU825
 2957 0cc4 10309FE5 		ldr	r3, .L183+4	@,
 2958 0cc8 B020A0E3 		mov	r2, #176	@,
 2959 0ccc 0C109FE5 		ldr	r1, .L183+8	@,
 2960 0cd0 0C009FE5 		ldr	r0, .L183+12	@,
 2961 0cd4 FEFFFFEB 		bl	__assert_fail		@
 2962              	.LVL227:
 2963              	.L184:
 2964              		.align	2
 2965              	.L183:
 2966 0cd8 00000000 		.word	g_armwave_state
 2967 0cdc 18000000 		.word	.LANCHOR0+24
 2968 0ce0 20000000 		.word	.LC2
 2969 0ce4 2C000000 		.word	.LC3
 2970              	.LBE35:
 2971              	.LBE36:
 2972              		.cfi_endproc
 2973              	.LFE71:
 2975              		.align	2
 2976              		.global	armwave_test_dump_buffer_to_ppm
 2977              		.syntax unified
 2978              		.arm
 2979              		.fpu vfp
 2981              	armwave_test_dump_buffer_to_ppm:
 2982              	.LVL228:
 2983              	.LFB72:
 436:armwave.c     **** 
 437:armwave.c     **** /*
 438:armwave.c     ****  * Dump the working local allocated buffer to a ppm file for debug.
 439:armwave.c     ****  */
 440:armwave.c     **** void armwave_test_dump_buffer_to_ppm(char *fn)
 441:armwave.c     **** {
 2984              		.loc 1 441 1 view -0
 2985              		.cfi_startproc
 2986              		@ args = 0, pretend = 0, frame = 0
 2987              		@ frame_needed = 0, uses_anonymous_args = 0
 2988              		@ link register save eliminated.
 442:armwave.c     ****     armwave_dump_ppm_debug(g_armwave_state.out_pixbuf, fn);
 2989              		.loc 1 442 5 view .LVU827
 2990 0ce8 08309FE5 		ldr	r3, .L186	@ tmp112,
 2991 0cec 0010A0E1 		mov	r1, r0	@, fn
 2992 0cf0 5C0093E5 		ldr	r0, [r3, #92]	@, g_armwave_state.out_pixbuf
 2993              	.LVL229:
 2994              		.loc 1 442 5 is_stmt 0 view .LVU828
 2995 0cf4 FEFFFFEA 		b	armwave_dump_ppm_debug		@
 2996              	.LVL230:
 2997              	.L187:
 2998              		.loc 1 442 5 view .LVU829
 2999              		.align	2
 3000              	.L186:
 3001 0cf8 00000000 		.word	g_armwave_state
 3002              		.cfi_endproc
 3003              	.LFE72:
 3005              		.align	2
 3006              		.global	armwave_test_fill_gdkbuf
 3007              		.syntax unified
 3008              		.arm
 3009              		.fpu vfp
 3011              	armwave_test_fill_gdkbuf:
 3012              	.LVL231:
 3013              	.LFB73:
 443:armwave.c     **** }
 444:armwave.c     **** 
 445:armwave.c     **** /*
 446:armwave.c     ****  * Render GDK buffer with test funtionry.
 447:armwave.c     ****  */
 448:armwave.c     **** void armwave_test_fill_gdkbuf(PyObject *buf)
 449:armwave.c     **** {
 3014              		.loc 1 449 1 is_stmt 1 view -0
 3015              		.cfi_startproc
 3016              		@ args = 0, pretend = 0, frame = 8
 3017              		@ frame_needed = 0, uses_anonymous_args = 0
 450:armwave.c     ****     //PyObject *mv;
 451:armwave.c     ****     //Py_buffer *buf = malloc(sizeof(Py_buffer));
 452:armwave.c     **** 
 453:armwave.c     ****     // Holy jesus dear mother of God, what have we done?
 454:armwave.c     ****     void *out_pixbuf = ((uint32_t ***)buf)[2][10];
 3018              		.loc 1 454 5 view .LVU831
 3019              	@ armwave.c:454:     void *out_pixbuf = ((uint32_t ***)buf)[2][10];
 3020              		.loc 1 454 11 is_stmt 0 view .LVU832
 3021 0cfc 083090E5 		ldr	r3, [r0, #8]	@ MEM[(uint32_t * * *)buf_2(D) + 8B], MEM[(uint32_t * * *)buf_2(D) + 8B]
 3022              	@ armwave.c:449: {
 449:armwave.c     ****     //PyObject *mv;
 3023              		.loc 1 449 1 view .LVU833
 3024 0d00 F04F2DE9 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}	@
 3025              		.cfi_def_cfa_offset 36
 3026              		.cfi_offset 4, -36
 3027              		.cfi_offset 5, -32
 3028              		.cfi_offset 6, -28
 3029              		.cfi_offset 7, -24
 3030              		.cfi_offset 8, -20
 3031              		.cfi_offset 9, -16
 3032              		.cfi_offset 10, -12
 3033              		.cfi_offset 11, -8
 3034              		.cfi_offset 14, -4
 3035 0d04 0CD04DE2 		sub	sp, sp, #12	@,,
 3036              		.cfi_def_cfa_offset 48
 3037              	.LBB39:
 3038              	.LBB40:
 3039              	@ armwave.c:172:     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 172:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 3040              		.loc 1 172 15 view .LVU834
 3041 0d08 48519FE5 		ldr	r5, .L209	@ tmp208,
 3042              	.LBE40:
 3043              	.LBE39:
 3044              	@ armwave.c:454:     void *out_pixbuf = ((uint32_t ***)buf)[2][10];
 3045              		.loc 1 454 11 view .LVU835
 3046 0d0c 288093E5 		ldr	r8, [r3, #40]	@ out_pixbuf, MEM[(uint32_t * *)_1 + 40B]
 3047              	.LVL232:
 455:armwave.c     ****     
 456:armwave.c     ****     // TODO: use armwave_fill_pixbuf_256 for 256-height buffers for performance?
 457:armwave.c     ****     armwave_fill_pixbuf_scaled(out_pixbuf);
 3048              		.loc 1 457 5 is_stmt 1 view .LVU836
 3049              	.LBB43:
 3050              	.LBI39:
 167:armwave.c     **** {
 3051              		.loc 1 167 6 view .LVU837
 3052              	.LBB41:
 169:armwave.c     ****     int rr, gg, bb, n, nsub, npix, w, vscale;
 3053              		.loc 1 169 5 view .LVU838
 170:armwave.c     ****     uint8_t r, g, b, value, row;
 3054              		.loc 1 170 5 view .LVU839
 171:armwave.c     ****     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 3055              		.loc 1 171 5 view .LVU840
 172:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 3056              		.loc 1 172 5 view .LVU841
 3057              	@ armwave.c:176:     assert(out_buffer != NULL);
 176:armwave.c     **** 
 3058              		.loc 1 176 5 is_stmt 0 view .LVU842
 3059 0d10 000058E3 		cmp	r8, #0	@ out_pixbuf,
 3060              	@ armwave.c:172:     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 172:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 3061              		.loc 1 172 15 view .LVU843
 3062 0d14 049095E5 		ldr	r9, [r5, #4]	@ base_32ptr, g_armwave_state.ch1_buffer
 3063              	.LVL233:
 173:armwave.c     ****     uint32_t offset;
 3064              		.loc 1 173 5 is_stmt 1 view .LVU844
 174:armwave.c     **** 
 3065              		.loc 1 174 5 view .LVU845
 176:armwave.c     **** 
 3066              		.loc 1 176 5 view .LVU846
 3067 0d18 4900000A 		beq	.L207		@,
 178:armwave.c     ****     vscale = g_armwave_state.target_height >> 8;
 3068              		.loc 1 178 5 view .LVU847
 3069              	@ armwave.c:178:     npix = g_armwave_state.target_width * 256; 
 178:armwave.c     ****     vscale = g_armwave_state.target_height >> 8;
 3070              		.loc 1 178 41 is_stmt 0 view .LVU848
 3071 0d1c 4C7095E5 		ldr	r7, [r5, #76]	@ g_armwave_state.target_width, g_armwave_state.target_width
 3072 0d20 0774A0E1 		lsl	r7, r7, #8	@ npix, g_armwave_state.target_width,
 3073              	.LVL234:
 179:armwave.c     **** 
 3074              		.loc 1 179 5 is_stmt 1 view .LVU849
 181:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 3075              		.loc 1 181 5 view .LVU850
 181:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 3076              		.loc 1 181 5 is_stmt 0 view .LVU851
 3077 0d24 000057E3 		cmp	r7, #0	@ npix,
 3078 0d28 0A0000DA 		ble	.L188		@,
 3079              	@ armwave.c:193:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 193:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 3080              		.loc 1 193 52 view .LVU852
 3081 0d2c F0B6D5E1 		ldrsh	fp, [r5, #96]	@ _20, g_armwave_state.ch1_color.r
 3082              	@ armwave.c:194:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 194:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 3083              		.loc 1 194 52 view .LVU853
 3084 0d30 F2A6D5E1 		ldrsh	r10, [r5, #98]	@ _26, g_armwave_state.ch1_color.g
 3085              	@ armwave.c:195:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 195:armwave.c     **** 
 3086              		.loc 1 195 52 view .LVU854
 3087 0d34 F446D5E1 		ldrsh	r4, [r5, #100]	@ _30, g_armwave_state.ch1_color.b
 3088              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 3089              		.loc 1 217 57 view .LVU855
 3090 0d38 076AD5ED 		vldr.32	s13, [r5, #28]	@ _52, g_armwave_state.vscale_frac
 3091              	@ armwave.c:181:     for(n = 0; n < npix; n += 4) {
 181:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 3092              		.loc 1 181 11 view .LVU856
 3093 0d3c 00C0A0E3 		mov	ip, #0	@ n,
 3094              	.LVL235:
 3095              	.L195:
 185:armwave.c     **** 
 3096              		.loc 1 185 9 is_stmt 1 view .LVU857
 3097              	@ armwave.c:185:         wave_word = *base_32ptr++;
 185:armwave.c     **** 
 3098              		.loc 1 185 19 is_stmt 0 view .LVU858
 3099 0d40 040099E4 		ldr	r0, [r9], #4	@ wave_word, MEM[base: base_32ptr_11, offset: 4294967292B]
 3100              	.LVL236:
 187:armwave.c     ****             for(w = 0; w < 4; w++) {
 3101              		.loc 1 187 9 is_stmt 1 view .LVU859
 3102              	@ armwave.c:187:         if(COND_UNLIKELY(wave_word != 0)) {
 187:armwave.c     ****             for(w = 0; w < 4; w++) {
 3103              		.loc 1 187 11 is_stmt 0 view .LVU860
 3104 0d44 000050E3 		cmp	r0, #0	@ wave_word,
 3105 0d48 0400001A 		bne	.L204		@,
 3106 0d4c 04C08CE2 		add	ip, ip, #4	@ n, n,
 3107              	.L191:
 3108              	.LVL237:
 3109              	@ armwave.c:181:     for(n = 0; n < npix; n += 4) {
 181:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 3110              		.loc 1 181 5 view .LVU861
 3111 0d50 0C0057E1 		cmp	r7, ip	@ npix, n
 3112 0d54 F9FFFFCA 		bgt	.L195		@,
 3113              	.LVL238:
 3114              	.L188:
 181:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 3115              		.loc 1 181 5 view .LVU862
 3116              	.LBE41:
 3117              	.LBE43:
 3118              	@ armwave.c:458: }
 458:armwave.c     **** }
 3119              		.loc 1 458 1 view .LVU863
 3120 0d58 0CD08DE2 		add	sp, sp, #12	@,,
 3121              		.cfi_remember_state
 3122              		.cfi_def_cfa_offset 36
 3123              		@ sp needed	@
 3124 0d5c F08FBDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}	@
 3125              	.LVL239:
 3126              	.L204:
 3127              		.cfi_restore_state
 3128              	.LBB44:
 3129              	.LBB42:
 3130              	@ armwave.c:192:                 if(value != 0) {
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 3131              		.loc 1 192 19 view .LVU864
 3132 0d60 FF1010E2 		ands	r1, r0, #255	@ _22, wave_word,
 3133              	@ armwave.c:187:         if(COND_UNLIKELY(wave_word != 0)) {
 187:armwave.c     ****             for(w = 0; w < 4; w++) {
 3134              		.loc 1 187 11 view .LVU865
 3135 0d64 0C60A0E1 		mov	r6, ip	@ ivtmp.137, n
 3136              	.LVL240:
 189:armwave.c     ****                 wave_word >>= 8;
 3137              		.loc 1 189 17 is_stmt 1 view .LVU866
 190:armwave.c     **** 
 3138              		.loc 1 190 17 view .LVU867
 3139              	@ armwave.c:190:                 wave_word >>= 8;
 190:armwave.c     **** 
 3140              		.loc 1 190 27 is_stmt 0 view .LVU868
 3141 0d68 2004A0E1 		lsr	r0, r0, #8	@ wave_word, wave_word,
 3142              	.LVL241:
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 3143              		.loc 1 192 17 is_stmt 1 view .LVU869
 3144 0d6c 04C08CE2 		add	ip, ip, #4	@ n, ivtmp.137,
 3145              	@ armwave.c:192:                 if(value != 0) {
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 3146              		.loc 1 192 19 is_stmt 0 view .LVU870
 3147 0d70 0500001A 		bne	.L208		@,
 3148              	.LVL242:
 3149              	.L192:
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 3150              		.loc 1 192 19 view .LVU871
 3151 0d74 016086E2 		add	r6, r6, #1	@ ivtmp.137, ivtmp.137,
 3152              	@ armwave.c:188:             for(w = 0; w < 4; w++) {
 188:armwave.c     ****                 value = wave_word & 0xff;
 3153              		.loc 1 188 13 view .LVU872
 3154 0d78 06005CE1 		cmp	ip, r6	@ n, ivtmp.137
 3155 0d7c F3FFFF0A 		beq	.L191		@,
 189:armwave.c     ****                 wave_word >>= 8;
 3156              		.loc 1 189 17 is_stmt 1 view .LVU873
 3157              	.LVL243:
 190:armwave.c     **** 
 3158              		.loc 1 190 17 view .LVU874
 3159              	@ armwave.c:192:                 if(value != 0) {
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 3160              		.loc 1 192 19 is_stmt 0 view .LVU875
 3161 0d80 FF1010E2 		ands	r1, r0, #255	@ _22, wave_word,
 3162              	@ armwave.c:190:                 wave_word >>= 8;
 190:armwave.c     **** 
 3163              		.loc 1 190 27 view .LVU876
 3164 0d84 2004A0E1 		lsr	r0, r0, #8	@ wave_word, wave_word,
 3165              	.LVL244:
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 3166              		.loc 1 192 17 is_stmt 1 view .LVU877
 3167              	@ armwave.c:192:                 if(value != 0) {
 192:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 3168              		.loc 1 192 19 is_stmt 0 view .LVU878
 3169 0d88 F9FFFF0A 		beq	.L192		@,
 3170              	.L208:
 193:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 3171              		.loc 1 193 21 is_stmt 1 view .LVU879
 3172              	.LVL245:
 194:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 3173              		.loc 1 194 21 view .LVU880
 195:armwave.c     **** 
 3174              		.loc 1 195 21 view .LVU881
 197:armwave.c     ****                     g = MIN(gg, 255);
 3175              		.loc 1 197 21 view .LVU882
 198:armwave.c     ****                     b = MIN(bb, 255);
 3176              		.loc 1 198 21 view .LVU883
 199:armwave.c     **** 
 3177              		.loc 1 199 21 view .LVU884
 202:armwave.c     **** 
 3178              		.loc 1 202 21 view .LVU885
 3179              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 3180              		.loc 1 217 32 is_stmt 0 view .LVU886
 3181 0d8c 7630EFE6 		uxtb	r3, r6	@ _50, ivtmp.137
 3182              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 3183              		.loc 1 218 41 view .LVU887
 3184 0d90 012083E2 		add	r2, r3, #1	@ tmp199, _50,
 3185              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 3186              		.loc 1 217 40 view .LVU888
 3187 0d94 903A07EE 		vmov	s15, r3	@ int	@ _50, _50
 3188              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 3189              		.loc 1 218 41 view .LVU889
 3190 0d98 102A07EE 		vmov	s14, r2	@ int	@ tmp199, tmp199
 3191              	@ armwave.c:195:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 195:armwave.c     **** 
 3192              		.loc 1 195 55 view .LVU890
 3193 0d9c 940103E0 		mul	r3, r4, r1	@ tmp184, _30, _22
 3194              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 3195              		.loc 1 217 40 view .LVU891
 3196 0da0 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp197, _50
 3197              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 3198              		.loc 1 218 46 view .LVU892
 3199 0da4 C77AB8EE 		vcvt.f32.s32	s14, s14	@ tmp200, tmp199
 3200              	@ armwave.c:194:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 194:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 3201              		.loc 1 194 55 view .LVU893
 3202 0da8 9A0102E0 		mul	r2, r10, r1	@ tmp188, _26, _22
 3203              	@ armwave.c:195:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 195:armwave.c     **** 
 3204              		.loc 1 195 24 view .LVU894
 3205 0dac 4334A0E1 		asr	r3, r3, #8	@ bb, tmp184,
 3206              	.LVL246:
 3207              	@ armwave.c:199:                     b = MIN(bb, 255);
 199:armwave.c     **** 
 3208              		.loc 1 199 25 view .LVU895
 3209 0db0 FF0053E3 		cmp	r3, #255	@ bb,
 3210              	@ armwave.c:194:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 194:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 3211              		.loc 1 194 24 view .LVU896
 3212 0db4 4224A0E1 		asr	r2, r2, #8	@ gg, tmp188,
 3213              	.LVL247:
 3214              	@ armwave.c:199:                     b = MIN(bb, 255);
 199:armwave.c     **** 
 3215              		.loc 1 199 25 view .LVU897
 3216 0db8 FF30A0A3 		movge	r3, #255	@ bb,
 3217              	.LVL248:
 3218              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 3219              		.loc 1 217 40 view .LVU898
 3220 0dbc A67A67EE 		vmul.f32	s15, s15, s13	@ tmp198, tmp197, _52
 3221              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 3222              		.loc 1 218 46 view .LVU899
 3223 0dc0 267A27EE 		vmul.f32	s14, s14, s13	@ tmp201, tmp200, _52
 3224              	@ armwave.c:198:                     g = MIN(gg, 255);
 198:armwave.c     ****                     b = MIN(bb, 255);
 3225              		.loc 1 198 25 view .LVU900
 3226 0dc4 FF0052E3 		cmp	r2, #255	@ gg,
 3227 0dc8 FF20A0A3 		movge	r2, #255	@ gg,
 3228              	.LVL249:
 3229              	@ armwave.c:193:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 193:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 3230              		.loc 1 193 55 view .LVU901
 3231 0dcc 910B01E0 		mul	r1, r1, fp	@ tmp194, _22, _20
 3232              	.LVL250:
 3233              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 3234              		.loc 1 202 56 view .LVU902
 3235 0dd0 0224A0E1 		lsl	r2, r2, #8	@ tmp189, gg,
 3236              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 3237              		.loc 1 202 44 view .LVU903
 3238 0dd4 0338A0E1 		lsl	r3, r3, #16	@ tmp185, bb,
 3239              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 3240              		.loc 1 217 24 view .LVU904
 3241 0dd8 E77AFCEE 		vcvt.u32.f32	s15, s15	@ yy, tmp198
 3242              	@ armwave.c:193:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 193:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 3243              		.loc 1 193 24 view .LVU905
 3244 0ddc 4114A0E1 		asr	r1, r1, #8	@ rr, tmp194,
 3245              	.LVL251:
 3246              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 3247              		.loc 1 202 56 view .LVU906
 3248 0de0 7220FFE6 		uxth	r2, r2	@ tmp190, tmp189
 3249              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 3250              		.loc 1 202 44 view .LVU907
 3251 0de4 FF3803E2 		and	r3, r3, #16711680	@ tmp186, tmp185,
 3252              	@ armwave.c:197:                     r = MIN(rr, 255);
 197:armwave.c     ****                     g = MIN(gg, 255);
 3253              		.loc 1 197 25 view .LVU908
 3254 0de8 FF0051E3 		cmp	r1, #255	@ rr,
 3255              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 3256              		.loc 1 202 51 view .LVU909
 3257 0dec 023083E1 		orr	r3, r3, r2	@ tmp192, tmp186, tmp190
 3258              	@ armwave.c:197:                     r = MIN(rr, 255);
 197:armwave.c     ****                     g = MIN(gg, 255);
 3259              		.loc 1 197 25 view .LVU910
 3260 0df0 FF10A0A3 		movge	r1, #255	@ rr,
 3261              	.LVL252:
 3262              	@ armwave.c:217:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 3263              		.loc 1 217 24 view .LVU911
 3264 0df4 90EA17EE 		vmov	lr, s15	@ int	@ yy, yy
 3265              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 3266              		.loc 1 218 24 view .LVU912
 3267 0df8 C77AFCEE 		vcvt.u32.f32	s15, s14	@ ye, tmp201
 3268              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 3269              		.loc 1 202 62 view .LVU913
 3270 0dfc 7110EFE6 		uxtb	r1, r1	@ rr, rr
 3271 0e00 013083E1 		orr	r3, r3, r1	@ tmp196, tmp192, rr
 3272              	@ armwave.c:202:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 202:armwave.c     **** 
 3273              		.loc 1 202 26 view .LVU914
 3274 0e04 FF3483E3 		orr	r3, r3, #-16777216	@ word, tmp196,
 3275              	.LVL253:
 216:armwave.c     ****                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 3276              		.loc 1 216 21 is_stmt 1 view .LVU915
 217:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 3277              		.loc 1 217 21 view .LVU916
 218:armwave.c     ****                     xx = (nsub >> 8);
 3278              		.loc 1 218 21 view .LVU917
 219:armwave.c     **** 
 3279              		.loc 1 219 21 view .LVU918
 3280              	@ armwave.c:219:                     xx = (nsub >> 8);
 219:armwave.c     **** 
 3281              		.loc 1 219 32 is_stmt 0 view .LVU919
 3282 0e08 4614A0E1 		asr	r1, r6, #8	@ xx, ivtmp.137,
 3283              	.LVL254:
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 3284              		.loc 1 221 21 is_stmt 1 view .LVU920
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 3285              		.loc 1 221 21 is_stmt 0 view .LVU921
 3286 0e0c 902A17EE 		vmov	r2, s15	@ int	@ ye,
 3287              	@ armwave.c:218:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 218:armwave.c     ****                     xx = (nsub >> 8);
 3288              		.loc 1 218 24 view .LVU922
 3289 0e10 007ACDED 		vstr.32	s15, [sp]	@ int	@ ye, %sfp
 3290              	.LVL255:
 3291              	@ armwave.c:221:                     for(y = yy; y < ye; y++) {
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 3292              		.loc 1 221 21 view .LVU923
 3293 0e14 02005EE1 		cmp	lr, r2	@ yy, ye
 3294 0e18 D5FFFF2A 		bcs	.L192		@,
 3295 0e1c 04008DE5 		str	r0, [sp, #4]	@ wave_word, %sfp
 3296              	.LVL256:
 3297              	.L193:
 222:armwave.c     ****                         *(out_buffer_base + offset) = word;
 3298              		.loc 1 222 25 is_stmt 1 view .LVU924
 223:armwave.c     ****                     }
 3299              		.loc 1 223 25 view .LVU925
 3300              	@ armwave.c:222:                         offset = (xx + (y * g_armwave_state.target_width)); 
 222:armwave.c     ****                         *(out_buffer_base + offset) = word;
 3301              		.loc 1 222 43 is_stmt 0 view .LVU926
 3302 0e20 4C2095E5 		ldr	r2, [r5, #76]	@ g_armwave_state.target_width, g_armwave_state.target_width
 3303              	@ armwave.c:221:                     for(y = yy; y < ye; y++) {
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 3304              		.loc 1 221 21 view .LVU927
 3305 0e24 00009DE5 		ldr	r0, [sp]	@ ye, %sfp
 3306              	@ armwave.c:223:                         *(out_buffer_base + offset) = word;
 223:armwave.c     ****                     }
 3307              		.loc 1 223 43 view .LVU928
 3308 0e28 921E22E0 		mla	r2, r2, lr, r1	@ tmp205, g_armwave_state.target_width, yy, xx
 3309              	.LVL257:
 3310              	@ armwave.c:221:                     for(y = yy; y < ye; y++) {
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 3311              		.loc 1 221 42 view .LVU929
 3312 0e2c 01E08EE2 		add	lr, lr, #1	@ yy, yy,
 3313              	.LVL258:
 3314              	@ armwave.c:221:                     for(y = yy; y < ye; y++) {
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 3315              		.loc 1 221 21 view .LVU930
 3316 0e30 0E0050E1 		cmp	r0, lr	@ ye, yy
 3317              	@ armwave.c:223:                         *(out_buffer_base + offset) = word;
 223:armwave.c     ****                     }
 3318              		.loc 1 223 53 view .LVU931
 3319 0e34 023188E7 		str	r3, [r8, r2, lsl #2]	@ word, *_66
 3320              	@ armwave.c:221:                     for(y = yy; y < ye; y++) {
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 3321              		.loc 1 221 21 view .LVU932
 3322 0e38 F8FFFF1A 		bne	.L193		@,
 221:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 3323              		.loc 1 221 21 view .LVU933
 3324 0e3c 04009DE5 		ldr	r0, [sp, #4]	@ wave_word, %sfp
 3325 0e40 CBFFFFEA 		b	.L192		@
 3326              	.LVL259:
 3327              	.L207:
 176:armwave.c     **** 
 3328              		.loc 1 176 5 is_stmt 1 view .LVU934
 3329 0e44 10309FE5 		ldr	r3, .L209+4	@,
 3330 0e48 B020A0E3 		mov	r2, #176	@,
 3331 0e4c 0C109FE5 		ldr	r1, .L209+8	@,
 3332 0e50 0C009FE5 		ldr	r0, .L209+12	@,
 3333              	.LVL260:
 176:armwave.c     **** 
 3334              		.loc 1 176 5 is_stmt 0 view .LVU935
 3335 0e54 FEFFFFEB 		bl	__assert_fail		@
 3336              	.LVL261:
 3337              	.L210:
 3338              		.align	2
 3339              	.L209:
 3340 0e58 00000000 		.word	g_armwave_state
 3341 0e5c 18000000 		.word	.LANCHOR0+24
 3342 0e60 20000000 		.word	.LC2
 3343 0e64 2C000000 		.word	.LC3
 3344              	.LBE42:
 3345              	.LBE44:
 3346              		.cfi_endproc
 3347              	.LFE73:
 3349              		.align	2
 3350              		.global	armwave_test_buffer_alloc
 3351              		.syntax unified
 3352              		.arm
 3353              		.fpu vfp
 3355              	armwave_test_buffer_alloc:
 3356              	.LFB74:
 459:armwave.c     **** 
 460:armwave.c     **** /*
 461:armwave.c     ****  * Allocate a test buffer, freeing any existing buffer.
 462:armwave.c     ****  */
 463:armwave.c     **** void armwave_test_buffer_alloc()
 464:armwave.c     **** {
 3357              		.loc 1 464 1 is_stmt 1 view -0
 3358              		.cfi_startproc
 3359              		@ args = 0, pretend = 0, frame = 0
 3360              		@ frame_needed = 0, uses_anonymous_args = 0
 465:armwave.c     ****     if(g_armwave_state.test_wave_buffer != NULL) {
 3361              		.loc 1 465 5 view .LVU937
 3362              	@ armwave.c:464: {
 464:armwave.c     ****     if(g_armwave_state.test_wave_buffer != NULL) {
 3363              		.loc 1 464 1 is_stmt 0 view .LVU938
 3364 0e68 70402DE9 		push	{r4, r5, r6, lr}	@
 3365              		.cfi_def_cfa_offset 16
 3366              		.cfi_offset 4, -16
 3367              		.cfi_offset 5, -12
 3368              		.cfi_offset 6, -8
 3369              		.cfi_offset 14, -4
 3370              	@ armwave.c:465:     if(g_armwave_state.test_wave_buffer != NULL) {
 3371              		.loc 1 465 23 view .LVU939
 3372 0e6c 40409FE5 		ldr	r4, .L218	@ tmp123,
 3373 0e70 180094E5 		ldr	r0, [r4, #24]	@ _1, g_armwave_state.test_wave_buffer
 3374              	@ armwave.c:465:     if(g_armwave_state.test_wave_buffer != NULL) {
 3375              		.loc 1 465 7 view .LVU940
 3376 0e74 000050E3 		cmp	r0, #0	@ _1,
 3377 0e78 0000000A 		beq	.L212		@,
 466:armwave.c     ****         free(g_armwave_state.test_wave_buffer);
 3378              		.loc 1 466 9 is_stmt 1 view .LVU941
 3379 0e7c FEFFFFEB 		bl	free		@
 3380              	.LVL262:
 3381              	.L212:
 467:armwave.c     ****     }
 468:armwave.c     **** 
 469:armwave.c     ****     //printf("armwave_test_buffer_alloc: length=%d max=%d\n", g_armwave_state.wave_length, g_armwav
 470:armwave.c     **** 
 471:armwave.c     ****     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armwave_state.waves_m
 3382              		.loc 1 471 5 view .LVU942
 3383              	@ armwave.c:471:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 3384              		.loc 1 471 40 is_stmt 0 view .LVU943
 3385 0e80 403094E5 		ldr	r3, [r4, #64]	@ g_armwave_state.wave_length, g_armwave_state.wave_length
 3386 0e84 305094E5 		ldr	r5, [r4, #48]	@ g_armwave_state.waves_max, g_armwave_state.waves_max
 3387 0e88 0110A0E3 		mov	r1, #1	@,
 3388 0e8c 950305E0 		mul	r5, r5, r3	@ _4, g_armwave_state.waves_max, g_armwave_state.wave_length
 3389 0e90 0500A0E1 		mov	r0, r5	@, _4
 3390 0e94 FEFFFFEB 		bl	calloc		@
 3391              	.LVL263:
 3392              	@ armwave.c:473:     if(g_armwave_state.test_wave_buffer == NULL) {
 472:armwave.c     **** 
 473:armwave.c     ****     if(g_armwave_state.test_wave_buffer == NULL) {
 3393              		.loc 1 473 7 view .LVU944
 3394 0e98 000050E3 		cmp	r0, #0	@ tmp120,
 3395              	@ armwave.c:471:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 471:armwave.c     **** 
 3396              		.loc 1 471 38 view .LVU945
 3397 0e9c 180084E5 		str	r0, [r4, #24]	@ tmp120, g_armwave_state.test_wave_buffer
 3398              		.loc 1 473 5 is_stmt 1 view .LVU946
 3399              	@ armwave.c:473:     if(g_armwave_state.test_wave_buffer == NULL) {
 3400              		.loc 1 473 7 is_stmt 0 view .LVU947
 3401 0ea0 7080BD18 		popne	{r4, r5, r6, pc}	@
 474:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes)\n", g_arm
 3402              		.loc 1 474 9 is_stmt 1 view .LVU948
 3403 0ea4 0510A0E1 		mov	r1, r5	@, _4
 3404 0ea8 08009FE5 		ldr	r0, .L218+4	@,
 3405              	@ armwave.c:477: }
 475:armwave.c     ****         return;
 476:armwave.c     ****     }
 477:armwave.c     **** }
 3406              		.loc 1 477 1 is_stmt 0 view .LVU949
 3407 0eac 7040BDE8 		pop	{r4, r5, r6, lr}	@
 3408              		.cfi_restore 14
 3409              		.cfi_restore 6
 3410              		.cfi_restore 5
 3411              		.cfi_restore 4
 3412              		.cfi_def_cfa_offset 0
 3413              	@ armwave.c:474:         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d
 474:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes)\n", g_arm
 3414              		.loc 1 474 9 view .LVU950
 3415 0eb0 FEFFFFEA 		b	printf		@
 3416              	.LVL264:
 3417              	.L219:
 3418              		.align	2
 3419              	.L218:
 3420 0eb4 00000000 		.word	g_armwave_state
 3421 0eb8 60010000 		.word	.LC17
 3422              		.cfi_endproc
 3423              	.LFE74:
 3425              		.align	2
 3426              		.global	armwave_fill_pixbuf_into_pybuffer
 3427              		.syntax unified
 3428              		.arm
 3429              		.fpu vfp
 3431              	armwave_fill_pixbuf_into_pybuffer:
 3432              	.LVL265:
 3433              	.LFB75:
 478:armwave.c     **** 
 479:armwave.c     **** /*
 480:armwave.c     ****  * Fill a pixbuf PyBuffer with a rendered waveform.
 481:armwave.c     ****  */
 482:armwave.c     **** PyObject *armwave_fill_pixbuf_into_pybuffer(PyObject *buf_obj)
 483:armwave.c     **** {
 3434              		.loc 1 483 1 is_stmt 1 view -0
 3435              		.cfi_startproc
 3436              		@ args = 0, pretend = 0, frame = 48
 3437              		@ frame_needed = 0, uses_anonymous_args = 0
 484:armwave.c     ****     Py_buffer buffer;
 3438              		.loc 1 484 5 view .LVU952
 485:armwave.c     ****     int ret;
 3439              		.loc 1 485 5 view .LVU953
 486:armwave.c     **** 
 487:armwave.c     ****     //printf("armwave_fill_pixbuf_into_pybuffer: start\n");
 488:armwave.c     **** 
 489:armwave.c     ****     ret = PyObject_GetBuffer(buf_obj, &buffer, PyBUF_SIMPLE | PyBUF_WRITABLE);
 3440              		.loc 1 489 5 view .LVU954
 3441              	@ armwave.c:483: {
 483:armwave.c     ****     Py_buffer buffer;
 3442              		.loc 1 483 1 is_stmt 0 view .LVU955
 3443 0ebc 04E02DE5 		str	lr, [sp, #-4]!	@,
 3444              		.cfi_def_cfa_offset 4
 3445              		.cfi_offset 14, -4
 3446 0ec0 34D04DE2 		sub	sp, sp, #52	@,,
 3447              		.cfi_def_cfa_offset 56
 3448              	@ armwave.c:489:     ret = PyObject_GetBuffer(buf_obj, &buffer, PyBUF_SIMPLE | PyBUF_WRITABLE);
 3449              		.loc 1 489 11 view .LVU956
 3450 0ec4 04108DE2 		add	r1, sp, #4	@ tmp131,,
 3451 0ec8 0120A0E3 		mov	r2, #1	@,
 3452 0ecc FEFFFFEB 		bl	PyObject_GetBuffer		@
 3453              	.LVL266:
 490:armwave.c     **** 
 491:armwave.c     ****     if(ret != 0) {
 3454              		.loc 1 491 5 is_stmt 1 view .LVU957
 3455              	@ armwave.c:491:     if(ret != 0) {
 3456              		.loc 1 491 7 is_stmt 0 view .LVU958
 3457 0ed0 000050E3 		cmp	r0, #0	@,
 3458 0ed4 0A00001A 		bne	.L224		@,
 492:armwave.c     ****         printf("armwave_fill_pixbuf_into_pybuffer: PyObject_GetBuffer() failed, returning PyFalse\n
 493:armwave.c     ****         Py_RETURN_FALSE;
 494:armwave.c     ****     }
 495:armwave.c     **** 
 496:armwave.c     ****     //printf("PyObject_GetBuffer did not trigger assert: buffer->buf=0x%08x, buffer->obj=0x%08x, bu
 497:armwave.c     **** 
 498:armwave.c     ****     armwave_fill_pixbuf_scaled(buffer.buf);
 3459              		.loc 1 498 5 is_stmt 1 view .LVU959
 3460 0ed8 04009DE5 		ldr	r0, [sp, #4]	@, buffer.buf
 3461              	.LVL267:
 3462              		.loc 1 498 5 is_stmt 0 view .LVU960
 3463 0edc FEFFFFEB 		bl	armwave_fill_pixbuf_scaled		@
 3464              	.LVL268:
 499:armwave.c     ****     //printf("armwave_fill_pixbuf_into_pybuffer: buffer fill done\n");
 500:armwave.c     **** 
 501:armwave.c     ****     PyBuffer_Release(&buffer);
 3465              		.loc 1 501 5 is_stmt 1 view .LVU961
 3466 0ee0 04008DE2 		add	r0, sp, #4	@ tmp132,,
 3467 0ee4 FEFFFFEB 		bl	PyBuffer_Release		@
 3468              	.LVL269:
 502:armwave.c     ****     //printf("armwave_fill_pixbuf_into_pybuffer: done\n");
 503:armwave.c     **** 
 504:armwave.c     ****     Py_RETURN_TRUE;
 3469              		.loc 1 504 5 view .LVU962
 3470              	.LBB45:
 3471              	.LBI45:
 3472              		.file 2 "/usr/local/include/python3.8/object.h"
   1:/usr/local/include/python3.8/object.h **** #ifndef Py_OBJECT_H
   2:/usr/local/include/python3.8/object.h **** #define Py_OBJECT_H
   3:/usr/local/include/python3.8/object.h **** 
   4:/usr/local/include/python3.8/object.h **** #include "pymem.h"   /* _Py_tracemalloc_config */
   5:/usr/local/include/python3.8/object.h **** 
   6:/usr/local/include/python3.8/object.h **** #ifdef __cplusplus
   7:/usr/local/include/python3.8/object.h **** extern "C" {
   8:/usr/local/include/python3.8/object.h **** #endif
   9:/usr/local/include/python3.8/object.h **** 
  10:/usr/local/include/python3.8/object.h **** 
  11:/usr/local/include/python3.8/object.h **** /* Object and type object interface */
  12:/usr/local/include/python3.8/object.h **** 
  13:/usr/local/include/python3.8/object.h **** /*
  14:/usr/local/include/python3.8/object.h **** Objects are structures allocated on the heap.  Special rules apply to
  15:/usr/local/include/python3.8/object.h **** the use of objects to ensure they are properly garbage-collected.
  16:/usr/local/include/python3.8/object.h **** Objects are never allocated statically or on the stack; they must be
  17:/usr/local/include/python3.8/object.h **** accessed through special macros and functions only.  (Type objects are
  18:/usr/local/include/python3.8/object.h **** exceptions to the first rule; the standard types are represented by
  19:/usr/local/include/python3.8/object.h **** statically initialized type objects, although work on type/class unification
  20:/usr/local/include/python3.8/object.h **** for Python 2.2 made it possible to have heap-allocated type objects too).
  21:/usr/local/include/python3.8/object.h **** 
  22:/usr/local/include/python3.8/object.h **** An object has a 'reference count' that is increased or decreased when a
  23:/usr/local/include/python3.8/object.h **** pointer to the object is copied or deleted; when the reference count
  24:/usr/local/include/python3.8/object.h **** reaches zero there are no references to the object left and it can be
  25:/usr/local/include/python3.8/object.h **** removed from the heap.
  26:/usr/local/include/python3.8/object.h **** 
  27:/usr/local/include/python3.8/object.h **** An object has a 'type' that determines what it represents and what kind
  28:/usr/local/include/python3.8/object.h **** of data it contains.  An object's type is fixed when it is created.
  29:/usr/local/include/python3.8/object.h **** Types themselves are represented as objects; an object contains a
  30:/usr/local/include/python3.8/object.h **** pointer to the corresponding type object.  The type itself has a type
  31:/usr/local/include/python3.8/object.h **** pointer pointing to the object representing the type 'type', which
  32:/usr/local/include/python3.8/object.h **** contains a pointer to itself!.
  33:/usr/local/include/python3.8/object.h **** 
  34:/usr/local/include/python3.8/object.h **** Objects do not float around in memory; once allocated an object keeps
  35:/usr/local/include/python3.8/object.h **** the same size and address.  Objects that must hold variable-size data
  36:/usr/local/include/python3.8/object.h **** can contain pointers to variable-size parts of the object.  Not all
  37:/usr/local/include/python3.8/object.h **** objects of the same type have the same size; but the size cannot change
  38:/usr/local/include/python3.8/object.h **** after allocation.  (These restrictions are made so a reference to an
  39:/usr/local/include/python3.8/object.h **** object can be simply a pointer -- moving an object would require
  40:/usr/local/include/python3.8/object.h **** updating all the pointers, and changing an object's size would require
  41:/usr/local/include/python3.8/object.h **** moving it if there was another object right next to it.)
  42:/usr/local/include/python3.8/object.h **** 
  43:/usr/local/include/python3.8/object.h **** Objects are always accessed through pointers of the type 'PyObject *'.
  44:/usr/local/include/python3.8/object.h **** The type 'PyObject' is a structure that only contains the reference count
  45:/usr/local/include/python3.8/object.h **** and the type pointer.  The actual memory allocated for an object
  46:/usr/local/include/python3.8/object.h **** contains other data that can only be accessed after casting the pointer
  47:/usr/local/include/python3.8/object.h **** to a pointer to a longer structure type.  This longer type must start
  48:/usr/local/include/python3.8/object.h **** with the reference count and type fields; the macro PyObject_HEAD should be
  49:/usr/local/include/python3.8/object.h **** used for this (to accommodate for future changes).  The implementation
  50:/usr/local/include/python3.8/object.h **** of a particular object type can cast the object pointer to the proper
  51:/usr/local/include/python3.8/object.h **** type and back.
  52:/usr/local/include/python3.8/object.h **** 
  53:/usr/local/include/python3.8/object.h **** A standard interface exists for objects that contain an array of items
  54:/usr/local/include/python3.8/object.h **** whose size is determined when the object is allocated.
  55:/usr/local/include/python3.8/object.h **** */
  56:/usr/local/include/python3.8/object.h **** 
  57:/usr/local/include/python3.8/object.h **** /* Py_DEBUG implies Py_REF_DEBUG. */
  58:/usr/local/include/python3.8/object.h **** #if defined(Py_DEBUG) && !defined(Py_REF_DEBUG)
  59:/usr/local/include/python3.8/object.h **** #define Py_REF_DEBUG
  60:/usr/local/include/python3.8/object.h **** #endif
  61:/usr/local/include/python3.8/object.h **** 
  62:/usr/local/include/python3.8/object.h **** #if defined(Py_LIMITED_API) && defined(Py_REF_DEBUG)
  63:/usr/local/include/python3.8/object.h **** #error Py_LIMITED_API is incompatible with Py_DEBUG, Py_TRACE_REFS, and Py_REF_DEBUG
  64:/usr/local/include/python3.8/object.h **** #endif
  65:/usr/local/include/python3.8/object.h **** 
  66:/usr/local/include/python3.8/object.h **** 
  67:/usr/local/include/python3.8/object.h **** #ifdef Py_TRACE_REFS
  68:/usr/local/include/python3.8/object.h **** /* Define pointers to support a doubly-linked list of all live heap objects. */
  69:/usr/local/include/python3.8/object.h **** #define _PyObject_HEAD_EXTRA            \
  70:/usr/local/include/python3.8/object.h ****     struct _object *_ob_next;           \
  71:/usr/local/include/python3.8/object.h ****     struct _object *_ob_prev;
  72:/usr/local/include/python3.8/object.h **** 
  73:/usr/local/include/python3.8/object.h **** #define _PyObject_EXTRA_INIT 0, 0,
  74:/usr/local/include/python3.8/object.h **** 
  75:/usr/local/include/python3.8/object.h **** #else
  76:/usr/local/include/python3.8/object.h **** #define _PyObject_HEAD_EXTRA
  77:/usr/local/include/python3.8/object.h **** #define _PyObject_EXTRA_INIT
  78:/usr/local/include/python3.8/object.h **** #endif
  79:/usr/local/include/python3.8/object.h **** 
  80:/usr/local/include/python3.8/object.h **** /* PyObject_HEAD defines the initial segment of every PyObject. */
  81:/usr/local/include/python3.8/object.h **** #define PyObject_HEAD                   PyObject ob_base;
  82:/usr/local/include/python3.8/object.h **** 
  83:/usr/local/include/python3.8/object.h **** #define PyObject_HEAD_INIT(type)        \
  84:/usr/local/include/python3.8/object.h ****     { _PyObject_EXTRA_INIT              \
  85:/usr/local/include/python3.8/object.h ****     1, type },
  86:/usr/local/include/python3.8/object.h **** 
  87:/usr/local/include/python3.8/object.h **** #define PyVarObject_HEAD_INIT(type, size)       \
  88:/usr/local/include/python3.8/object.h ****     { PyObject_HEAD_INIT(type) size },
  89:/usr/local/include/python3.8/object.h **** 
  90:/usr/local/include/python3.8/object.h **** /* PyObject_VAR_HEAD defines the initial segment of all variable-size
  91:/usr/local/include/python3.8/object.h ****  * container objects.  These end with a declaration of an array with 1
  92:/usr/local/include/python3.8/object.h ****  * element, but enough space is malloc'ed so that the array actually
  93:/usr/local/include/python3.8/object.h ****  * has room for ob_size elements.  Note that ob_size is an element count,
  94:/usr/local/include/python3.8/object.h ****  * not necessarily a byte count.
  95:/usr/local/include/python3.8/object.h ****  */
  96:/usr/local/include/python3.8/object.h **** #define PyObject_VAR_HEAD      PyVarObject ob_base;
  97:/usr/local/include/python3.8/object.h **** #define Py_INVALID_SIZE (Py_ssize_t)-1
  98:/usr/local/include/python3.8/object.h **** 
  99:/usr/local/include/python3.8/object.h **** /* Nothing is actually declared to be a PyObject, but every pointer to
 100:/usr/local/include/python3.8/object.h ****  * a Python object can be cast to a PyObject*.  This is inheritance built
 101:/usr/local/include/python3.8/object.h ****  * by hand.  Similarly every pointer to a variable-size Python object can,
 102:/usr/local/include/python3.8/object.h ****  * in addition, be cast to PyVarObject*.
 103:/usr/local/include/python3.8/object.h ****  */
 104:/usr/local/include/python3.8/object.h **** typedef struct _object {
 105:/usr/local/include/python3.8/object.h ****     _PyObject_HEAD_EXTRA
 106:/usr/local/include/python3.8/object.h ****     Py_ssize_t ob_refcnt;
 107:/usr/local/include/python3.8/object.h ****     struct _typeobject *ob_type;
 108:/usr/local/include/python3.8/object.h **** } PyObject;
 109:/usr/local/include/python3.8/object.h **** 
 110:/usr/local/include/python3.8/object.h **** /* Cast argument to PyObject* type. */
 111:/usr/local/include/python3.8/object.h **** #define _PyObject_CAST(op) ((PyObject*)(op))
 112:/usr/local/include/python3.8/object.h **** 
 113:/usr/local/include/python3.8/object.h **** typedef struct {
 114:/usr/local/include/python3.8/object.h ****     PyObject ob_base;
 115:/usr/local/include/python3.8/object.h ****     Py_ssize_t ob_size; /* Number of items in variable part */
 116:/usr/local/include/python3.8/object.h **** } PyVarObject;
 117:/usr/local/include/python3.8/object.h **** 
 118:/usr/local/include/python3.8/object.h **** /* Cast argument to PyVarObject* type. */
 119:/usr/local/include/python3.8/object.h **** #define _PyVarObject_CAST(op) ((PyVarObject*)(op))
 120:/usr/local/include/python3.8/object.h **** 
 121:/usr/local/include/python3.8/object.h **** #define Py_REFCNT(ob)           (_PyObject_CAST(ob)->ob_refcnt)
 122:/usr/local/include/python3.8/object.h **** #define Py_TYPE(ob)             (_PyObject_CAST(ob)->ob_type)
 123:/usr/local/include/python3.8/object.h **** #define Py_SIZE(ob)             (_PyVarObject_CAST(ob)->ob_size)
 124:/usr/local/include/python3.8/object.h **** 
 125:/usr/local/include/python3.8/object.h **** /*
 126:/usr/local/include/python3.8/object.h **** Type objects contain a string containing the type name (to help somewhat
 127:/usr/local/include/python3.8/object.h **** in debugging), the allocation parameters (see PyObject_New() and
 128:/usr/local/include/python3.8/object.h **** PyObject_NewVar()),
 129:/usr/local/include/python3.8/object.h **** and methods for accessing objects of the type.  Methods are optional, a
 130:/usr/local/include/python3.8/object.h **** nil pointer meaning that particular kind of access is not available for
 131:/usr/local/include/python3.8/object.h **** this type.  The Py_DECREF() macro uses the tp_dealloc method without
 132:/usr/local/include/python3.8/object.h **** checking for a nil pointer; it should always be implemented except if
 133:/usr/local/include/python3.8/object.h **** the implementation can guarantee that the reference count will never
 134:/usr/local/include/python3.8/object.h **** reach zero (e.g., for statically allocated type objects).
 135:/usr/local/include/python3.8/object.h **** 
 136:/usr/local/include/python3.8/object.h **** NB: the methods for certain type groups are now contained in separate
 137:/usr/local/include/python3.8/object.h **** method blocks.
 138:/usr/local/include/python3.8/object.h **** */
 139:/usr/local/include/python3.8/object.h **** 
 140:/usr/local/include/python3.8/object.h **** typedef PyObject * (*unaryfunc)(PyObject *);
 141:/usr/local/include/python3.8/object.h **** typedef PyObject * (*binaryfunc)(PyObject *, PyObject *);
 142:/usr/local/include/python3.8/object.h **** typedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);
 143:/usr/local/include/python3.8/object.h **** typedef int (*inquiry)(PyObject *);
 144:/usr/local/include/python3.8/object.h **** typedef Py_ssize_t (*lenfunc)(PyObject *);
 145:/usr/local/include/python3.8/object.h **** typedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);
 146:/usr/local/include/python3.8/object.h **** typedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);
 147:/usr/local/include/python3.8/object.h **** typedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);
 148:/usr/local/include/python3.8/object.h **** typedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);
 149:/usr/local/include/python3.8/object.h **** typedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);
 150:/usr/local/include/python3.8/object.h **** 
 151:/usr/local/include/python3.8/object.h **** typedef int (*objobjproc)(PyObject *, PyObject *);
 152:/usr/local/include/python3.8/object.h **** typedef int (*visitproc)(PyObject *, void *);
 153:/usr/local/include/python3.8/object.h **** typedef int (*traverseproc)(PyObject *, visitproc, void *);
 154:/usr/local/include/python3.8/object.h **** 
 155:/usr/local/include/python3.8/object.h **** 
 156:/usr/local/include/python3.8/object.h **** typedef void (*freefunc)(void *);
 157:/usr/local/include/python3.8/object.h **** typedef void (*destructor)(PyObject *);
 158:/usr/local/include/python3.8/object.h **** typedef PyObject *(*getattrfunc)(PyObject *, char *);
 159:/usr/local/include/python3.8/object.h **** typedef PyObject *(*getattrofunc)(PyObject *, PyObject *);
 160:/usr/local/include/python3.8/object.h **** typedef int (*setattrfunc)(PyObject *, char *, PyObject *);
 161:/usr/local/include/python3.8/object.h **** typedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);
 162:/usr/local/include/python3.8/object.h **** typedef PyObject *(*reprfunc)(PyObject *);
 163:/usr/local/include/python3.8/object.h **** typedef Py_hash_t (*hashfunc)(PyObject *);
 164:/usr/local/include/python3.8/object.h **** typedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);
 165:/usr/local/include/python3.8/object.h **** typedef PyObject *(*getiterfunc) (PyObject *);
 166:/usr/local/include/python3.8/object.h **** typedef PyObject *(*iternextfunc) (PyObject *);
 167:/usr/local/include/python3.8/object.h **** typedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);
 168:/usr/local/include/python3.8/object.h **** typedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);
 169:/usr/local/include/python3.8/object.h **** typedef int (*initproc)(PyObject *, PyObject *, PyObject *);
 170:/usr/local/include/python3.8/object.h **** typedef PyObject *(*newfunc)(struct _typeobject *, PyObject *, PyObject *);
 171:/usr/local/include/python3.8/object.h **** typedef PyObject *(*allocfunc)(struct _typeobject *, Py_ssize_t);
 172:/usr/local/include/python3.8/object.h **** 
 173:/usr/local/include/python3.8/object.h **** #ifdef Py_LIMITED_API
 174:/usr/local/include/python3.8/object.h **** /* In Py_LIMITED_API, PyTypeObject is an opaque structure. */
 175:/usr/local/include/python3.8/object.h **** typedef struct _typeobject PyTypeObject;
 176:/usr/local/include/python3.8/object.h **** #else
 177:/usr/local/include/python3.8/object.h **** /* PyTypeObject is defined in cpython/object.h */
 178:/usr/local/include/python3.8/object.h **** #endif
 179:/usr/local/include/python3.8/object.h **** 
 180:/usr/local/include/python3.8/object.h **** typedef struct{
 181:/usr/local/include/python3.8/object.h ****     int slot;    /* slot id, see below */
 182:/usr/local/include/python3.8/object.h ****     void *pfunc; /* function pointer */
 183:/usr/local/include/python3.8/object.h **** } PyType_Slot;
 184:/usr/local/include/python3.8/object.h **** 
 185:/usr/local/include/python3.8/object.h **** typedef struct{
 186:/usr/local/include/python3.8/object.h ****     const char* name;
 187:/usr/local/include/python3.8/object.h ****     int basicsize;
 188:/usr/local/include/python3.8/object.h ****     int itemsize;
 189:/usr/local/include/python3.8/object.h ****     unsigned int flags;
 190:/usr/local/include/python3.8/object.h ****     PyType_Slot *slots; /* terminated by slot==0. */
 191:/usr/local/include/python3.8/object.h **** } PyType_Spec;
 192:/usr/local/include/python3.8/object.h **** 
 193:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);
 194:/usr/local/include/python3.8/object.h **** #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
 195:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);
 196:/usr/local/include/python3.8/object.h **** #endif
 197:/usr/local/include/python3.8/object.h **** #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
 198:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void*) PyType_GetSlot(struct _typeobject*, int);
 199:/usr/local/include/python3.8/object.h **** #endif
 200:/usr/local/include/python3.8/object.h **** 
 201:/usr/local/include/python3.8/object.h **** /* Generic type check */
 202:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyType_IsSubtype(struct _typeobject *, struct _typeobject *);
 203:/usr/local/include/python3.8/object.h **** #define PyObject_TypeCheck(ob, tp) \
 204:/usr/local/include/python3.8/object.h ****     (Py_TYPE(ob) == (tp) || PyType_IsSubtype(Py_TYPE(ob), (tp)))
 205:/usr/local/include/python3.8/object.h **** 
 206:/usr/local/include/python3.8/object.h **** PyAPI_DATA(struct _typeobject) PyType_Type; /* built-in 'type' */
 207:/usr/local/include/python3.8/object.h **** PyAPI_DATA(struct _typeobject) PyBaseObject_Type; /* built-in 'object' */
 208:/usr/local/include/python3.8/object.h **** PyAPI_DATA(struct _typeobject) PySuper_Type; /* built-in 'super' */
 209:/usr/local/include/python3.8/object.h **** 
 210:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(unsigned long) PyType_GetFlags(struct _typeobject*);
 211:/usr/local/include/python3.8/object.h **** 
 212:/usr/local/include/python3.8/object.h **** #define PyType_Check(op) \
 213:/usr/local/include/python3.8/object.h ****     PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS)
 214:/usr/local/include/python3.8/object.h **** #define PyType_CheckExact(op) (Py_TYPE(op) == &PyType_Type)
 215:/usr/local/include/python3.8/object.h **** 
 216:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyType_Ready(struct _typeobject *);
 217:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyType_GenericAlloc(struct _typeobject *, Py_ssize_t);
 218:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyType_GenericNew(struct _typeobject *,
 219:/usr/local/include/python3.8/object.h ****                                                PyObject *, PyObject *);
 220:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(unsigned int) PyType_ClearCache(void);
 221:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) PyType_Modified(struct _typeobject *);
 222:/usr/local/include/python3.8/object.h **** 
 223:/usr/local/include/python3.8/object.h **** /* Generic operations on objects */
 224:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);
 225:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);
 226:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);
 227:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);
 228:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);
 229:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);
 230:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);
 231:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);
 232:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);
 233:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);
 234:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);
 235:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);
 236:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);
 237:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);
 238:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *,
 239:/usr/local/include/python3.8/object.h ****                                               PyObject *, PyObject *);
 240:/usr/local/include/python3.8/object.h **** #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
 241:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);
 242:/usr/local/include/python3.8/object.h **** #endif
 243:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(Py_hash_t) PyObject_Hash(PyObject *);
 244:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(Py_hash_t) PyObject_HashNotImplemented(PyObject *);
 245:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_IsTrue(PyObject *);
 246:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_Not(PyObject *);
 247:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyCallable_Check(PyObject *);
 248:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);
 249:/usr/local/include/python3.8/object.h **** 
 250:/usr/local/include/python3.8/object.h **** /* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a
 251:/usr/local/include/python3.8/object.h ****    list of strings.  PyObject_Dir(NULL) is like builtins.dir(),
 252:/usr/local/include/python3.8/object.h ****    returning the names of the current locals.  In this case, if there are
 253:/usr/local/include/python3.8/object.h ****    no current locals, NULL is returned, and PyErr_Occurred() is false.
 254:/usr/local/include/python3.8/object.h **** */
 255:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);
 256:/usr/local/include/python3.8/object.h **** 
 257:/usr/local/include/python3.8/object.h **** 
 258:/usr/local/include/python3.8/object.h **** /* Helpers for printing recursive container types */
 259:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) Py_ReprEnter(PyObject *);
 260:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) Py_ReprLeave(PyObject *);
 261:/usr/local/include/python3.8/object.h **** 
 262:/usr/local/include/python3.8/object.h **** /* Flag bits for printing: */
 263:/usr/local/include/python3.8/object.h **** #define Py_PRINT_RAW    1       /* No string quotes etc. */
 264:/usr/local/include/python3.8/object.h **** 
 265:/usr/local/include/python3.8/object.h **** /*
 266:/usr/local/include/python3.8/object.h **** Type flags (tp_flags)
 267:/usr/local/include/python3.8/object.h **** 
 268:/usr/local/include/python3.8/object.h **** These flags are used to change expected features and behavior for a
 269:/usr/local/include/python3.8/object.h **** particular type.
 270:/usr/local/include/python3.8/object.h **** 
 271:/usr/local/include/python3.8/object.h **** Arbitration of the flag bit positions will need to be coordinated among
 272:/usr/local/include/python3.8/object.h **** all extension writers who publicly release their extensions (this will
 273:/usr/local/include/python3.8/object.h **** be fewer than you might expect!).
 274:/usr/local/include/python3.8/object.h **** 
 275:/usr/local/include/python3.8/object.h **** Most flags were removed as of Python 3.0 to make room for new flags.  (Some
 276:/usr/local/include/python3.8/object.h **** flags are not for backwards compatibility but to indicate the presence of an
 277:/usr/local/include/python3.8/object.h **** optional feature; these flags remain of course.)
 278:/usr/local/include/python3.8/object.h **** 
 279:/usr/local/include/python3.8/object.h **** Type definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.
 280:/usr/local/include/python3.8/object.h **** 
 281:/usr/local/include/python3.8/object.h **** Code can use PyType_HasFeature(type_ob, flag_value) to test whether the
 282:/usr/local/include/python3.8/object.h **** given type object has a specified feature.
 283:/usr/local/include/python3.8/object.h **** */
 284:/usr/local/include/python3.8/object.h **** 
 285:/usr/local/include/python3.8/object.h **** /* Set if the type object is dynamically allocated */
 286:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HEAPTYPE (1UL << 9)
 287:/usr/local/include/python3.8/object.h **** 
 288:/usr/local/include/python3.8/object.h **** /* Set if the type allows subclassing */
 289:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_BASETYPE (1UL << 10)
 290:/usr/local/include/python3.8/object.h **** 
 291:/usr/local/include/python3.8/object.h **** /* Set if the type implements the vectorcall protocol (PEP 590) */
 292:/usr/local/include/python3.8/object.h **** #ifndef Py_LIMITED_API
 293:/usr/local/include/python3.8/object.h **** #define _Py_TPFLAGS_HAVE_VECTORCALL (1UL << 11)
 294:/usr/local/include/python3.8/object.h **** #endif
 295:/usr/local/include/python3.8/object.h **** 
 296:/usr/local/include/python3.8/object.h **** /* Set if the type is 'ready' -- fully initialized */
 297:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_READY (1UL << 12)
 298:/usr/local/include/python3.8/object.h **** 
 299:/usr/local/include/python3.8/object.h **** /* Set while the type is being 'readied', to prevent recursive ready calls */
 300:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_READYING (1UL << 13)
 301:/usr/local/include/python3.8/object.h **** 
 302:/usr/local/include/python3.8/object.h **** /* Objects support garbage collection (see objimpl.h) */
 303:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HAVE_GC (1UL << 14)
 304:/usr/local/include/python3.8/object.h **** 
 305:/usr/local/include/python3.8/object.h **** /* These two bits are preserved for Stackless Python, next after this is 17 */
 306:/usr/local/include/python3.8/object.h **** #ifdef STACKLESS
 307:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3UL << 15)
 308:/usr/local/include/python3.8/object.h **** #else
 309:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0
 310:/usr/local/include/python3.8/object.h **** #endif
 311:/usr/local/include/python3.8/object.h **** 
 312:/usr/local/include/python3.8/object.h **** /* Objects behave like an unbound method */
 313:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_METHOD_DESCRIPTOR (1UL << 17)
 314:/usr/local/include/python3.8/object.h **** 
 315:/usr/local/include/python3.8/object.h **** /* Objects support type attribute cache */
 316:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HAVE_VERSION_TAG   (1UL << 18)
 317:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_VALID_VERSION_TAG  (1UL << 19)
 318:/usr/local/include/python3.8/object.h **** 
 319:/usr/local/include/python3.8/object.h **** /* Type is abstract and cannot be instantiated */
 320:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_IS_ABSTRACT (1UL << 20)
 321:/usr/local/include/python3.8/object.h **** 
 322:/usr/local/include/python3.8/object.h **** /* These flags are used to determine if a type is a subclass. */
 323:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_LONG_SUBCLASS        (1UL << 24)
 324:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_LIST_SUBCLASS        (1UL << 25)
 325:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_TUPLE_SUBCLASS       (1UL << 26)
 326:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_BYTES_SUBCLASS       (1UL << 27)
 327:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_UNICODE_SUBCLASS     (1UL << 28)
 328:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_DICT_SUBCLASS        (1UL << 29)
 329:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_BASE_EXC_SUBCLASS    (1UL << 30)
 330:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_TYPE_SUBCLASS        (1UL << 31)
 331:/usr/local/include/python3.8/object.h **** 
 332:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_DEFAULT  ( \
 333:/usr/local/include/python3.8/object.h ****                  Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \
 334:/usr/local/include/python3.8/object.h ****                  Py_TPFLAGS_HAVE_VERSION_TAG | \
 335:/usr/local/include/python3.8/object.h ****                 0)
 336:/usr/local/include/python3.8/object.h **** 
 337:/usr/local/include/python3.8/object.h **** /* NOTE: The following flags reuse lower bits (removed as part of the
 338:/usr/local/include/python3.8/object.h ****  * Python 3.0 transition). */
 339:/usr/local/include/python3.8/object.h **** 
 340:/usr/local/include/python3.8/object.h **** /* The following flag is kept for compatibility.  Starting with 3.8,
 341:/usr/local/include/python3.8/object.h ****  * binary compatibility of C extensions accross feature releases of
 342:/usr/local/include/python3.8/object.h ****  * Python is not supported anymore, except when using the stable ABI.
 343:/usr/local/include/python3.8/object.h ****  */
 344:/usr/local/include/python3.8/object.h **** 
 345:/usr/local/include/python3.8/object.h **** /* Type structure has tp_finalize member (3.4) */
 346:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HAVE_FINALIZE (1UL << 0)
 347:/usr/local/include/python3.8/object.h **** 
 348:/usr/local/include/python3.8/object.h **** #ifdef Py_LIMITED_API
 349:/usr/local/include/python3.8/object.h **** #  define PyType_HasFeature(t,f)  ((PyType_GetFlags(t) & (f)) != 0)
 350:/usr/local/include/python3.8/object.h **** #endif
 351:/usr/local/include/python3.8/object.h **** #define PyType_FastSubclass(t,f)  PyType_HasFeature(t,f)
 352:/usr/local/include/python3.8/object.h **** 
 353:/usr/local/include/python3.8/object.h **** 
 354:/usr/local/include/python3.8/object.h **** /*
 355:/usr/local/include/python3.8/object.h **** The macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement
 356:/usr/local/include/python3.8/object.h **** reference counts.  Py_DECREF calls the object's deallocator function when
 357:/usr/local/include/python3.8/object.h **** the refcount falls to 0; for
 358:/usr/local/include/python3.8/object.h **** objects that don't contain references to other objects or heap memory
 359:/usr/local/include/python3.8/object.h **** this can be the standard function free().  Both macros can be used
 360:/usr/local/include/python3.8/object.h **** wherever a void expression is allowed.  The argument must not be a
 361:/usr/local/include/python3.8/object.h **** NULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.
 362:/usr/local/include/python3.8/object.h **** The macro _Py_NewReference(op) initialize reference counts to 1, and
 363:/usr/local/include/python3.8/object.h **** in special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional
 364:/usr/local/include/python3.8/object.h **** bookkeeping appropriate to the special build.
 365:/usr/local/include/python3.8/object.h **** 
 366:/usr/local/include/python3.8/object.h **** We assume that the reference count field can never overflow; this can
 367:/usr/local/include/python3.8/object.h **** be proven when the size of the field is the same as the pointer size, so
 368:/usr/local/include/python3.8/object.h **** we ignore the possibility.  Provided a C int is at least 32 bits (which
 369:/usr/local/include/python3.8/object.h **** is implicitly assumed in many parts of this code), that's enough for
 370:/usr/local/include/python3.8/object.h **** about 2**31 references to an object.
 371:/usr/local/include/python3.8/object.h **** 
 372:/usr/local/include/python3.8/object.h **** XXX The following became out of date in Python 2.2, but I'm not sure
 373:/usr/local/include/python3.8/object.h **** XXX what the full truth is now.  Certainly, heap-allocated type objects
 374:/usr/local/include/python3.8/object.h **** XXX can and should be deallocated.
 375:/usr/local/include/python3.8/object.h **** Type objects should never be deallocated; the type pointer in an object
 376:/usr/local/include/python3.8/object.h **** is not considered to be a reference to the type object, to save
 377:/usr/local/include/python3.8/object.h **** complications in the deallocation function.  (This is actually a
 378:/usr/local/include/python3.8/object.h **** decision that's up to the implementer of each new type so if you want,
 379:/usr/local/include/python3.8/object.h **** you can count such references to the type object.)
 380:/usr/local/include/python3.8/object.h **** */
 381:/usr/local/include/python3.8/object.h **** 
 382:/usr/local/include/python3.8/object.h **** /* First define a pile of simple helper macros, one set per special
 383:/usr/local/include/python3.8/object.h ****  * build symbol.  These either expand to the obvious things, or to
 384:/usr/local/include/python3.8/object.h ****  * nothing at all when the special mode isn't in effect.  The main
 385:/usr/local/include/python3.8/object.h ****  * macros can later be defined just once then, yet expand to different
 386:/usr/local/include/python3.8/object.h ****  * things depending on which special build options are and aren't in effect.
 387:/usr/local/include/python3.8/object.h ****  * Trust me <wink>:  while painful, this is 20x easier to understand than,
 388:/usr/local/include/python3.8/object.h ****  * e.g, defining _Py_NewReference five different times in a maze of nested
 389:/usr/local/include/python3.8/object.h ****  * #ifdefs (we used to do that -- it was impenetrable).
 390:/usr/local/include/python3.8/object.h ****  */
 391:/usr/local/include/python3.8/object.h **** #ifdef Py_REF_DEBUG
 392:/usr/local/include/python3.8/object.h **** PyAPI_DATA(Py_ssize_t) _Py_RefTotal;
 393:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_NegativeRefcount(const char *filename, int lineno,
 394:/usr/local/include/python3.8/object.h ****                                       PyObject *op);
 395:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(Py_ssize_t) _Py_GetRefTotal(void);
 396:/usr/local/include/python3.8/object.h **** #define _Py_INC_REFTOTAL        _Py_RefTotal++
 397:/usr/local/include/python3.8/object.h **** #define _Py_DEC_REFTOTAL        _Py_RefTotal--
 398:/usr/local/include/python3.8/object.h **** 
 399:/usr/local/include/python3.8/object.h **** /* Py_REF_DEBUG also controls the display of refcounts and memory block
 400:/usr/local/include/python3.8/object.h ****  * allocations at the interactive prompt and at interpreter shutdown
 401:/usr/local/include/python3.8/object.h ****  */
 402:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _PyDebug_PrintTotalRefs(void);
 403:/usr/local/include/python3.8/object.h **** #else
 404:/usr/local/include/python3.8/object.h **** #define _Py_INC_REFTOTAL
 405:/usr/local/include/python3.8/object.h **** #define _Py_DEC_REFTOTAL
 406:/usr/local/include/python3.8/object.h **** #endif /* Py_REF_DEBUG */
 407:/usr/local/include/python3.8/object.h **** 
 408:/usr/local/include/python3.8/object.h **** #ifdef COUNT_ALLOCS
 409:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_inc_count(struct _typeobject *);
 410:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_dec_count(struct _typeobject *);
 411:/usr/local/include/python3.8/object.h **** #define _Py_INC_TPALLOCS(OP)    _Py_inc_count(Py_TYPE(OP))
 412:/usr/local/include/python3.8/object.h **** #define _Py_INC_TPFREES(OP)     _Py_dec_count(Py_TYPE(OP))
 413:/usr/local/include/python3.8/object.h **** #define _Py_DEC_TPFREES(OP)     Py_TYPE(OP)->tp_frees--
 414:/usr/local/include/python3.8/object.h **** #define _Py_COUNT_ALLOCS_COMMA  ,
 415:/usr/local/include/python3.8/object.h **** #else
 416:/usr/local/include/python3.8/object.h **** #define _Py_INC_TPALLOCS(OP)
 417:/usr/local/include/python3.8/object.h **** #define _Py_INC_TPFREES(OP)
 418:/usr/local/include/python3.8/object.h **** #define _Py_DEC_TPFREES(OP)
 419:/usr/local/include/python3.8/object.h **** #define _Py_COUNT_ALLOCS_COMMA
 420:/usr/local/include/python3.8/object.h **** #endif /* COUNT_ALLOCS */
 421:/usr/local/include/python3.8/object.h **** 
 422:/usr/local/include/python3.8/object.h **** /* Update the Python traceback of an object. This function must be called
 423:/usr/local/include/python3.8/object.h ****    when a memory block is reused from a free list. */
 424:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) _PyTraceMalloc_NewReference(PyObject *op);
 425:/usr/local/include/python3.8/object.h **** 
 426:/usr/local/include/python3.8/object.h **** #ifdef Py_TRACE_REFS
 427:/usr/local/include/python3.8/object.h **** /* Py_TRACE_REFS is such major surgery that we call external routines. */
 428:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_NewReference(PyObject *);
 429:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_ForgetReference(PyObject *);
 430:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_PrintReferences(FILE *);
 431:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_PrintReferenceAddresses(FILE *);
 432:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_AddToAllObjects(PyObject *, int force);
 433:/usr/local/include/python3.8/object.h **** #else
 434:/usr/local/include/python3.8/object.h **** /* Without Py_TRACE_REFS, there's little enough to do that we expand code
 435:/usr/local/include/python3.8/object.h ****    inline. */
 436:/usr/local/include/python3.8/object.h **** static inline void _Py_NewReference(PyObject *op)
 437:/usr/local/include/python3.8/object.h **** {
 438:/usr/local/include/python3.8/object.h ****     if (_Py_tracemalloc_config.tracing) {
 439:/usr/local/include/python3.8/object.h ****         _PyTraceMalloc_NewReference(op);
 440:/usr/local/include/python3.8/object.h ****     }
 441:/usr/local/include/python3.8/object.h ****     _Py_INC_TPALLOCS(op);
 442:/usr/local/include/python3.8/object.h ****     _Py_INC_REFTOTAL;
 443:/usr/local/include/python3.8/object.h ****     Py_REFCNT(op) = 1;
 444:/usr/local/include/python3.8/object.h **** }
 445:/usr/local/include/python3.8/object.h **** 
 446:/usr/local/include/python3.8/object.h **** static inline void _Py_ForgetReference(PyObject *op)
 447:/usr/local/include/python3.8/object.h **** {
 448:/usr/local/include/python3.8/object.h ****     (void)op; /* may be unused, shut up -Wunused-parameter */
 449:/usr/local/include/python3.8/object.h ****     _Py_INC_TPFREES(op);
 450:/usr/local/include/python3.8/object.h **** }
 451:/usr/local/include/python3.8/object.h **** #endif /* !Py_TRACE_REFS */
 452:/usr/local/include/python3.8/object.h **** 
 453:/usr/local/include/python3.8/object.h **** 
 454:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_Dealloc(PyObject *);
 455:/usr/local/include/python3.8/object.h **** 
 456:/usr/local/include/python3.8/object.h **** static inline void _Py_INCREF(PyObject *op)
 3473              		.loc 2 456 20 view .LVU963
 3474              	.LBB46:
 457:/usr/local/include/python3.8/object.h **** {
 458:/usr/local/include/python3.8/object.h ****     _Py_INC_REFTOTAL;
 3475              		.loc 2 458 21 view .LVU964
 459:/usr/local/include/python3.8/object.h ****     op->ob_refcnt++;
 3476              		.loc 2 459 5 view .LVU965
 3477              	@ /usr/local/include/python3.8/object.h:459:     op->ob_refcnt++;
 3478              		.loc 2 459 18 is_stmt 0 view .LVU966
 3479 0ee8 38309FE5 		ldr	r3, .L225	@ tmp126,
 3480              	.LBE46:
 3481              	.LBE45:
 3482              	@ armwave.c:504:     Py_RETURN_TRUE;
 3483              		.loc 1 504 5 view .LVU967
 3484 0eec 0300A0E1 		mov	r0, r3	@ <retval>, tmp126
 3485              	.LBB48:
 3486              	.LBB47:
 3487              	@ /usr/local/include/python3.8/object.h:459:     op->ob_refcnt++;
 3488              		.loc 2 459 18 view .LVU968
 3489 0ef0 002093E5 		ldr	r2, [r3]	@ MEM[(Py_ssize_t *)&_Py_TrueStruct],
 3490 0ef4 012082E2 		add	r2, r2, #1	@ tmp128, MEM[(Py_ssize_t *)&_Py_TrueStruct],
 3491 0ef8 002083E5 		str	r2, [r3]	@ tmp128,
 3492              	.LBE47:
 3493              	.LBE48:
 3494              	@ armwave.c:505: }
 505:armwave.c     **** }
 3495              		.loc 1 505 1 view .LVU969
 3496 0efc 34D08DE2 		add	sp, sp, #52	@,,
 3497              		.cfi_remember_state
 3498              		.cfi_def_cfa_offset 4
 3499              		@ sp needed	@
 3500 0f00 04F09DE4 		ldr	pc, [sp], #4	@
 3501              	.LVL270:
 3502              	.L224:
 3503              		.cfi_restore_state
 492:armwave.c     ****         Py_RETURN_FALSE;
 3504              		.loc 1 492 9 is_stmt 1 view .LVU970
 3505 0f04 20009FE5 		ldr	r0, .L225+4	@,
 3506              	.LVL271:
 492:armwave.c     ****         Py_RETURN_FALSE;
 3507              		.loc 1 492 9 is_stmt 0 view .LVU971
 3508 0f08 FEFFFFEB 		bl	puts		@
 3509              	.LVL272:
 493:armwave.c     ****     }
 3510              		.loc 1 493 9 is_stmt 1 view .LVU972
 3511              	.LBB49:
 3512              	.LBI49:
 456:/usr/local/include/python3.8/object.h **** {
 3513              		.loc 2 456 20 view .LVU973
 3514              	.LBB50:
 458:/usr/local/include/python3.8/object.h ****     op->ob_refcnt++;
 3515              		.loc 2 458 21 view .LVU974
 3516              		.loc 2 459 5 view .LVU975
 3517              	@ /usr/local/include/python3.8/object.h:459:     op->ob_refcnt++;
 3518              		.loc 2 459 18 is_stmt 0 view .LVU976
 3519 0f0c 1C309FE5 		ldr	r3, .L225+8	@ tmp120,
 3520              	.LBE50:
 3521              	.LBE49:
 3522              	@ armwave.c:493:         Py_RETURN_FALSE;
 493:armwave.c     ****     }
 3523              		.loc 1 493 9 view .LVU977
 3524 0f10 0300A0E1 		mov	r0, r3	@ <retval>, tmp120
 3525              	.LBB52:
 3526              	.LBB51:
 3527              	@ /usr/local/include/python3.8/object.h:459:     op->ob_refcnt++;
 3528              		.loc 2 459 18 view .LVU978
 3529 0f14 002093E5 		ldr	r2, [r3]	@ MEM[(Py_ssize_t *)&_Py_FalseStruct],
 3530 0f18 012082E2 		add	r2, r2, #1	@ tmp122, MEM[(Py_ssize_t *)&_Py_FalseStruct],
 3531 0f1c 002083E5 		str	r2, [r3]	@ tmp122,
 3532              	.LBE51:
 3533              	.LBE52:
 3534              	@ armwave.c:505: }
 3535              		.loc 1 505 1 view .LVU979
 3536 0f20 34D08DE2 		add	sp, sp, #52	@,,
 3537              		.cfi_def_cfa_offset 4
 3538              		@ sp needed	@
 3539 0f24 04F09DE4 		ldr	pc, [sp], #4	@
 3540              	.L226:
 3541              		.align	2
 3542              	.L225:
 3543 0f28 00000000 		.word	_Py_TrueStruct
 3544 0f2c AC010000 		.word	.LC18
 3545 0f30 00000000 		.word	_Py_FalseStruct
 3546              		.cfi_endproc
 3547              	.LFE75:
 3549              		.align	2
 3550              		.global	armwave_test_create_am_sine
 3551              		.syntax unified
 3552              		.arm
 3553              		.fpu vfp
 3555              	armwave_test_create_am_sine:
 3556              	.LVL273:
 3557              	.LFB76:
 506:armwave.c     **** 
 507:armwave.c     **** /*
 508:armwave.c     ****  * Make a test AM waveform for render tests.
 509:armwave.c     ****  *
 510:armwave.c     ****  * @param   mod                 modulation depth
 511:armwave.c     ****  * @param   noise_fraction      typically 1e-6
 512:armwave.c     ****  */
 513:armwave.c     **** void armwave_test_create_am_sine(float mod, float noise_fraction)
 514:armwave.c     **** {
 3558              		.loc 1 514 1 is_stmt 1 view -0
 3559              		.cfi_startproc
 3560              		@ args = 0, pretend = 0, frame = 8
 3561              		@ frame_needed = 0, uses_anonymous_args = 0
 515:armwave.c     ****     float v, noise, xnoise, mod_val;
 3562              		.loc 1 515 5 view .LVU981
 516:armwave.c     ****     int w, x;
 3563              		.loc 1 516 5 view .LVU982
 517:armwave.c     **** 
 518:armwave.c     ****     armwave_test_buffer_alloc();
 3564              		.loc 1 518 5 view .LVU983
 3565              	.LBB55:
 3566              	.LBI55:
 463:armwave.c     **** {
 3567              		.loc 1 463 6 view .LVU984
 3568              	.LBB56:
 465:armwave.c     ****         free(g_armwave_state.test_wave_buffer);
 3569              		.loc 1 465 5 view .LVU985
 3570              	.LBE56:
 3571              	.LBE55:
 3572              	@ armwave.c:514: {
 514:armwave.c     ****     float v, noise, xnoise, mod_val;
 3573              		.loc 1 514 1 is_stmt 0 view .LVU986
 3574 0f34 70402DE9 		push	{r4, r5, r6, lr}	@
 3575              		.cfi_def_cfa_offset 16
 3576              		.cfi_offset 4, -16
 3577              		.cfi_offset 5, -12
 3578              		.cfi_offset 6, -8
 3579              		.cfi_offset 14, -4
 3580 0f38 0E8B2DED 		vpush.64	{d8, d9, d10, d11, d12, d13, d14}	@
 3581              		.cfi_def_cfa_offset 72
 3582              		.cfi_offset 80, -72
 3583              		.cfi_offset 81, -68
 3584              		.cfi_offset 82, -64
 3585              		.cfi_offset 83, -60
 3586              		.cfi_offset 84, -56
 3587              		.cfi_offset 85, -52
 3588              		.cfi_offset 86, -48
 3589              		.cfi_offset 87, -44
 3590              		.cfi_offset 88, -40
 3591              		.cfi_offset 89, -36
 3592              		.cfi_offset 90, -32
 3593              		.cfi_offset 91, -28
 3594              		.cfi_offset 92, -24
 3595              		.cfi_offset 93, -20
 3596              	.LBB61:
 3597              	.LBB57:
 3598              	@ armwave.c:465:     if(g_armwave_state.test_wave_buffer != NULL) {
 465:armwave.c     ****         free(g_armwave_state.test_wave_buffer);
 3599              		.loc 1 465 23 view .LVU987
 3600 0f3c A8519FE5 		ldr	r5, .L258+32	@ tmp224,
 3601              	.LBE57:
 3602              	.LBE61:
 3603              	@ armwave.c:514: {
 514:armwave.c     ****     float v, noise, xnoise, mod_val;
 3604              		.loc 1 514 1 view .LVU988
 3605 0f40 40CAF0EE 		vmov.f32	s25, s0	@ mod, mod
 3606 0f44 60BAB0EE 		vmov.f32	s22, s1	@ noise_fraction, noise_fraction
 3607              	.LBB62:
 3608              	.LBB58:
 3609              	@ armwave.c:465:     if(g_armwave_state.test_wave_buffer != NULL) {
 465:armwave.c     ****         free(g_armwave_state.test_wave_buffer);
 3610              		.loc 1 465 23 view .LVU989
 3611 0f48 180095E5 		ldr	r0, [r5, #24]	@ _63, g_armwave_state.test_wave_buffer
 3612              	.LBE58:
 3613              	.LBE62:
 3614              	@ armwave.c:514: {
 514:armwave.c     ****     float v, noise, xnoise, mod_val;
 3615              		.loc 1 514 1 view .LVU990
 3616 0f4c 08D04DE2 		sub	sp, sp, #8	@,,
 3617              		.cfi_def_cfa_offset 80
 3618              	.LBB63:
 3619              	.LBB59:
 3620              	@ armwave.c:465:     if(g_armwave_state.test_wave_buffer != NULL) {
 465:armwave.c     ****         free(g_armwave_state.test_wave_buffer);
 3621              		.loc 1 465 7 view .LVU991
 3622 0f50 000050E3 		cmp	r0, #0	@ _63,
 3623 0f54 0000000A 		beq	.L228		@,
 466:armwave.c     ****     }
 3624              		.loc 1 466 9 is_stmt 1 view .LVU992
 3625 0f58 FEFFFFEB 		bl	free		@
 3626              	.LVL274:
 3627              	.L228:
 471:armwave.c     **** 
 3628              		.loc 1 471 5 view .LVU993
 3629              	@ armwave.c:471:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 471:armwave.c     **** 
 3630              		.loc 1 471 40 is_stmt 0 view .LVU994
 3631 0f5c 403095E5 		ldr	r3, [r5, #64]	@ g_armwave_state.wave_length, g_armwave_state.wave_length
 3632 0f60 304095E5 		ldr	r4, [r5, #48]	@ g_armwave_state.waves_max, g_armwave_state.waves_max
 3633 0f64 0110A0E3 		mov	r1, #1	@,
 3634 0f68 940304E0 		mul	r4, r4, r3	@ _66, g_armwave_state.waves_max, g_armwave_state.wave_length
 3635 0f6c 0400A0E1 		mov	r0, r4	@, _66
 3636 0f70 FEFFFFEB 		bl	calloc		@
 3637              	.LVL275:
 3638              	@ armwave.c:473:     if(g_armwave_state.test_wave_buffer == NULL) {
 473:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes)\n", g_arm
 3639              		.loc 1 473 7 view .LVU995
 3640 0f74 000050E3 		cmp	r0, #0	@ tmp170,
 3641              	@ armwave.c:471:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 471:armwave.c     **** 
 3642              		.loc 1 471 38 view .LVU996
 3643 0f78 180085E5 		str	r0, [r5, #24]	@ tmp170, g_armwave_state.test_wave_buffer
 473:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes)\n", g_arm
 3644              		.loc 1 473 5 is_stmt 1 view .LVU997
 3645              	@ armwave.c:473:     if(g_armwave_state.test_wave_buffer == NULL) {
 473:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes)\n", g_arm
 3646              		.loc 1 473 7 is_stmt 0 view .LVU998
 3647 0f7c 4E00000A 		beq	.L257		@,
 3648              	.L229:
 3649              	.LVL276:
 473:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes)\n", g_arm
 3650              		.loc 1 473 7 view .LVU999
 3651              	.LBE59:
 3652              	.LBE63:
 3653              	@ armwave.c:520:     for(w = 0; w < g_armwave_state.waves; w++) {
 519:armwave.c     **** 
 520:armwave.c     ****     for(w = 0; w < g_armwave_state.waves; w++) {
 3654              		.loc 1 520 35 discriminator 1 view .LVU1000
 3655 0f80 2C2095E5 		ldr	r2, [r5, #44]	@ prephitmp_92, g_armwave_state.waves
 3656              	@ armwave.c:520:     for(w = 0; w < g_armwave_state.waves; w++) {
 3657              		.loc 1 520 5 discriminator 1 view .LVU1001
 3658 0f84 000052E3 		cmp	r2, #0	@ prephitmp_92,
 3659 0f88 4800000A 		beq	.L227		@,
 3660              	@ armwave.c:521:         mod_val = 0.5f + (((float)w / TEST_NWAVES) * mod);
 521:armwave.c     ****         mod_val = 0.5f + (((float)w / TEST_NWAVES) * mod);
 3661              		.loc 1 521 37 view .LVU1002
 3662 0f8c 4EDADFED 		vldr.32	s27, .L258	@ tmp177,
 3663              	@ armwave.c:521:         mod_val = 0.5f + (((float)w / TEST_NWAVES) * mod);
 3664              		.loc 1 521 17 view .LVU1003
 3665 0f90 4EDA9FED 		vldr.32	s26, .L258+4	@ tmp179,
 3666              	@ armwave.c:536:             v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoise) 
 522:armwave.c     ****         //mod = 1.0f;
 523:armwave.c     **** 
 524:armwave.c     ****         for(x = 0; x < g_armwave_state.wave_length; x++) {
 525:armwave.c     ****             noise  = ((rand() & 0xffff) * noise_fraction);
 526:armwave.c     ****             noise *= noise;
 527:armwave.c     ****             noise *= noise;
 528:armwave.c     ****             noise *= noise;
 529:armwave.c     **** 
 530:armwave.c     ****             if((rand() & 0xffff) > 0x7fff)
 531:armwave.c     ****                 noise = -noise;
 532:armwave.c     **** 
 533:armwave.c     ****             noise += 1.0f;
 534:armwave.c     ****             xnoise = (rand() & 0xffff) / 6553500.0f;
 535:armwave.c     **** 
 536:armwave.c     ****             v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoise) * mod_val) * nois
 3667              		.loc 1 536 41 view .LVU1004
 3668 0f94 4E8A9FED 		vldr.32	s16, .L258+8	@ tmp227,
 3669              	@ armwave.c:536:             v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoise) 
 3670              		.loc 1 536 29 view .LVU1005
 3671 0f98 4EBADFED 		vldr.32	s23, .L258+12	@ tmp228,
 3672              	@ armwave.c:539:             g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_stride)
 537:armwave.c     ****             //v = ((x & 0xff) / 128.0f) - 1.0f;
 538:armwave.c     ****             //printf("%d = %d\n", x + (w * g_armwave_state.wave_stride), MIN(MAX(128 + (v * 127), 0
 539:armwave.c     ****             g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_stride)] = (uint8_t)MIN(
 3673              		.loc 1 539 87 view .LVU1006
 3674 0f9c 4ECA9FED 		vldr.32	s24, .L258+16	@ tmp229,
 3675 0fa0 403095E5 		ldr	r3, [r5, #64]	@ prephitmp_97, g_armwave_state.wave_length
 3676              	@ armwave.c:520:     for(w = 0; w < g_armwave_state.waves; w++) {
 520:armwave.c     ****         mod_val = 0.5f + (((float)w / TEST_NWAVES) * mod);
 3677              		.loc 1 520 5 view .LVU1007
 3678 0fa4 0060A0E3 		mov	r6, #0	@ w,
 3679              	.LVL277:
 3680              	.L237:
 521:armwave.c     ****         //mod = 1.0f;
 3681              		.loc 1 521 9 is_stmt 1 view .LVU1008
 3682              	@ armwave.c:521:         mod_val = 0.5f + (((float)w / TEST_NWAVES) * mod);
 521:armwave.c     ****         //mod = 1.0f;
 3683              		.loc 1 521 28 is_stmt 0 view .LVU1009
 3684 0fa8 906A07EE 		vmov	s15, r6	@ int	@ w, w
 3685              	@ armwave.c:521:         mod_val = 0.5f + (((float)w / TEST_NWAVES) * mod);
 521:armwave.c     ****         //mod = 1.0f;
 3686              		.loc 1 521 17 view .LVU1010
 3687 0fac 4D9AB0EE 		vmov.f32	s18, s26	@ mod_val, tmp179
 3688              	@ armwave.c:524:         for(x = 0; x < g_armwave_state.wave_length; x++) {
 524:armwave.c     ****             noise  = ((rand() & 0xffff) * noise_fraction);
 3689              		.loc 1 524 9 view .LVU1011
 3690 0fb0 000053E3 		cmp	r3, #0	@ prephitmp_97,
 3691              	@ armwave.c:521:         mod_val = 0.5f + (((float)w / TEST_NWAVES) * mod);
 521:armwave.c     ****         //mod = 1.0f;
 3692              		.loc 1 521 28 view .LVU1012
 3693 0fb4 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp175, w
 3694              	@ armwave.c:521:         mod_val = 0.5f + (((float)w / TEST_NWAVES) * mod);
 521:armwave.c     ****         //mod = 1.0f;
 3695              		.loc 1 521 37 view .LVU1013
 3696 0fb8 AD7A67EE 		vmul.f32	s15, s15, s27	@ tmp176, tmp175, tmp177
 3697              	@ armwave.c:521:         mod_val = 0.5f + (((float)w / TEST_NWAVES) * mod);
 521:armwave.c     ****         //mod = 1.0f;
 3698              		.loc 1 521 17 view .LVU1014
 3699 0fbc AC9A07EE 		vmla.f32	s18, s15, s25	@ mod_val, tmp176, mod
 3700              	.LVL278:
 524:armwave.c     ****             noise  = ((rand() & 0xffff) * noise_fraction);
 3701              		.loc 1 524 9 is_stmt 1 view .LVU1015
 524:armwave.c     ****             noise  = ((rand() & 0xffff) * noise_fraction);
 3702              		.loc 1 524 9 is_stmt 0 view .LVU1016
 3703 0fc0 3700000A 		beq	.L231		@,
 3704 0fc4 C99AB7EE 		vcvt.f64.f32	d9, s18	@ tmp225, mod_val
 3705              	@ armwave.c:534:             xnoise = (rand() & 0xffff) / 6553500.0f;
 534:armwave.c     **** 
 3706              		.loc 1 534 20 view .LVU1017
 3707 0fc8 44AADFED 		vldr.32	s21, .L258+20	@ tmp197,
 3708              	@ armwave.c:539:             g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_stride)
 3709              		.loc 1 539 96 view .LVU1018
 3710 0fcc 44AA9FED 		vldr.32	s20, .L258+24	@ tmp208,
 3711 0fd0 448ADFED 		vldr.32	s17, .L258+28	@ tmp209,
 3712              	@ armwave.c:524:         for(x = 0; x < g_armwave_state.wave_length; x++) {
 524:armwave.c     ****             noise  = ((rand() & 0xffff) * noise_fraction);
 3713              		.loc 1 524 15 view .LVU1019
 3714 0fd4 0040A0E3 		mov	r4, #0	@ x,
 3715              	.LVL279:
 3716              	.L236:
 525:armwave.c     ****             noise *= noise;
 3717              		.loc 1 525 13 is_stmt 1 view .LVU1020
 3718              	@ armwave.c:525:             noise  = ((rand() & 0xffff) * noise_fraction);
 525:armwave.c     ****             noise *= noise;
 3719              		.loc 1 525 24 is_stmt 0 view .LVU1021
 3720 0fd8 FEFFFFEB 		bl	rand		@
 3721              	.LVL280:
 3722              	@ armwave.c:525:             noise  = ((rand() & 0xffff) * noise_fraction);
 525:armwave.c     ****             noise *= noise;
 3723              		.loc 1 525 31 view .LVU1022
 3724 0fdc 7000FFE6 		uxth	r0, r0	@ tmp180,
 3725              	@ armwave.c:525:             noise  = ((rand() & 0xffff) * noise_fraction);
 525:armwave.c     ****             noise *= noise;
 3726              		.loc 1 525 41 view .LVU1023
 3727 0fe0 900A07EE 		vmov	s15, r0	@ int	@ tmp180, tmp180
 3728 0fe4 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp182, tmp180
 3729              	@ armwave.c:525:             noise  = ((rand() & 0xffff) * noise_fraction);
 525:armwave.c     ****             noise *= noise;
 3730              		.loc 1 525 20 view .LVU1024
 3731 0fe8 8B7A67EE 		vmul.f32	s15, s15, s22	@ noise, tmp182, noise_fraction
 3732              	.LVL281:
 526:armwave.c     ****             noise *= noise;
 3733              		.loc 1 526 13 is_stmt 1 view .LVU1025
 3734              	@ armwave.c:526:             noise *= noise;
 526:armwave.c     ****             noise *= noise;
 3735              		.loc 1 526 19 is_stmt 0 view .LVU1026
 3736 0fec A77A67EE 		vmul.f32	s15, s15, s15	@ noise, noise, noise
 3737              	.LVL282:
 527:armwave.c     ****             noise *= noise;
 3738              		.loc 1 527 13 is_stmt 1 view .LVU1027
 3739              	@ armwave.c:527:             noise *= noise;
 527:armwave.c     ****             noise *= noise;
 3740              		.loc 1 527 19 is_stmt 0 view .LVU1028
 3741 0ff0 A77A67EE 		vmul.f32	s15, s15, s15	@ noise, noise, noise
 3742              	.LVL283:
 528:armwave.c     **** 
 3743              		.loc 1 528 13 is_stmt 1 view .LVU1029
 3744              	@ armwave.c:528:             noise *= noise;
 528:armwave.c     **** 
 3745              		.loc 1 528 19 is_stmt 0 view .LVU1030
 3746 0ff4 A7EA27EE 		vmul.f32	s28, s15, s15	@ noise, noise, noise
 3747              	.LVL284:
 530:armwave.c     ****                 noise = -noise;
 3748              		.loc 1 530 13 is_stmt 1 view .LVU1031
 3749              	@ armwave.c:530:             if((rand() & 0xffff) > 0x7fff)
 530:armwave.c     ****                 noise = -noise;
 3750              		.loc 1 530 17 is_stmt 0 view .LVU1032
 3751 0ff8 FEFFFFEB 		bl	rand		@
 3752              	.LVL285:
 531:armwave.c     **** 
 3753              		.loc 1 531 17 is_stmt 1 view .LVU1033
 3754              	@ armwave.c:530:             if((rand() & 0xffff) > 0x7fff)
 530:armwave.c     ****                 noise = -noise;
 3755              		.loc 1 530 15 is_stmt 0 view .LVU1034
 3756 0ffc 020910E3 		tst	r0, #32768	@,
 3757              	@ armwave.c:531:                 noise = -noise;
 531:armwave.c     **** 
 3758              		.loc 1 531 23 view .LVU1035
 3759 1000 4EEAB11E 		vnegne.f32	s28, s28	@ noise, noise
 3760              	.LVL286:
 533:armwave.c     ****             xnoise = (rand() & 0xffff) / 6553500.0f;
 3761              		.loc 1 533 13 is_stmt 1 view .LVU1036
 534:armwave.c     **** 
 3762              		.loc 1 534 13 view .LVU1037
 3763              	@ armwave.c:534:             xnoise = (rand() & 0xffff) / 6553500.0f;
 534:armwave.c     **** 
 3764              		.loc 1 534 23 is_stmt 0 view .LVU1038
 3765 1004 FEFFFFEB 		bl	rand		@
 3766              	.LVL287:
 536:armwave.c     ****             //v = ((x & 0xff) / 128.0f) - 1.0f;
 3767              		.loc 1 536 13 is_stmt 1 view .LVU1039
 3768              	@ armwave.c:536:             v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoise) 
 536:armwave.c     ****             //v = ((x & 0xff) / 128.0f) - 1.0f;
 3769              		.loc 1 536 41 is_stmt 0 view .LVU1040
 3770 1008 107A95ED 		vldr.32	s14, [r5, #64]	@ int	@ tmp235, g_armwave_state.wave_length
 3771              	@ armwave.c:536:             v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoise) 
 536:armwave.c     ****             //v = ((x & 0xff) / 128.0f) - 1.0f;
 3772              		.loc 1 536 29 view .LVU1041
 3773 100c 904A07EE 		vmov	s15, r4	@ int	@ x, x
 3774              	@ armwave.c:536:             v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoise) 
 536:armwave.c     ****             //v = ((x & 0xff) / 128.0f) - 1.0f;
 3775              		.loc 1 536 41 view .LVU1042
 3776 1010 477AB8EE 		vcvt.f32.u32	s14, s14	@ tmp185, tmp235
 3777              	@ armwave.c:536:             v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoise) 
 536:armwave.c     ****             //v = ((x & 0xff) / 128.0f) - 1.0f;
 3778              		.loc 1 536 29 view .LVU1043
 3779 1014 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp189, x
 3780              	@ armwave.c:536:             v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoise) 
 536:armwave.c     ****             //v = ((x & 0xff) / 128.0f) - 1.0f;
 3781              		.loc 1 536 41 view .LVU1044
 3782 1018 076AC8EE 		vdiv.f32	s13, s16, s14	@ tmp187, tmp227, tmp185
 3783              	@ armwave.c:536:             v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoise) 
 536:armwave.c     ****             //v = ((x & 0xff) / 128.0f) - 1.0f;
 3784              		.loc 1 536 29 view .LVU1045
 3785 101c AB7A67EE 		vmul.f32	s15, s15, s23	@ tmp190, tmp189, tmp228
 3786              	@ armwave.c:534:             xnoise = (rand() & 0xffff) / 6553500.0f;
 534:armwave.c     **** 
 3787              		.loc 1 534 30 view .LVU1046
 3788 1020 7000FFE6 		uxth	r0, r0	@ tmp193,
 3789              	.LVL288:
 3790              	@ armwave.c:534:             xnoise = (rand() & 0xffff) / 6553500.0f;
 534:armwave.c     **** 
 3791              		.loc 1 534 40 view .LVU1047
 3792 1024 100A07EE 		vmov	s14, r0	@ int	@ tmp193, tmp193
 3793 1028 C77AB8EE 		vcvt.f32.s32	s14, s14	@ tmp195, tmp193
 3794              	@ armwave.c:534:             xnoise = (rand() & 0xffff) / 6553500.0f;
 534:armwave.c     **** 
 3795              		.loc 1 534 20 view .LVU1048
 3796 102c 2A0A87EE 		vdiv.f32	s0, s14, s21	@ xnoise, tmp195, tmp197
 3797              	@ armwave.c:536:             v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoise) 
 536:armwave.c     ****             //v = ((x & 0xff) / 128.0f) - 1.0f;
 3798              		.loc 1 536 73 view .LVU1049
 3799 1030 A70A06EE 		vmla.f32	s0, s13, s15	@ tmp198, tmp187, tmp190
 3800              	@ armwave.c:536:             v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoise) 
 536:armwave.c     ****             //v = ((x & 0xff) / 128.0f) - 1.0f;
 3801              		.loc 1 536 18 view .LVU1050
 3802 1034 C00AB7EE 		vcvt.f64.f32	d0, s0	@, tmp198
 3803 1038 FEFFFFEB 		bl	sin		@
 3804              	.LVL289:
 3805              		.loc 1 539 13 is_stmt 1 view .LVU1051
 3806              	@ armwave.c:533:             noise += 1.0f;
 533:armwave.c     ****             xnoise = (rand() & 0xffff) / 6553500.0f;
 3807              		.loc 1 533 19 is_stmt 0 view .LVU1052
 3808 103c 087A7EEE 		vadd.f32	s15, s28, s16	@ noise, noise, tmp227
 3809              	@ armwave.c:539:             g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_stride)
 3810              		.loc 1 539 87 view .LVU1053
 3811 1040 0020A0E3 		mov	r2, #0	@ iftmp.20_39,
 3812              	@ armwave.c:536:             v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoise) 
 536:armwave.c     ****             //v = ((x & 0xff) / 128.0f) - 1.0f;
 3813              		.loc 1 536 94 view .LVU1054
 3814 1044 E77AB7EE 		vcvt.f64.f32	d7, s15	@ tmp204, noise
 3815              	@ armwave.c:536:             v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoise) 
 536:armwave.c     ****             //v = ((x & 0xff) / 128.0f) - 1.0f;
 3816              		.loc 1 536 83 view .LVU1055
 3817 1048 000B29EE 		vmul.f64	d0, d9, d0	@ tmp201, tmp225,
 3818              	.LVL290:
 3819              	@ armwave.c:536:             v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoise) 
 536:armwave.c     ****             //v = ((x & 0xff) / 128.0f) - 1.0f;
 3820              		.loc 1 536 94 view .LVU1056
 3821 104c 077B20EE 		vmul.f64	d7, d0, d7	@ tmp205, tmp201, tmp204
 3822              	@ armwave.c:536:             v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoise) 
 536:armwave.c     ****             //v = ((x & 0xff) / 128.0f) - 1.0f;
 3823              		.loc 1 536 15 view .LVU1057
 3824 1050 C77BB7EE 		vcvt.f32.f64	s14, d7	@ v, tmp205
 3825              	@ armwave.c:539:             g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_stride)
 3826              		.loc 1 539 96 view .LVU1058
 3827 1054 687AF0EE 		vmov.f32	s15, s17	@ _26, tmp209
 3828 1058 0A7A47EE 		vmla.f32	s15, s14, s20	@ _26, v, tmp208
 3829 105c C07AF5EE 		vcmpe.f32	s15, #0	@ _26
 3830 1060 10FAF1EE 		vmrs	APSR_nzcv, FPSCR
 3831 1064 050000DA 		ble	.L233		@,
 3832              	@ armwave.c:539:             g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_stride)
 3833              		.loc 1 539 87 discriminator 1 view .LVU1059
 3834 1068 CC7AF4EE 		vcmpe.f32	s15, s24	@ _26, tmp229
 3835 106c FF20A0E3 		mov	r2, #255	@ iftmp.20_39,
 3836 1070 10FAF1EE 		vmrs	APSR_nzcv, FPSCR
 3837 1074 E77AFC4E 		vcvtmi.u32.f32	s15, s15	@ tmp213, _26
 3838 1078 017ACD4D 		vstrmi.32	s15, [sp, #4]	@ int	@ tmp213, %sfp
 3839 107c 0420DD45 		ldrbmi	r2, [sp, #4]	@ zero_extendqisi2	@ iftmp.20_39, %sfp
 3840              	.L233:
 3841              	@ armwave.c:539:             g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_stride)
 3842              		.loc 1 539 53 discriminator 12 view .LVU1060
 3843 1080 283095E5 		ldr	r3, [r5, #40]	@ g_armwave_state.wave_stride, g_armwave_state.wave_stride
 3844              	@ armwave.c:539:             g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_stride)
 3845              		.loc 1 539 85 discriminator 12 view .LVU1061
 3846 1084 181095E5 		ldr	r1, [r5, #24]	@ g_armwave_state.test_wave_buffer, g_armwave_state.test_wave_buffer
 3847 1088 931623E0 		mla	r3, r3, r6, r1	@ tmp219, g_armwave_state.wave_stride, w, g_armwave_state.test_wave_buffer
 3848 108c 0420C3E7 		strb	r2, [r3, r4]	@ iftmp.20_39, *_31
 3849              	@ armwave.c:524:         for(x = 0; x < g_armwave_state.wave_length; x++) {
 524:armwave.c     ****             noise  = ((rand() & 0xffff) * noise_fraction);
 3850              		.loc 1 524 39 discriminator 12 view .LVU1062
 3851 1090 403095E5 		ldr	r3, [r5, #64]	@ prephitmp_97, g_armwave_state.wave_length
 3852              	@ armwave.c:524:         for(x = 0; x < g_armwave_state.wave_length; x++) {
 524:armwave.c     ****             noise  = ((rand() & 0xffff) * noise_fraction);
 3853              		.loc 1 524 54 discriminator 12 view .LVU1063
 3854 1094 014084E2 		add	r4, r4, #1	@ x, x,
 3855              	.LVL291:
 3856              	@ armwave.c:524:         for(x = 0; x < g_armwave_state.wave_length; x++) {
 524:armwave.c     ****             noise  = ((rand() & 0xffff) * noise_fraction);
 3857              		.loc 1 524 9 discriminator 12 view .LVU1064
 3858 1098 040053E1 		cmp	r3, r4	@ prephitmp_97, x
 3859 109c CDFFFF8A 		bhi	.L236		@,
 3860 10a0 2C2095E5 		ldr	r2, [r5, #44]	@ prephitmp_92, g_armwave_state.waves
 3861              	.LVL292:
 3862              	.L231:
 3863              	@ armwave.c:520:     for(w = 0; w < g_armwave_state.waves; w++) {
 520:armwave.c     ****         mod_val = 0.5f + (((float)w / TEST_NWAVES) * mod);
 3864              		.loc 1 520 44 discriminator 2 view .LVU1065
 3865 10a4 016086E2 		add	r6, r6, #1	@ w, w,
 3866              	.LVL293:
 3867              	@ armwave.c:520:     for(w = 0; w < g_armwave_state.waves; w++) {
 520:armwave.c     ****         mod_val = 0.5f + (((float)w / TEST_NWAVES) * mod);
 3868              		.loc 1 520 5 discriminator 2 view .LVU1066
 3869 10a8 020056E1 		cmp	r6, r2	@ w, prephitmp_92
 3870 10ac BDFFFF3A 		bcc	.L237		@,
 3871              	.LVL294:
 3872              	.L227:
 3873              	@ armwave.c:542: }
 540:armwave.c     ****         }
 541:armwave.c     ****     }
 542:armwave.c     **** }
 3874              		.loc 1 542 1 view .LVU1067
 3875 10b0 08D08DE2 		add	sp, sp, #8	@,,
 3876              		.cfi_remember_state
 3877              		.cfi_def_cfa_offset 72
 3878              		@ sp needed	@
 3879 10b4 0E8BBDEC 		vldm	sp!, {d8-d14}	@,
 3880              		.cfi_restore 92
 3881              		.cfi_restore 93
 3882              		.cfi_restore 90
 3883              		.cfi_restore 91
 3884              		.cfi_restore 88
 3885              		.cfi_restore 89
 3886              		.cfi_restore 86
 3887              		.cfi_restore 87
 3888              		.cfi_restore 84
 3889              		.cfi_restore 85
 3890              		.cfi_restore 82
 3891              		.cfi_restore 83
 3892              		.cfi_restore 80
 3893              		.cfi_restore 81
 3894              		.cfi_def_cfa_offset 16
 3895              	.LVL295:
 3896              		.loc 1 542 1 view .LVU1068
 3897 10b8 7080BDE8 		pop	{r4, r5, r6, pc}	@
 3898              	.LVL296:
 3899              	.L257:
 3900              		.cfi_restore_state
 3901              	.LBB64:
 3902              	.LBB60:
 474:armwave.c     ****         return;
 3903              		.loc 1 474 9 is_stmt 1 view .LVU1069
 3904 10bc 0410A0E1 		mov	r1, r4	@, _66
 3905 10c0 28009FE5 		ldr	r0, .L258+36	@,
 3906 10c4 FEFFFFEB 		bl	printf		@
 3907              	.LVL297:
 475:armwave.c     ****     }
 3908              		.loc 1 475 9 view .LVU1070
 3909 10c8 ACFFFFEA 		b	.L229		@
 3910              	.L259:
 3911              		.align	2
 3912              	.L258:
 3913 10cc 0000803C 		.word	1015021568
 3914 10d0 0000003F 		.word	1056964608
 3915 10d4 0000803F 		.word	1065353216
 3916 10d8 C3F5C840 		.word	1086911939
 3917 10dc 00007F43 		.word	1132396544
 3918 10e0 38FFC74A 		.word	1254620984
 3919 10e4 0000FE42 		.word	1123942400
 3920 10e8 00000043 		.word	1124073472
 3921 10ec 00000000 		.word	g_armwave_state
 3922 10f0 60010000 		.word	.LC17
 3923              	.LBE60:
 3924              	.LBE64:
 3925              		.cfi_endproc
 3926              	.LFE76:
 3928              		.align	2
 3929              		.global	armwave_test_create_square
 3930              		.syntax unified
 3931              		.arm
 3932              		.fpu vfp
 3934              	armwave_test_create_square:
 3935              	.LVL298:
 3936              	.LFB77:
 543:armwave.c     **** 
 544:armwave.c     **** /*
 545:armwave.c     ****  * Make a test square waveform.
 546:armwave.c     ****  *
 547:armwave.c     ****  * @param   noise_fraction      typically 1e-6
 548:armwave.c     ****  */
 549:armwave.c     **** void armwave_test_create_square(float noise_fraction)
 550:armwave.c     **** {
 3937              		.loc 1 550 1 view -0
 3938              		.cfi_startproc
 3939              		@ args = 0, pretend = 0, frame = 8
 3940              		@ frame_needed = 0, uses_anonymous_args = 0
 551:armwave.c     ****     uint8_t v;
 3941              		.loc 1 551 5 view .LVU1072
 552:armwave.c     ****     float noise, xnoise;
 3942              		.loc 1 552 5 view .LVU1073
 553:armwave.c     ****     float level = 0.8f, new_level = 0.8f;
 3943              		.loc 1 553 5 view .LVU1074
 554:armwave.c     ****     int w, x;
 3944              		.loc 1 554 5 view .LVU1075
 555:armwave.c     **** 
 556:armwave.c     ****     for(w = 0; w < g_armwave_state.waves; w++) {
 3945              		.loc 1 556 5 view .LVU1076
 3946              	@ armwave.c:550: {
 550:armwave.c     ****     uint8_t v;
 3947              		.loc 1 550 1 is_stmt 0 view .LVU1077
 3948 10f4 70402DE9 		push	{r4, r5, r6, lr}	@
 3949              		.cfi_def_cfa_offset 16
 3950              		.cfi_offset 4, -16
 3951              		.cfi_offset 5, -12
 3952              		.cfi_offset 6, -8
 3953              		.cfi_offset 14, -4
 3954 10f8 0A8B2DED 		vpush.64	{d8, d9, d10, d11, d12}	@
 3955              		.cfi_def_cfa_offset 56
 3956              		.cfi_offset 80, -56
 3957              		.cfi_offset 81, -52
 3958              		.cfi_offset 82, -48
 3959              		.cfi_offset 83, -44
 3960              		.cfi_offset 84, -40
 3961              		.cfi_offset 85, -36
 3962              		.cfi_offset 86, -32
 3963              		.cfi_offset 87, -28
 3964              		.cfi_offset 88, -24
 3965              		.cfi_offset 89, -20
 3966              	@ armwave.c:556:     for(w = 0; w < g_armwave_state.waves; w++) {
 3967              		.loc 1 556 35 view .LVU1078
 3968 10fc 54519FE5 		ldr	r5, .L288+32	@ tmp179,
 3969 1100 2C2095E5 		ldr	r2, [r5, #44]	@ prephitmp_33, g_armwave_state.waves
 3970              	@ armwave.c:550: {
 550:armwave.c     ****     uint8_t v;
 3971              		.loc 1 550 1 view .LVU1079
 3972 1104 08D04DE2 		sub	sp, sp, #8	@,,
 3973              		.cfi_def_cfa_offset 64
 3974              	@ armwave.c:556:     for(w = 0; w < g_armwave_state.waves; w++) {
 3975              		.loc 1 556 5 view .LVU1080
 3976 1108 000052E3 		cmp	r2, #0	@ prephitmp_33,
 3977 110c 4600000A 		beq	.L260		@,
 3978 1110 409AF0EE 		vmov.f32	s19, s0	@ noise_fraction, noise_fraction
 3979              	@ armwave.c:553:     float level = 0.8f, new_level = 0.8f;
 553:armwave.c     ****     int w, x;
 3980              		.loc 1 553 11 view .LVU1081
 3981 1114 47CA9FED 		vldr.32	s24, .L288	@ level,
 3982              	@ armwave.c:568:             if(x > (g_armwave_state.wave_length * 0.75f)) {
 557:armwave.c     ****         for(x = 0; x < g_armwave_state.wave_length; x++) {
 558:armwave.c     ****             noise  = ((rand() & 0xffff) * noise_fraction);
 559:armwave.c     ****             noise *= noise;
 560:armwave.c     ****             noise *= noise;
 561:armwave.c     ****             noise *= noise;
 562:armwave.c     **** 
 563:armwave.c     ****             if((rand() & 0xff) > 0x7f)
 564:armwave.c     ****                 noise = -noise;
 565:armwave.c     **** 
 566:armwave.c     ****             //noise += 1.0f;
 567:armwave.c     **** 
 568:armwave.c     ****             if(x > (g_armwave_state.wave_length * 0.75f)) {
 3983              		.loc 1 568 49 view .LVU1082
 3984 1118 47AA9FED 		vldr.32	s20, .L288+4	@ tmp186,
 3985              	@ armwave.c:573:                 new_level = 0.2f;
 569:armwave.c     ****                 new_level = 0.2f;
 570:armwave.c     ****             } else if(x > (g_armwave_state.wave_length * 0.5f)) {
 571:armwave.c     ****                 new_level = 0.8f;
 572:armwave.c     ****             } else if(x > (g_armwave_state.wave_length * 0.25f)) {
 573:armwave.c     ****                 new_level = 0.2f;
 3986              		.loc 1 573 27 view .LVU1083
 3987 111c 47AADFED 		vldr.32	s21, .L288+8	@ new_level,
 3988              	@ armwave.c:570:             } else if(x > (g_armwave_state.wave_length * 0.5f)) {
 570:armwave.c     ****                 new_level = 0.8f;
 3989              		.loc 1 570 56 view .LVU1084
 3990 1120 47BADFED 		vldr.32	s23, .L288+12	@ tmp188,
 3991              	@ armwave.c:572:             } else if(x > (g_armwave_state.wave_length * 0.25f)) {
 572:armwave.c     ****                 new_level = 0.2f;
 3992              		.loc 1 572 56 view .LVU1085
 3993 1124 478ADFED 		vldr.32	s17, .L288+16	@ tmp189,
 3994 1128 403095E5 		ldr	r3, [r5, #64]	@ prephitmp_70, g_armwave_state.wave_length
 3995              	@ armwave.c:556:     for(w = 0; w < g_armwave_state.waves; w++) {
 556:armwave.c     ****         for(x = 0; x < g_armwave_state.wave_length; x++) {
 3996              		.loc 1 556 11 view .LVU1086
 3997 112c 0060A0E3 		mov	r6, #0	@ w,
 3998              	.LVL299:
 3999              	.L262:
 4000              	@ armwave.c:557:         for(x = 0; x < g_armwave_state.wave_length; x++) {
 557:armwave.c     ****             noise  = ((rand() & 0xffff) * noise_fraction);
 4001              		.loc 1 557 9 view .LVU1087
 4002 1130 000053E3 		cmp	r3, #0	@ prephitmp_70,
 4003 1134 3900000A 		beq	.L269		@,
 4004              	@ armwave.c:571:                 new_level = 0.8f;
 571:armwave.c     ****             } else if(x > (g_armwave_state.wave_length * 0.25f)) {
 4005              		.loc 1 571 27 view .LVU1088
 4006 1138 3EBA9FED 		vldr.32	s22, .L288	@ new_level,
 4007              	@ armwave.c:578:             level = ((level * 3) + new_level) * 0.25f;
 574:armwave.c     ****             } else {
 575:armwave.c     ****                 new_level = 0.8f;
 576:armwave.c     ****             }
 577:armwave.c     **** 
 578:armwave.c     ****             level = ((level * 3) + new_level) * 0.25f;
 4008              		.loc 1 578 29 view .LVU1089
 4009 113c 429A9FED 		vldr.32	s18, .L288+20	@ tmp161,
 4010              	@ armwave.c:557:         for(x = 0; x < g_armwave_state.wave_length; x++) {
 557:armwave.c     ****             noise  = ((rand() & 0xffff) * noise_fraction);
 4011              		.loc 1 557 15 view .LVU1090
 4012 1140 0040A0E3 		mov	r4, #0	@ x,
 4013              	.LVL300:
 4014              	.L268:
 558:armwave.c     ****             noise *= noise;
 4015              		.loc 1 558 13 is_stmt 1 view .LVU1091
 4016              	@ armwave.c:558:             noise  = ((rand() & 0xffff) * noise_fraction);
 558:armwave.c     ****             noise *= noise;
 4017              		.loc 1 558 24 is_stmt 0 view .LVU1092
 4018 1144 FEFFFFEB 		bl	rand		@
 4019              	.LVL301:
 4020              	@ armwave.c:558:             noise  = ((rand() & 0xffff) * noise_fraction);
 558:armwave.c     ****             noise *= noise;
 4021              		.loc 1 558 31 view .LVU1093
 4022 1148 7000FFE6 		uxth	r0, r0	@ tmp148,
 4023              	@ armwave.c:558:             noise  = ((rand() & 0xffff) * noise_fraction);
 558:armwave.c     ****             noise *= noise;
 4024              		.loc 1 558 41 view .LVU1094
 4025 114c 900A07EE 		vmov	s15, r0	@ int	@ tmp148, tmp148
 4026 1150 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp150, tmp148
 4027              	@ armwave.c:558:             noise  = ((rand() & 0xffff) * noise_fraction);
 558:armwave.c     ****             noise *= noise;
 4028              		.loc 1 558 20 view .LVU1095
 4029 1154 A97A67EE 		vmul.f32	s15, s15, s19	@ noise, tmp150, noise_fraction
 4030              	.LVL302:
 559:armwave.c     ****             noise *= noise;
 4031              		.loc 1 559 13 is_stmt 1 view .LVU1096
 4032              	@ armwave.c:559:             noise *= noise;
 559:armwave.c     ****             noise *= noise;
 4033              		.loc 1 559 19 is_stmt 0 view .LVU1097
 4034 1158 A77A67EE 		vmul.f32	s15, s15, s15	@ noise, noise, noise
 4035              	.LVL303:
 560:armwave.c     ****             noise *= noise;
 4036              		.loc 1 560 13 is_stmt 1 view .LVU1098
 4037              	@ armwave.c:560:             noise *= noise;
 560:armwave.c     ****             noise *= noise;
 4038              		.loc 1 560 19 is_stmt 0 view .LVU1099
 4039 115c A77A67EE 		vmul.f32	s15, s15, s15	@ noise, noise, noise
 4040              	.LVL304:
 561:armwave.c     **** 
 4041              		.loc 1 561 13 is_stmt 1 view .LVU1100
 4042              	@ armwave.c:561:             noise *= noise;
 561:armwave.c     **** 
 4043              		.loc 1 561 19 is_stmt 0 view .LVU1101
 4044 1160 A78A27EE 		vmul.f32	s16, s15, s15	@ noise, noise, noise
 4045              	.LVL305:
 563:armwave.c     ****                 noise = -noise;
 4046              		.loc 1 563 13 is_stmt 1 view .LVU1102
 4047              	@ armwave.c:563:             if((rand() & 0xff) > 0x7f)
 563:armwave.c     ****                 noise = -noise;
 4048              		.loc 1 563 17 is_stmt 0 view .LVU1103
 4049 1164 FEFFFFEB 		bl	rand		@
 4050              	.LVL306:
 4051              	@ armwave.c:568:             if(x > (g_armwave_state.wave_length * 0.75f)) {
 568:armwave.c     ****                 new_level = 0.2f;
 4052              		.loc 1 568 18 view .LVU1104
 4053 1168 904A07EE 		vmov	s15, r4	@ int	@ x, x
 4054 116c E77AB8EE 		vcvt.f32.s32	s14, s15	@ _6, x
 4055              	@ armwave.c:568:             if(x > (g_armwave_state.wave_length * 0.75f)) {
 568:armwave.c     ****                 new_level = 0.2f;
 4056              		.loc 1 568 49 view .LVU1105
 4057 1170 107AD5ED 		vldr.32	s15, [r5, #64]	@ int	@ tmp195, g_armwave_state.wave_length
 4058 1174 677AF8EE 		vcvt.f32.u32	s15, s15	@ _8, tmp195
 4059 1178 8A6A67EE 		vmul.f32	s13, s15, s20	@ tmp154, _8, tmp186
 4060              	@ armwave.c:568:             if(x > (g_armwave_state.wave_length * 0.75f)) {
 568:armwave.c     ****                 new_level = 0.2f;
 4061              		.loc 1 568 15 view .LVU1106
 4062 117c E67AB4EE 		vcmpe.f32	s14, s13	@ _6, tmp154
 4063              	@ armwave.c:563:             if((rand() & 0xff) > 0x7f)
 563:armwave.c     ****                 noise = -noise;
 4064              		.loc 1 563 15 view .LVU1107
 4065 1180 800010E3 		tst	r0, #128	@,
 564:armwave.c     **** 
 4066              		.loc 1 564 17 is_stmt 1 view .LVU1108
 4067              	@ armwave.c:564:                 noise = -noise;
 564:armwave.c     **** 
 4068              		.loc 1 564 23 is_stmt 0 view .LVU1109
 4069 1184 488AB11E 		vnegne.f32	s16, s16	@ noise, noise
 4070              	.LVL307:
 568:armwave.c     ****                 new_level = 0.2f;
 4071              		.loc 1 568 13 is_stmt 1 view .LVU1110
 4072              	@ armwave.c:568:             if(x > (g_armwave_state.wave_length * 0.75f)) {
 568:armwave.c     ****                 new_level = 0.2f;
 4073              		.loc 1 568 15 is_stmt 0 view .LVU1111
 4074 1188 10FAF1EE 		vmrs	APSR_nzcv, FPSCR
 4075              	@ armwave.c:573:                 new_level = 0.2f;
 573:armwave.c     ****             } else {
 4076              		.loc 1 573 27 view .LVU1112
 4077 118c 6A7AF0CE 		vmovgt.f32	s15, s21	@ new_level, new_level
 4078              	@ armwave.c:568:             if(x > (g_armwave_state.wave_length * 0.75f)) {
 568:armwave.c     ****                 new_level = 0.2f;
 4079              		.loc 1 568 15 view .LVU1113
 4080 1190 090000CA 		bgt	.L264		@,
 570:armwave.c     ****                 new_level = 0.8f;
 4081              		.loc 1 570 20 is_stmt 1 view .LVU1114
 4082              	@ armwave.c:570:             } else if(x > (g_armwave_state.wave_length * 0.5f)) {
 570:armwave.c     ****                 new_level = 0.8f;
 4083              		.loc 1 570 56 is_stmt 0 view .LVU1115
 4084 1194 AB6A67EE 		vmul.f32	s13, s15, s23	@ tmp156, _8, tmp188
 4085              	@ armwave.c:570:             } else if(x > (g_armwave_state.wave_length * 0.5f)) {
 570:armwave.c     ****                 new_level = 0.8f;
 4086              		.loc 1 570 22 view .LVU1116
 4087 1198 E67AB4EE 		vcmpe.f32	s14, s13	@ _6, tmp156
 4088 119c 10FAF1EE 		vmrs	APSR_nzcv, FPSCR
 4089              	@ armwave.c:571:                 new_level = 0.8f;
 571:armwave.c     ****             } else if(x > (g_armwave_state.wave_length * 0.25f)) {
 4090              		.loc 1 571 27 view .LVU1117
 4091 11a0 4B7AF0CE 		vmovgt.f32	s15, s22	@ new_level, new_level
 4092              	@ armwave.c:570:             } else if(x > (g_armwave_state.wave_length * 0.5f)) {
 570:armwave.c     ****                 new_level = 0.8f;
 4093              		.loc 1 570 22 view .LVU1118
 4094 11a4 040000CA 		bgt	.L264		@,
 572:armwave.c     ****                 new_level = 0.2f;
 4095              		.loc 1 572 20 is_stmt 1 view .LVU1119
 4096              	@ armwave.c:572:             } else if(x > (g_armwave_state.wave_length * 0.25f)) {
 572:armwave.c     ****                 new_level = 0.2f;
 4097              		.loc 1 572 56 is_stmt 0 view .LVU1120
 4098 11a8 A87A67EE 		vmul.f32	s15, s15, s17	@ tmp158, _8, tmp189
 4099              	@ armwave.c:571:                 new_level = 0.8f;
 571:armwave.c     ****             } else if(x > (g_armwave_state.wave_length * 0.25f)) {
 4100              		.loc 1 571 27 view .LVU1121
 4101 11ac E77AB4EE 		vcmpe.f32	s14, s15	@ _6, tmp158
 4102 11b0 10FAF1EE 		vmrs	APSR_nzcv, FPSCR
 4103 11b4 4B7AF0DE 		vmovle.f32	s15, s22	@, new_level, new_level
 4104 11b8 6A7AF0CE 		vmovgt.f32	s15, s21	@, new_level, new_level
 4105              	.L264:
 4106              	.LVL308:
 4107              		.loc 1 578 13 is_stmt 1 view .LVU1122
 4108              	@ armwave.c:578:             level = ((level * 3) + new_level) * 0.25f;
 4109              		.loc 1 578 34 is_stmt 0 view .LVU1123
 4110 11bc 097A4CEE 		vmla.f32	s15, s24, s18	@ _14, level, tmp161
 4111              	.LVL309:
 4112              	@ armwave.c:578:             level = ((level * 3) + new_level) * 0.25f;
 4113              		.loc 1 578 19 view .LVU1124
 4114 11c0 A8CA27EE 		vmul.f32	s24, s15, s17	@ level, _14, tmp189
 4115              	.LVL310:
 579:armwave.c     **** 
 580:armwave.c     ****             v = (uint8_t)(CLAMP(level + noise, 0.0f, 1.0f) * 255);
 4116              		.loc 1 580 13 is_stmt 1 view .LVU1125
 4117              	@ armwave.c:580:             v = (uint8_t)(CLAMP(level + noise, 0.0f, 1.0f) * 255);
 4118              		.loc 1 580 27 is_stmt 0 view .LVU1126
 4119 11c4 0C7A78EE 		vadd.f32	s15, s16, s24	@ _15, noise, level
 4120 11c8 C07AF5EE 		vcmpe.f32	s15, #0	@ _15
 4121 11cc 10FAF1EE 		vmrs	APSR_nzcv, FPSCR
 4122              	@ armwave.c:580:             v = (uint8_t)(CLAMP(level + noise, 0.0f, 1.0f) * 255);
 4123              		.loc 1 580 17 view .LVU1127
 4124 11d0 0020A0D3 		movle	r2, #0	@ iftmp.27_32,
 4125              	@ armwave.c:580:             v = (uint8_t)(CLAMP(level + noise, 0.0f, 1.0f) * 255);
 4126              		.loc 1 580 27 view .LVU1128
 4127 11d4 080000DA 		ble	.L265		@,
 4128              	@ armwave.c:580:             v = (uint8_t)(CLAMP(level + noise, 0.0f, 1.0f) * 255);
 4129              		.loc 1 580 17 discriminator 1 view .LVU1129
 4130 11d8 1C7A9FED 		vldr.32	s14, .L288+24	@ tmp164,
 4131 11dc C77AF4EE 		vcmpe.f32	s15, s14	@ _15, tmp164
 4132 11e0 10FAF1EE 		vmrs	APSR_nzcv, FPSCR
 4133              	@ armwave.c:580:             v = (uint8_t)(CLAMP(level + noise, 0.0f, 1.0f) * 255);
 4134              		.loc 1 580 60 discriminator 1 view .LVU1130
 4135 11e4 1A7A9F4D 		vldrmi.32	s14, .L288+28	@ tmp166,
 4136              	@ armwave.c:580:             v = (uint8_t)(CLAMP(level + noise, 0.0f, 1.0f) * 255);
 4137              		.loc 1 580 17 discriminator 1 view .LVU1131
 4138 11e8 FF20A053 		movpl	r2, #255	@ iftmp.27_32,
 4139              	@ armwave.c:580:             v = (uint8_t)(CLAMP(level + noise, 0.0f, 1.0f) * 255);
 4140              		.loc 1 580 60 discriminator 1 view .LVU1132
 4141 11ec 877A674E 		vmulmi.f32	s15, s15, s14	@ tmp165, _15, tmp166
 4142              	@ armwave.c:580:             v = (uint8_t)(CLAMP(level + noise, 0.0f, 1.0f) * 255);
 4143              		.loc 1 580 17 discriminator 1 view .LVU1133
 4144 11f0 E77AFC4E 		vcvtmi.u32.f32	s15, s15	@ tmp168, tmp165
 4145 11f4 017ACD4D 		vstrmi.32	s15, [sp, #4]	@ int	@ tmp168, %sfp
 4146 11f8 0420DD45 		ldrbmi	r2, [sp, #4]	@ zero_extendqisi2	@ iftmp.27_32, %sfp
 4147              	.L265:
 4148              	.LVL311:
 581:armwave.c     ****             g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_stride)] = v;
 4149              		.loc 1 581 13 is_stmt 1 discriminator 12 view .LVU1134
 4150              	@ armwave.c:581:             g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_stride)
 4151              		.loc 1 581 53 is_stmt 0 discriminator 12 view .LVU1135
 4152 11fc 283095E5 		ldr	r3, [r5, #40]	@ g_armwave_state.wave_stride, g_armwave_state.wave_stride
 4153              	@ armwave.c:581:             g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_stride)
 4154              		.loc 1 581 85 discriminator 12 view .LVU1136
 4155 1200 181095E5 		ldr	r1, [r5, #24]	@ g_armwave_state.test_wave_buffer, g_armwave_state.test_wave_buffer
 4156 1204 931623E0 		mla	r3, r3, r6, r1	@ tmp174, g_armwave_state.wave_stride, w, g_armwave_state.test_wave_buffer
 4157 1208 0420C3E7 		strb	r2, [r3, r4]	@ iftmp.27_32, *_21
 4158              	@ armwave.c:557:         for(x = 0; x < g_armwave_state.wave_length; x++) {
 557:armwave.c     ****             noise  = ((rand() & 0xffff) * noise_fraction);
 4159              		.loc 1 557 39 discriminator 12 view .LVU1137
 4160 120c 403095E5 		ldr	r3, [r5, #64]	@ prephitmp_70, g_armwave_state.wave_length
 4161              	@ armwave.c:557:         for(x = 0; x < g_armwave_state.wave_length; x++) {
 557:armwave.c     ****             noise  = ((rand() & 0xffff) * noise_fraction);
 4162              		.loc 1 557 54 discriminator 12 view .LVU1138
 4163 1210 014084E2 		add	r4, r4, #1	@ x, x,
 4164              	.LVL312:
 4165              	@ armwave.c:557:         for(x = 0; x < g_armwave_state.wave_length; x++) {
 557:armwave.c     ****             noise  = ((rand() & 0xffff) * noise_fraction);
 4166              		.loc 1 557 9 discriminator 12 view .LVU1139
 4167 1214 040053E1 		cmp	r3, r4	@ prephitmp_70, x
 4168 1218 C9FFFF8A 		bhi	.L268		@,
 4169 121c 2C2095E5 		ldr	r2, [r5, #44]	@ prephitmp_33, g_armwave_state.waves
 4170              	.LVL313:
 4171              	.L269:
 4172              	@ armwave.c:556:     for(w = 0; w < g_armwave_state.waves; w++) {
 556:armwave.c     ****         for(x = 0; x < g_armwave_state.wave_length; x++) {
 4173              		.loc 1 556 44 discriminator 2 view .LVU1140
 4174 1220 016086E2 		add	r6, r6, #1	@ w, w,
 4175              	.LVL314:
 4176              	@ armwave.c:556:     for(w = 0; w < g_armwave_state.waves; w++) {
 556:armwave.c     ****         for(x = 0; x < g_armwave_state.wave_length; x++) {
 4177              		.loc 1 556 5 discriminator 2 view .LVU1141
 4178 1224 020056E1 		cmp	r6, r2	@ w, prephitmp_33
 4179 1228 C0FFFF3A 		bcc	.L262		@,
 4180              	.LVL315:
 4181              	.L260:
 4182              	@ armwave.c:584: }
 582:armwave.c     ****         }
 583:armwave.c     ****     }
 584:armwave.c     **** }
 4183              		.loc 1 584 1 view .LVU1142
 4184 122c 08D08DE2 		add	sp, sp, #8	@,,
 4185              		.cfi_def_cfa_offset 56
 4186              		@ sp needed	@
 4187 1230 0A8BBDEC 		vldm	sp!, {d8-d12}	@,
 4188              		.cfi_restore 88
 4189              		.cfi_restore 89
 4190              		.cfi_restore 86
 4191              		.cfi_restore 87
 4192              		.cfi_restore 84
 4193              		.cfi_restore 85
 4194              		.cfi_restore 82
 4195              		.cfi_restore 83
 4196              		.cfi_restore 80
 4197              		.cfi_restore 81
 4198              		.cfi_def_cfa_offset 16
 4199 1234 7080BDE8 		pop	{r4, r5, r6, pc}	@
 4200              	.L289:
 4201              		.align	2
 4202              	.L288:
 4203 1238 CDCC4C3F 		.word	1061997773
 4204 123c 0000403F 		.word	1061158912
 4205 1240 CDCC4C3E 		.word	1045220557
 4206 1244 0000003F 		.word	1056964608
 4207 1248 0000803E 		.word	1048576000
 4208 124c 00004040 		.word	1077936128
 4209 1250 0000803F 		.word	1065353216
 4210 1254 00007F43 		.word	1132396544
 4211 1258 00000000 		.word	g_armwave_state
 4212              		.cfi_endproc
 4213              	.LFE77:
 4215              		.align	2
 4216              		.global	armwave_cleanup
 4217              		.syntax unified
 4218              		.arm
 4219              		.fpu vfp
 4221              	armwave_cleanup:
 4222              	.LFB78:
 585:armwave.c     **** 
 586:armwave.c     **** /*
 587:armwave.c     ****  * Free all buffers and set to NULL, ready to be reinitialised or stopped.
 588:armwave.c     ****  */
 589:armwave.c     **** void armwave_cleanup()
 590:armwave.c     **** {
 4223              		.loc 1 590 1 is_stmt 1 view -0
 4224              		.cfi_startproc
 4225              		@ args = 0, pretend = 0, frame = 0
 4226              		@ frame_needed = 0, uses_anonymous_args = 0
 591:armwave.c     ****     free(g_armwave_state.out_pixbuf);
 4227              		.loc 1 591 5 view .LVU1144
 4228              	@ armwave.c:590: {
 590:armwave.c     ****     free(g_armwave_state.out_pixbuf);
 4229              		.loc 1 590 1 is_stmt 0 view .LVU1145
 4230 125c 10402DE9 		push	{r4, lr}	@
 4231              		.cfi_def_cfa_offset 8
 4232              		.cfi_offset 4, -8
 4233              		.cfi_offset 14, -4
 4234              	@ armwave.c:591:     free(g_armwave_state.out_pixbuf);
 4235              		.loc 1 591 25 view .LVU1146
 4236 1260 34409FE5 		ldr	r4, .L292	@ tmp114,
 4237              	@ armwave.c:591:     free(g_armwave_state.out_pixbuf);
 4238              		.loc 1 591 5 view .LVU1147
 4239 1264 5C0094E5 		ldr	r0, [r4, #92]	@, g_armwave_state.out_pixbuf
 4240 1268 FEFFFFEB 		bl	free		@
 4241              	.LVL316:
 592:armwave.c     ****     free(g_armwave_state.ch1_buffer);
 4242              		.loc 1 592 5 is_stmt 1 view .LVU1148
 4243 126c 040094E5 		ldr	r0, [r4, #4]	@, g_armwave_state.ch1_buffer
 4244 1270 FEFFFFEB 		bl	free		@
 4245              	.LVL317:
 593:armwave.c     ****     free(g_armwave_state.xcoord_to_xpixel);
 4246              		.loc 1 593 5 view .LVU1149
 4247 1274 780094E5 		ldr	r0, [r4, #120]	@, g_armwave_state.xcoord_to_xpixel
 4248 1278 FEFFFFEB 		bl	free		@
 4249              	.LVL318:
 594:armwave.c     ****     free(g_armwave_state.test_wave_buffer);
 4250              		.loc 1 594 5 view .LVU1150
 4251 127c 180094E5 		ldr	r0, [r4, #24]	@, g_armwave_state.test_wave_buffer
 4252 1280 FEFFFFEB 		bl	free		@
 4253              	.LVL319:
 595:armwave.c     **** 
 596:armwave.c     ****     g_armwave_state.out_pixbuf = NULL;
 4254              		.loc 1 596 5 view .LVU1151
 4255              	@ armwave.c:596:     g_armwave_state.out_pixbuf = NULL;
 4256              		.loc 1 596 32 is_stmt 0 view .LVU1152
 4257 1284 0030A0E3 		mov	r3, #0	@ tmp123,
 4258 1288 5C3084E5 		str	r3, [r4, #92]	@ tmp123, g_armwave_state.out_pixbuf
 597:armwave.c     ****     g_armwave_state.ch1_buffer = NULL;
 4259              		.loc 1 597 5 is_stmt 1 view .LVU1153
 4260              	@ armwave.c:597:     g_armwave_state.ch1_buffer = NULL;
 4261              		.loc 1 597 32 is_stmt 0 view .LVU1154
 4262 128c 043084E5 		str	r3, [r4, #4]	@ tmp123, g_armwave_state.ch1_buffer
 598:armwave.c     ****     g_armwave_state.xcoord_to_xpixel = NULL;
 4263              		.loc 1 598 5 is_stmt 1 view .LVU1155
 4264              	@ armwave.c:598:     g_armwave_state.xcoord_to_xpixel = NULL;
 4265              		.loc 1 598 38 is_stmt 0 view .LVU1156
 4266 1290 783084E5 		str	r3, [r4, #120]	@ tmp123, g_armwave_state.xcoord_to_xpixel
 599:armwave.c     ****     g_armwave_state.test_wave_buffer = NULL;
 4267              		.loc 1 599 5 is_stmt 1 view .LVU1157
 4268              	@ armwave.c:599:     g_armwave_state.test_wave_buffer = NULL;
 4269              		.loc 1 599 38 is_stmt 0 view .LVU1158
 4270 1294 183084E5 		str	r3, [r4, #24]	@ tmp123, g_armwave_state.test_wave_buffer
 4271              	@ armwave.c:600: }
 600:armwave.c     **** }
 4272              		.loc 1 600 1 view .LVU1159
 4273 1298 1080BDE8 		pop	{r4, pc}	@
 4274              	.L293:
 4275              		.align	2
 4276              	.L292:
 4277 129c 00000000 		.word	g_armwave_state
 4278              		.cfi_endproc
 4279              	.LFE78:
 4281              		.comm	gamma_table,256,4
 4282              		.comm	g_armwave_state,124,4
 4283              		.section	.rodata
 4284              		.align	2
 4285              		.set	.LANCHOR0,. + 0
 4288              	__PRETTY_FUNCTION__.17093:
 4289 0000 61726D77 		.ascii	"armwave_fill_pixbuf_256\000"
 4289      6176655F 
 4289      66696C6C 
 4289      5F706978 
 4289      6275665F 
 4292              	__PRETTY_FUNCTION__.17126:
 4293 0018 61726D77 		.ascii	"armwave_fill_pixbuf_scaled\000"
 4293      6176655F 
 4293      66696C6C 
 4293      5F706978 
 4293      6275665F 
 4294 0033 00       		.space	1
 4297              	__PRETTY_FUNCTION__.17148:
 4298 0034 61726D77 		.ascii	"armwave_setup_render\000"
 4298      6176655F 
 4298      73657475 
 4298      705F7265 
 4298      6E646572 
 4299 0049 000000   		.space	3
 4302              	__PRETTY_FUNCTION__.17155:
 4303 004c 61726D77 		.ascii	"armwave_set_wave_pointer\000"
 4303      6176655F 
 4303      7365745F 
 4303      77617665 
 4303      5F706F69 
 4304 0065 000000   		.space	3
 4307              	__PRETTY_FUNCTION__.17161:
 4308 0068 61726D77 		.ascii	"armwave_set_wave_pointer_u32\000"
 4308      6176655F 
 4308      7365745F 
 4308      77617665 
 4308      5F706F69 
 4309              		.section	.rodata.str1.4,"aMS",%progbits,1
 4310              		.align	2
 4311              	.LC0:
 4312 0000 76302E30 		.ascii	"v0.0.1\000"
 4312      2E3100
 4313 0007 00       		.space	1
 4314              	.LC1:
 4315 0008 61726D77 		.ascii	"armwave version: %s\012\000"
 4315      61766520 
 4315      76657273 
 4315      696F6E3A 
 4315      2025730A 
 4316 001d 000000   		.space	3
 4317              	.LC2:
 4318 0020 61726D77 		.ascii	"armwave.c\000"
 4318      6176652E 
 4318      6300
 4319 002a 0000     		.space	2
 4320              	.LC3:
 4321 002c 6F75745F 		.ascii	"out_buffer != NULL\000"
 4321      62756666 
 4321      65722021 
 4321      3D204E55 
 4321      4C4C00
 4322 003f 00       		.space	1
 4323              	.LC4:
 4324 0040 733D2564 		.ascii	"s=%d e=%d w=%d ws=%d tw=%d th=%d rf=0x%08x\012\000"
 4324      20653D25 
 4324      6420773D 
 4324      25642077 
 4324      733D2564 
 4325              	.LC5:
 4326 006c 73746172 		.ascii	"start_point < end_point\000"
 4326      745F706F 
 4326      696E7420 
 4326      3C20656E 
 4326      645F706F 
 4327              	.LC6:
 4328 0084 63685F62 		.ascii	"ch_buff_size=%d\012\000"
 4328      7566665F 
 4328      73697A65 
 4328      3D25640A 
 4328      00
 4329 0095 000000   		.space	3
 4330              	.LC7:
 4331 0098 675F6172 		.ascii	"g_armwave_state.ch1_buffer != NULL\000"
 4331      6D776176 
 4331      655F7374 
 4331      6174652E 
 4331      6368315F 
 4332 00bb 00       		.space	1
 4333              	.LC8:
 4334 00bc 675F6172 		.ascii	"g_armwave_state.xcoord_to_xpixel != NULL\000"
 4334      6D776176 
 4334      655F7374 
 4334      6174652E 
 4334      78636F6F 
 4335 00e5 000000   		.space	3
 4336              	.LC9:
 4337 00e8 50747273 		.ascii	"Ptrs: 0x%08x 0x%08x 0x%08x 0x%08x \012\000"
 4337      3A203078 
 4337      25303878 
 4337      20307825 
 4337      30387820 
 4338              	.LC10:
 4339 010c 77617665 		.ascii	"wave_buffer != NULL\000"
 4339      5F627566 
 4339      66657220 
 4339      213D204E 
 4339      554C4C00 
 4340              	.LC11:
 4341 0120 77617665 		.ascii	"wave_buffer_ptr != 0\000"
 4341      5F627566 
 4341      6665725F 
 4341      70747220 
 4341      213D2030 
 4342 0135 000000   		.space	3
 4343              	.LC12:
 4344 0138 776200   		.ascii	"wb\000"
 4345 013b 00       		.space	1
 4346              	.LC13:
 4347 013c 50330A00 		.ascii	"P3\012\000"
 4348              	.LC14:
 4349 0140 25642025 		.ascii	"%d %d\012\000"
 4349      640A00
 4350 0147 00       		.space	1
 4351              	.LC15:
 4352 0148 3235350A 		.ascii	"255\012\000"
 4352      00
 4353 014d 000000   		.space	3
 4354              	.LC16:
 4355 0150 25336420 		.ascii	"%3d %3d %3d\012\000"
 4355      25336420 
 4355      2533640A 
 4355      00
 4356 015d 000000   		.space	3
 4357              	.LC17:
 4358 0160 61726D77 		.ascii	"armwave_test_buffer_alloc: failed to allocate test "
 4358      6176655F 
 4358      74657374 
 4358      5F627566 
 4358      6665725F 
 4359 0193 77617665 		.ascii	"wave buffer (%d bytes)\012\000"
 4359      20627566 
 4359      66657220 
 4359      28256420 
 4359      62797465 
 4360 01ab 00       		.space	1
 4361              	.LC18:
 4362 01ac 61726D77 		.ascii	"armwave_fill_pixbuf_into_pybuffer: PyObject_GetBuff"
 4362      6176655F 
 4362      66696C6C 
 4362      5F706978 
 4362      6275665F 
 4363 01df 65722829 		.ascii	"er() failed, returning PyFalse\000"
 4363      20666169 
 4363      6C65642C 
 4363      20726574 
 4363      75726E69 
 4364              		.text
 4365              	.Letext0:
 4366              		.file 3 "/usr/lib/gcc/arm-linux-gnueabihf/8/include/stddef.h"
 4367              		.file 4 "/usr/include/arm-linux-gnueabihf/bits/types.h"
 4368              		.file 5 "/usr/include/arm-linux-gnueabihf/bits/types/struct_FILE.h"
 4369              		.file 6 "/usr/include/arm-linux-gnueabihf/bits/types/FILE.h"
 4370              		.file 7 "/usr/include/stdio.h"
 4371              		.file 8 "/usr/include/arm-linux-gnueabihf/bits/sys_errlist.h"
 4372              		.file 9 "/usr/include/errno.h"
 4373              		.file 10 "/usr/include/arm-linux-gnueabihf/bits/stdint-intn.h"
 4374              		.file 11 "/usr/include/unistd.h"
 4375              		.file 12 "/usr/include/arm-linux-gnueabihf/bits/getopt_core.h"
 4376              		.file 13 "/usr/include/arm-linux-gnueabihf/bits/stdint-uintn.h"
 4377              		.file 14 "/usr/local/include/python3.8/pyport.h"
 4378              		.file 15 "/usr/include/math.h"
 4379              		.file 16 "/usr/include/arm-linux-gnueabihf/sys/time.h"
 4380              		.file 17 "/usr/include/time.h"
 4381              		.file 18 "/usr/local/include/python3.8/pymem.h"
 4382              		.file 19 "/usr/local/include/python3.8/cpython/object.h"
 4383              		.file 20 "/usr/local/include/python3.8/methodobject.h"
 4384              		.file 21 "/usr/local/include/python3.8/descrobject.h"
 4385              		.file 22 "/usr/local/include/python3.8/pyhash.h"
 4386              		.file 23 "/usr/local/include/python3.8/pydebug.h"
 4387              		.file 24 "/usr/local/include/python3.8/bytearrayobject.h"
 4388              		.file 25 "/usr/local/include/python3.8/bytesobject.h"
 4389              		.file 26 "/usr/local/include/python3.8/unicodeobject.h"
 4390              		.file 27 "/usr/local/include/python3.8/cpython/unicodeobject.h"
 4391              		.file 28 "/usr/local/include/python3.8/longintrepr.h"
 4392              		.file 29 "/usr/local/include/python3.8/longobject.h"
 4393              		.file 30 "/usr/local/include/python3.8/boolobject.h"
 4394              		.file 31 "/usr/local/include/python3.8/floatobject.h"
 4395              		.file 32 "/usr/local/include/python3.8/complexobject.h"
 4396              		.file 33 "/usr/local/include/python3.8/rangeobject.h"
 4397              		.file 34 "/usr/local/include/python3.8/memoryobject.h"
 4398              		.file 35 "/usr/local/include/python3.8/tupleobject.h"
 4399              		.file 36 "/usr/local/include/python3.8/listobject.h"
 4400              		.file 37 "/usr/local/include/python3.8/dictobject.h"
 4401              		.file 38 "/usr/local/include/python3.8/odictobject.h"
 4402              		.file 39 "/usr/local/include/python3.8/enumobject.h"
 4403              		.file 40 "/usr/local/include/python3.8/setobject.h"
 4404              		.file 41 "/usr/local/include/python3.8/moduleobject.h"
 4405              		.file 42 "/usr/local/include/python3.8/funcobject.h"
 4406              		.file 43 "/usr/local/include/python3.8/classobject.h"
 4407              		.file 44 "/usr/local/include/python3.8/fileobject.h"
 4408              		.file 45 "/usr/local/include/python3.8/cpython/fileobject.h"
 4409              		.file 46 "/usr/local/include/python3.8/pycapsule.h"
 4410              		.file 47 "/usr/local/include/python3.8/traceback.h"
 4411              		.file 48 "/usr/local/include/python3.8/sliceobject.h"
 4412              		.file 49 "/usr/local/include/python3.8/cellobject.h"
 4413              		.file 50 "/usr/local/include/python3.8/iterobject.h"
 4414              		.file 51 "/usr/local/include/python3.8/pystate.h"
 4415              		.file 52 "/usr/local/include/python3.8/cpython/pystate.h"
 4416              		.file 53 "/usr/local/include/python3.8/genobject.h"
 4417              		.file 54 "/usr/local/include/python3.8/weakrefobject.h"
 4418              		.file 55 "/usr/local/include/python3.8/structseq.h"
 4419              		.file 56 "/usr/local/include/python3.8/namespaceobject.h"
 4420              		.file 57 "/usr/local/include/python3.8/picklebufobject.h"
 4421              		.file 58 "/usr/local/include/python3.8/codecs.h"
 4422              		.file 59 "/usr/local/include/python3.8/pyerrors.h"
 4423              		.file 60 "/usr/local/include/python3.8/context.h"
 4424              		.file 61 "/usr/local/include/python3.8/modsupport.h"
 4425              		.file 62 "/usr/local/include/python3.8/code.h"
 4426              		.file 63 "/usr/local/include/python3.8/pythonrun.h"
 4427              		.file 64 "/usr/local/include/python3.8/ceval.h"
 4428              		.file 65 "/usr/local/include/python3.8/import.h"
 4429              		.file 66 "/usr/local/include/python3.8/bltinmodule.h"
 4430              		.file 67 "/usr/local/include/python3.8/pyctype.h"
 4431              		.file 68 "/usr/include/malloc.h"
 4432              		.file 69 "armwave.h"
 4433              		.file 70 "/usr/include/stdlib.h"
 4434              		.file 71 "/usr/local/include/python3.8/cpython/abstract.h"
 4435              		.file 72 "/usr/include/assert.h"
 4436              		.file 73 "<built-in>"
 4437              		.file 74 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h"
