   1              		.arch armv6
   2              		.eabi_attribute 28, 1	@ Tag_ABI_VFP_args
   3              		.eabi_attribute 20, 1	@ Tag_ABI_FP_denormal
   4              		.eabi_attribute 21, 1	@ Tag_ABI_FP_exceptions
   5              		.eabi_attribute 23, 3	@ Tag_ABI_FP_number_model
   6              		.eabi_attribute 24, 1	@ Tag_ABI_align8_needed
   7              		.eabi_attribute 25, 1	@ Tag_ABI_align8_preserved
   8              		.eabi_attribute 26, 2	@ Tag_ABI_enum_size
   9              		.eabi_attribute 30, 2	@ Tag_ABI_optimization_goals
  10              		.eabi_attribute 34, 1	@ Tag_CPU_unaligned_access
  11              		.eabi_attribute 18, 4	@ Tag_ABI_PCS_wchar_t
  12              		.file	"armwave.c"
  13              	@ GNU C17 (Raspbian 8.3.0-6+rpi1) version 8.3.0 (arm-linux-gnueabihf)
  14              	@	compiled by GNU C version 8.3.0, GMP version 6.1.2, MPFR version 4.0.2, MPC version 1.1.0, isl ve
  15              	
  16              	@ GGC heuristics: --param ggc-min-expand=81 --param ggc-min-heapsize=95638
  17              	@ options passed:  -I /usr/local/include/python3.8 -imultilib .
  18              	@ -imultiarch arm-linux-gnueabihf armwave.c -mfloat-abi=hard -mfpu=vfp
  19              	@ -mtls-dialect=gnu -marm -march=armv6+fp -auxbase-strip armwave.s -g -O3
  20              	@ -fverbose-asm -fwrapv
  21              	@ options enabled:  -faggressive-loop-optimizations -falign-jumps
  22              	@ -falign-labels -falign-loops -fauto-inc-dec -fbranch-count-reg
  23              	@ -fcaller-saves -fchkp-check-incomplete-type -fchkp-check-read
  24              	@ -fchkp-check-write -fchkp-instrument-calls -fchkp-narrow-bounds
  25              	@ -fchkp-optimize -fchkp-store-bounds -fchkp-use-static-bounds
  26              	@ -fchkp-use-static-const-bounds -fchkp-use-wrappers -fcode-hoisting
  27              	@ -fcombine-stack-adjustments -fcommon -fcompare-elim -fcprop-registers
  28              	@ -fcrossjumping -fcse-follow-jumps -fdefer-pop
  29              	@ -fdelete-null-pointer-checks -fdevirtualize -fdevirtualize-speculatively
  30              	@ -fdwarf2-cfi-asm -fearly-inlining -feliminate-unused-debug-types
  31              	@ -fexpensive-optimizations -fforward-propagate -ffp-int-builtin-inexact
  32              	@ -ffunction-cse -fgcse -fgcse-after-reload -fgcse-lm -fgnu-runtime
  33              	@ -fgnu-unique -fguess-branch-probability -fhoist-adjacent-loads -fident
  34              	@ -fif-conversion -fif-conversion2 -findirect-inlining -finline
  35              	@ -finline-atomics -finline-functions -finline-functions-called-once
  36              	@ -finline-small-functions -fipa-bit-cp -fipa-cp -fipa-cp-clone -fipa-icf
  37              	@ -fipa-icf-functions -fipa-icf-variables -fipa-profile -fipa-pure-const
  38              	@ -fipa-ra -fipa-reference -fipa-sra -fipa-vrp -fira-hoist-pressure
  39              	@ -fira-share-save-slots -fira-share-spill-slots
  40              	@ -fisolate-erroneous-paths-dereference -fivopts -fkeep-static-consts
  41              	@ -fleading-underscore -flifetime-dse -floop-interchange
  42              	@ -floop-unroll-and-jam -flra-remat -flto-odr-type-merging -fmath-errno
  43              	@ -fmerge-constants -fmerge-debug-strings -fmove-loop-invariants
  44              	@ -fomit-frame-pointer -foptimize-sibling-calls -foptimize-strlen
  45              	@ -fpartial-inlining -fpeel-loops -fpeephole -fpeephole2 -fplt
  46              	@ -fpredictive-commoning -fprefetch-loop-arrays -freg-struct-return
  47              	@ -freorder-blocks -freorder-functions -frerun-cse-after-loop
  48              	@ -fsched-critical-path-heuristic -fsched-dep-count-heuristic
  49              	@ -fsched-group-heuristic -fsched-interblock -fsched-last-insn-heuristic
  50              	@ -fsched-pressure -fsched-rank-heuristic -fsched-spec
  51              	@ -fsched-spec-insn-heuristic -fsched-stalled-insns-dep -fschedule-insns
  52              	@ -fschedule-insns2 -fsection-anchors -fsemantic-interposition
  53              	@ -fshow-column -fshrink-wrap -fshrink-wrap-separate -fsigned-zeros
  54              	@ -fsplit-ivs-in-unroller -fsplit-loops -fsplit-paths -fsplit-wide-types
  55              	@ -fssa-backprop -fssa-phiopt -fstdarg-opt -fstore-merging
  56              	@ -fstrict-aliasing -fstrict-volatile-bitfields -fsync-libcalls
  57              	@ -fthread-jumps -ftoplevel-reorder -ftrapping-math -ftree-bit-ccp
  58              	@ -ftree-builtin-call-dce -ftree-ccp -ftree-ch -ftree-coalesce-vars
  59              	@ -ftree-copy-prop -ftree-cselim -ftree-dce -ftree-dominator-opts
  60              	@ -ftree-dse -ftree-forwprop -ftree-fre -ftree-loop-distribute-patterns
  61              	@ -ftree-loop-distribution -ftree-loop-if-convert -ftree-loop-im
  62              	@ -ftree-loop-ivcanon -ftree-loop-optimize -ftree-loop-vectorize
  63              	@ -ftree-parallelize-loops= -ftree-partial-pre -ftree-phiprop -ftree-pre
  64              	@ -ftree-pta -ftree-reassoc -ftree-scev-cprop -ftree-sink
  65              	@ -ftree-slp-vectorize -ftree-slsr -ftree-sra -ftree-switch-conversion
  66              	@ -ftree-tail-merge -ftree-ter -ftree-vrp -funit-at-a-time -funswitch-loops
  67              	@ -fvar-tracking -fvar-tracking-assignments -fverbose-asm -fwrapv
  68              	@ -fzero-initialized-in-bss -marm -mbe32 -mglibc -mlittle-endian
  69              	@ -mpic-data-is-text-relative -msched-prolog -munaligned-access
  70              	@ -mvectorize-with-neon-quad
  71              	
  72              		.text
  73              	.Ltext0:
  74              		.cfi_sections	.debug_frame
  75              		.align	2
  76              		.global	test_create_gamma
  77              		.arch armv6
  78              		.syntax unified
  79              		.arm
  80              		.fpu vfp
  82              	test_create_gamma:
  83              	.LFB57:
  84              		.file 1 "armwave.c"
   1:armwave.c     **** /*
   2:armwave.c     ****  * This file is part of YAOS and is licenced under the MIT Licence.
   3:armwave.c     ****  *
   4:armwave.c     ****  * armwave: an ARM-optimised waveform rendering engine for the Raspberry Pi 3.  
   5:armwave.c     ****  * This library attempts to use NEON tricks and architectural features of the Pi's
   6:armwave.c     ****  * processor to render waveforms damn quickly.
   7:armwave.c     ****  */
   8:armwave.c     **** 
   9:armwave.c     **** #define _GNU_SOURCE
  10:armwave.c     **** 
  11:armwave.c     **** #include <Python.h>
  12:armwave.c     **** 
  13:armwave.c     **** #include <assert.h>
  14:armwave.c     **** #include <ctype.h>
  15:armwave.c     **** #include <stdio.h>
  16:armwave.c     **** #include <stdint.h>
  17:armwave.c     **** #include <stdlib.h>
  18:armwave.c     **** #include <stdbool.h>
  19:armwave.c     **** #include <malloc.h>
  20:armwave.c     **** #include <string.h>
  21:armwave.c     **** #include <math.h>
  22:armwave.c     **** 
  23:armwave.c     **** #include "armwave.h"
  24:armwave.c     **** 
  25:armwave.c     **** #define ARMWAVE_VER  "v0.0.1"
  26:armwave.c     **** 
  27:armwave.c     **** struct armwave_state_t g_armwave_state;
  28:armwave.c     **** 
  29:armwave.c     **** uint8_t gamma_table[256];
  30:armwave.c     **** 
  31:armwave.c     **** /*
  32:armwave.c     ****  * Create a gamma table.
  33:armwave.c     ****  */
  34:armwave.c     **** void test_create_gamma()
  35:armwave.c     **** {
  85              		.loc 1 35 1 view -0
  86              		.cfi_startproc
  87              		@ args = 0, pretend = 0, frame = 0
  88              		@ frame_needed = 0, uses_anonymous_args = 0
  36:armwave.c     ****     int i;
  89              		.loc 1 36 5 view .LVU1
  37:armwave.c     ****     float gamma = 0.90f;
  90              		.loc 1 37 5 view .LVU2
  91              	.LVL0:
  38:armwave.c     **** 
  39:armwave.c     ****     for(i = 0; i < 256; i++) {
  92              		.loc 1 39 5 view .LVU3
  93              	@ armwave.c:35: {
  35:armwave.c     ****     int i;
  94              		.loc 1 35 1 is_stmt 0 view .LVU4
  95 0000 70402DE9 		push	{r4, r5, r6, lr}	@
  96              		.cfi_def_cfa_offset 16
  97              		.cfi_offset 4, -16
  98              		.cfi_offset 5, -12
  99              		.cfi_offset 6, -8
 100              		.cfi_offset 14, -4
 101 0004 068B2DED 		vpush.64	{d8, d9, d10}	@
 102              		.cfi_def_cfa_offset 40
 103              		.cfi_offset 80, -40
 104              		.cfi_offset 81, -36
 105              		.cfi_offset 82, -32
 106              		.cfi_offset 83, -28
 107              		.cfi_offset 84, -24
 108              		.cfi_offset 85, -20
 109 0008 64409FE5 		ldr	r4, .L6+20	@ ivtmp.37,
 110              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 111              		.loc 1 40 32 view .LVU5
 112 000c 17AA9FED 		vldr.32	s20, .L6+16	@ tmp128,
 113              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 114              		.loc 1 40 26 view .LVU6
 115 0010 129B9FED 		vldr.64	d9, .L6	@ tmp135,
 116              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 117              		.loc 1 40 49 view .LVU7
 118 0014 138B9FED 		vldr.64	d8, .L6+8	@ tmp131,
 119 0018 015084E2 		add	r5, r4, #1	@ _25, ivtmp.37,
 120 001c 016C84E2 		add	r6, r4, #256	@ _26, ivtmp.37,
 121 0020 015065E2 		rsb	r5, r5, #1	@ tmp134, _25,
 122              	.LVL1:
 123              	.L2:
 124              		.loc 1 40 9 is_stmt 1 discriminator 3 view .LVU8
 125              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 126              		.loc 1 40 32 is_stmt 0 discriminator 3 view .LVU9
 127 0024 043085E0 		add	r3, r5, r4	@ tmp125, tmp134, ivtmp.37
 128              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 129              		.loc 1 40 26 discriminator 3 view .LVU10
 130 0028 491BB0EE 		vmov.f64	d1, d9	@, tmp135
 131              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 132              		.loc 1 40 32 discriminator 3 view .LVU11
 133 002c 903A07EE 		vmov	s15, r3	@ int	@ tmp125, tmp125
 134 0030 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp126, tmp125
 135 0034 8A0A87EE 		vdiv.f32	s0, s15, s20	@ tmp127, tmp126, tmp128
 136              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 137              		.loc 1 40 26 discriminator 3 view .LVU12
 138 0038 C00AB7EE 		vcvt.f64.f32	d0, s0	@, tmp127
 139 003c FEFFFFEB 		bl	pow		@
 140              	.LVL2:
 141              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 142              		.loc 1 40 49 discriminator 3 view .LVU13
 143 0040 080B20EE 		vmul.f64	d0, d0, d8	@ tmp130,, tmp131
 144              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 145              		.loc 1 40 24 discriminator 3 view .LVU14
 146 0044 C07BFCEE 		vcvt.u32.f64	s15, d0	@ tmp132, tmp130
 147 0048 903A17EE 		vmov	r3, s15	@ int	@ tmp132, tmp132
 148 004c 0130E4E5 		strb	r3, [r4, #1]!	@ tmp132, MEM[base: _24, offset: 0B]
 149              	.LVL3:
 150              	@ armwave.c:39:     for(i = 0; i < 256; i++) {
  39:armwave.c     ****         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 151              		.loc 1 39 5 discriminator 3 view .LVU15
 152 0050 060054E1 		cmp	r4, r6	@ ivtmp.37, _26
 153 0054 F2FFFF1A 		bne	.L2		@,
 154              	@ armwave.c:42: }
  41:armwave.c     ****     }
  42:armwave.c     **** }
 155              		.loc 1 42 1 view .LVU16
 156 0058 068BBDEC 		vldm	sp!, {d8-d10}	@,
 157              		.cfi_restore 84
 158              		.cfi_restore 85
 159              		.cfi_restore 82
 160              		.cfi_restore 83
 161              		.cfi_restore 80
 162              		.cfi_restore 81
 163              		.cfi_def_cfa_offset 16
 164 005c 7080BDE8 		pop	{r4, r5, r6, pc}	@
 165              	.LVL4:
 166              	.L7:
 167              		.loc 1 42 1 view .LVU17
 168              		.align	3
 169              	.L6:
 170 0060 000000C0 		.word	-1073741824
 171 0064 CCCCEC3F 		.word	1072483532
 172 0068 00000000 		.word	0
 173 006c 00E06F40 		.word	1081073664
 174 0070 00007F43 		.word	1132396544
 175 0074 FFFFFFFF 		.word	gamma_table-1
 176              		.cfi_endproc
 177              	.LFE57:
 179              		.align	2
 180              		.global	armwave_init
 181              		.syntax unified
 182              		.arm
 183              		.fpu vfp
 185              	armwave_init:
 186              	.LFB58:
  43:armwave.c     **** 
  44:armwave.c     **** /*
  45:armwave.c     ****  * Initialise things.  STUB, mostly.
  46:armwave.c     ****  */
  47:armwave.c     **** void armwave_init()
  48:armwave.c     **** {
 187              		.loc 1 48 1 is_stmt 1 view -0
 188              		.cfi_startproc
 189              		@ args = 0, pretend = 0, frame = 0
 190              		@ frame_needed = 0, uses_anonymous_args = 0
 191              		@ link register save eliminated.
  49:armwave.c     ****     g_armwave_state.flags = 0;
 192              		.loc 1 49 5 view .LVU19
 193              	@ armwave.c:49:     g_armwave_state.flags = 0;
 194              		.loc 1 49 27 is_stmt 0 view .LVU20
 195 0078 10309FE5 		ldr	r3, .L9	@ tmp110,
 196 007c 0020A0E3 		mov	r2, #0	@ tmp111,
 197              	@ armwave.c:51:     printf("armwave version: %s\n", ARMWAVE_VER);
  50:armwave.c     **** 
  51:armwave.c     ****     printf("armwave version: %s\n", ARMWAVE_VER);
 198              		.loc 1 51 5 view .LVU21
 199 0080 0C109FE5 		ldr	r1, .L9+4	@,
 200 0084 0C009FE5 		ldr	r0, .L9+8	@,
 201              	@ armwave.c:49:     g_armwave_state.flags = 0;
  49:armwave.c     ****     g_armwave_state.flags = 0;
 202              		.loc 1 49 27 view .LVU22
 203 0088 002083E5 		str	r2, [r3]	@ tmp111, g_armwave_state.flags
 204              		.loc 1 51 5 is_stmt 1 view .LVU23
 205 008c FEFFFFEA 		b	printf		@
 206              	.LVL5:
 207              	.L10:
 208              		.align	2
 209              	.L9:
 210 0090 00000000 		.word	g_armwave_state
 211 0094 00000000 		.word	.LC0
 212 0098 08000000 		.word	.LC1
 213              		.cfi_endproc
 214              	.LFE58:
 216              		.align	2
 217              		.global	render_nonaa_to_buffer_1ch_slice
 218              		.syntax unified
 219              		.arm
 220              		.fpu vfp
 222              	render_nonaa_to_buffer_1ch_slice:
 223              	.LVL6:
 224              	.LFB59:
  52:armwave.c     **** }
  53:armwave.c     **** 
  54:armwave.c     **** /*
  55:armwave.c     ****  * 1ch renderer, renders up to slice-height buffer with X-coord of each waveaccess
  56:armwave.c     ****  * pre-computed.
  57:armwave.c     ****  *
  58:armwave.c     ****  * @param    slice_y        Slice to render at
  59:armwave.c     ****  * @param    height         Number of wave points to render (adjust for performance, 
  60:armwave.c     ****  *                          accounting for cache behaviour, etc.)
  61:armwave.c     ****  */
  62:armwave.c     **** void render_nonaa_to_buffer_1ch_slice(uint32_t slice_y, uint32_t height)
  63:armwave.c     **** {
 225              		.loc 1 63 1 view -0
 226              		.cfi_startproc
 227              		@ args = 0, pretend = 0, frame = 16
 228              		@ frame_needed = 0, uses_anonymous_args = 0
  64:armwave.c     ****     int yy, ys, w, scale_value;
 229              		.loc 1 64 5 view .LVU25
  65:armwave.c     ****     uint32_t value, word;
 230              		.loc 1 65 5 view .LVU26
  66:armwave.c     ****     uint8_t *wave_base;
 231              		.loc 1 66 5 view .LVU27
  67:armwave.c     ****     bufftyp_t *write_buffer_base;
 232              		.loc 1 67 5 view .LVU28
  68:armwave.c     ****     bufftyp_t *write_buffer;
 233              		.loc 1 68 5 view .LVU29
  69:armwave.c     **** 
  70:armwave.c     ****     //write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.bitdepth_height);
  71:armwave.c     ****     write_buffer_base = g_armwave_state.ch1_buffer + (((slice_y * g_armwave_state.cmp_x_bitdepth_sc
 234              		.loc 1 71 5 view .LVU30
 235              	@ armwave.c:63: {
  63:armwave.c     ****     int yy, ys, w, scale_value;
 236              		.loc 1 63 1 is_stmt 0 view .LVU31
 237 009c F04F2DE9 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}	@
 238              		.cfi_def_cfa_offset 36
 239              		.cfi_offset 4, -36
 240              		.cfi_offset 5, -32
 241              		.cfi_offset 6, -28
 242              		.cfi_offset 7, -24
 243              		.cfi_offset 8, -20
 244              		.cfi_offset 9, -16
 245              		.cfi_offset 10, -12
 246              		.cfi_offset 11, -8
 247              		.cfi_offset 14, -4
 248 00a0 0150A0E1 		mov	r5, r1	@ height, height
 249              	@ armwave.c:71:     write_buffer_base = g_armwave_state.ch1_buffer + (((slice_y * g_armwave_state.c
 250              		.loc 1 71 40 view .LVU32
 251 00a4 54619FE5 		ldr	r6, .L21	@ tmp191,
 252              	@ armwave.c:63: {
  63:armwave.c     ****     int yy, ys, w, scale_value;
 253              		.loc 1 63 1 view .LVU33
 254 00a8 2CD04DE2 		sub	sp, sp, #44	@,,
 255              		.cfi_def_cfa_offset 80
 256              	@ armwave.c:63: {
  63:armwave.c     ****     int yy, ys, w, scale_value;
 257              		.loc 1 63 1 view .LVU34
 258 00ac 0070A0E1 		mov	r7, r0	@ slice_y, slice_y
 259              	@ armwave.c:71:     write_buffer_base = g_armwave_state.ch1_buffer + (((slice_y * g_armwave_state.c
 260              		.loc 1 71 82 view .LVU35
 261 00b0 241096E5 		ldr	r1, [r6, #36]	@ _2, g_armwave_state.cmp_x_bitdepth_scale
 262              	.LVL7:
 263              	@ armwave.c:71:     write_buffer_base = g_armwave_state.ch1_buffer + (((slice_y * g_armwave_state.c
 264              		.loc 1 71 147 view .LVU36
 265 00b4 403096E5 		ldr	r3, [r6, #64]	@ _5, g_armwave_state.bitdepth_height
 266              	@ armwave.c:71:     write_buffer_base = g_armwave_state.ch1_buffer + (((slice_y * g_armwave_state.c
 267              		.loc 1 71 40 view .LVU37
 268 00b8 044096E5 		ldr	r4, [r6, #4]	@ _1, g_armwave_state.ch1_buffer
 269              	@ armwave.c:71:     write_buffer_base = g_armwave_state.ch1_buffer + (((slice_y * g_armwave_state.c
 270              		.loc 1 71 65 view .LVU38
 271 00bc 900102E0 		mul	r2, r0, r1	@ tmp194, slice_y, _2
 272              	@ armwave.c:73:     printf("wb=0x%08x b=0x%08x ch1=0x%08x off=%d slice_y=%d height=%d scale=%d bitd
  72:armwave.c     **** 
  73:armwave.c     ****     printf("wb=0x%08x b=0x%08x ch1=0x%08x off=%d slice_y=%d height=%d scale=%d bitdepth_height=%d\n
 273              		.loc 1 73 5 view .LVU39
 274 00c0 10308DE5 		str	r3, [sp, #16]	@ _5,
 275 00c4 21008DE9 		stmib	sp, {r0, r5}	@,,
 276              	@ armwave.c:71:     write_buffer_base = g_armwave_state.ch1_buffer + (((slice_y * g_armwave_state.c
  71:armwave.c     **** 
 277              		.loc 1 71 105 view .LVU40
 278 00c8 2228A0E1 		lsr	r2, r2, #16	@ tmp195, tmp194,
 279              	@ armwave.c:73:     printf("wb=0x%08x b=0x%08x ch1=0x%08x off=%d slice_y=%d height=%d scale=%d bitd
 280              		.loc 1 73 5 view .LVU41
 281 00cc 0C108DE5 		str	r1, [sp, #12]	@ _2,
 282              	@ armwave.c:71:     write_buffer_base = g_armwave_state.ch1_buffer + (((slice_y * g_armwave_state.c
  71:armwave.c     **** 
 283              		.loc 1 71 52 view .LVU42
 284 00d0 930202E0 		mul	r2, r3, r2	@ tmp196, _5, tmp195
 285              	@ armwave.c:73:     printf("wb=0x%08x b=0x%08x ch1=0x%08x off=%d slice_y=%d height=%d scale=%d bitd
 286              		.loc 1 73 5 view .LVU43
 287 00d4 0430A0E1 		mov	r3, r4	@, _1
 288 00d8 24019FE5 		ldr	r0, .L21+4	@,
 289              	.LVL8:
 290              	@ armwave.c:71:     write_buffer_base = g_armwave_state.ch1_buffer + (((slice_y * g_armwave_state.c
  71:armwave.c     **** 
 291              		.loc 1 71 52 view .LVU44
 292 00dc 8220A0E1 		lsl	r2, r2, #1	@ _8, tmp196,
 293              	@ armwave.c:71:     write_buffer_base = g_armwave_state.ch1_buffer + (((slice_y * g_armwave_state.c
  71:armwave.c     **** 
 294              		.loc 1 71 23 view .LVU45
 295 00e0 024084E0 		add	r4, r4, r2	@ write_buffer_base, _1, _8
 296              	.LVL9:
 297              		.loc 1 73 5 is_stmt 1 view .LVU46
 298 00e4 C220A0E1 		asr	r2, r2, #1	@ tmp201, _8,
 299 00e8 00208DE5 		str	r2, [sp]	@ tmp201,
 300 00ec 0420A0E1 		mov	r2, r4	@, write_buffer_base
 301 00f0 141096E5 		ldr	r1, [r6, #20]	@, g_armwave_state.wave_buffer
 302 00f4 FEFFFFEB 		bl	printf		@
 303              	.LVL10:
  74:armwave.c     ****         g_armwave_state.wave_buffer, write_buffer_base, g_armwave_state.ch1_buffer, \
  75:armwave.c     ****         write_buffer_base - g_armwave_state.ch1_buffer, slice_y, height, g_armwave_state.cmp_x_bitd
  76:armwave.c     ****         g_armwave_state.bitdepth_height);
  77:armwave.c     **** 
  78:armwave.c     ****     // roll through each waveform
  79:armwave.c     ****     for(w = 0; w < g_armwave_state.waves; w++) {
 304              		.loc 1 79 5 view .LVU47
 305              	@ armwave.c:79:     for(w = 0; w < g_armwave_state.waves; w++) {
 306              		.loc 1 79 35 is_stmt 0 view .LVU48
 307 00f8 383096E5 		ldr	r3, [r6, #56]	@ _91, g_armwave_state.waves
 308              	@ armwave.c:79:     for(w = 0; w < g_armwave_state.waves; w++) {
 309              		.loc 1 79 5 view .LVU49
 310 00fc 000053E3 		cmp	r3, #0	@ _91,
 311              	@ armwave.c:79:     for(w = 0; w < g_armwave_state.waves; w++) {
 312              		.loc 1 79 35 view .LVU50
 313 0100 20308DE5 		str	r3, [sp, #32]	@ _91, %sfp
 314              	@ armwave.c:79:     for(w = 0; w < g_armwave_state.waves; w++) {
 315              		.loc 1 79 5 view .LVU51
 316 0104 3B0000DA 		ble	.L11		@,
 317              	@ armwave.c:80:         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wa
  80:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 318              		.loc 1 80 81 view .LVU52
 319 0108 343096E5 		ldr	r3, [r6, #52]	@ _15, g_armwave_state.wave_stride
 320 010c 000055E3 		cmp	r5, #0	@ height,
 321              	@ armwave.c:80:         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wa
 322              		.loc 1 80 36 view .LVU53
 323 0110 14B096E5 		ldr	fp, [r6, #20]	@ _14, g_armwave_state.wave_buffer
 324              	@ armwave.c:103:                     ((((yy + ys) * g_armwave_state.cmp_x_bitdepth_scale) >> AM_XCO
  81:armwave.c     **** 
  82:armwave.c     ****         // roll through y and render the slice into the out buffer
  83:armwave.c     ****         // buffer is rendered rotated by 90 degrees
  84:armwave.c     ****         for(yy = 0; yy < height; yy += 4) {
  85:armwave.c     ****             //printf("w=%d stride=%d sly=%d wave_base=0x%08x yy=%d\n", w, g_armwave_state.wave_stri
  86:armwave.c     **** 
  87:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
  88:armwave.c     **** 
  89:armwave.c     ****             for(ys = 0; ys < 4; ys++) {
  90:armwave.c     ****                 scale_value = word & 0xff;
  91:armwave.c     ****                 
  92:armwave.c     ****                 /*
  93:armwave.c     ****                 // prevents saturating behaviour; we lose two ADC counts.
  94:armwave.c     ****                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  95:armwave.c     ****                     continue;
  96:armwave.c     ****                 */
  97:armwave.c     **** 
  98:armwave.c     ****                 // Keep math in integer where possible.  We compute the X scale and then multiply t
  99:armwave.c     ****                 // base coordinate.  The value of the point then informs us where to write in typic
 100:armwave.c     ****                 // The bonus of this method is that we tend to hit accesses along a 256 byte line. 
 101:armwave.c     ****                 // we set our accumulation buffer to 16 bits.)
 102:armwave.c     ****                 write_buffer = write_buffer_base + \
 103:armwave.c     ****                     ((((yy + ys) * g_armwave_state.cmp_x_bitdepth_scale) >> AM_XCOORD_MULT_SHIFT) *
 325              		.loc 1 103 51 view .LVU54
 326 0114 24E096E5 		ldr	lr, [r6, #36]	@ _64, g_armwave_state.cmp_x_bitdepth_scale
 327              	@ armwave.c:80:         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wa
  80:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 328              		.loc 1 80 81 view .LVU55
 329 0118 24308DE5 		str	r3, [sp, #36]	@ _15, %sfp
 330              	@ armwave.c:103:                     ((((yy + ys) * g_armwave_state.cmp_x_bitdepth_scale) >> AM_XCO
 331              		.loc 1 103 116 view .LVU56
 332 011c 406096E5 		ldr	r6, [r6, #64]	@ _68, g_armwave_state.bitdepth_height
 333 0120 3400000A 		beq	.L11		@,
 334 0124 07B08BE0 		add	fp, fp, r7	@ ivtmp.52, _14, slice_y
 335 0128 00A06BE2 		rsb	r10, fp, #0	@ ivtmp.53, ivtmp.52
 336              	@ armwave.c:79:     for(w = 0; w < g_armwave_state.waves; w++) {
  79:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 337              		.loc 1 79 11 view .LVU57
 338 012c 0030A0E3 		mov	r3, #0	@ w,
 339 0130 1C308DE5 		str	r3, [sp, #28]	@ w, %sfp
 340              	.LVL11:
 341              	.L14:
  80:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 342              		.loc 1 80 9 is_stmt 1 view .LVU58
  84:armwave.c     ****             //printf("w=%d stride=%d sly=%d wave_base=0x%08x yy=%d\n", w, g_armwave_state.wave_stri
 343              		.loc 1 84 9 view .LVU59
 344              	@ armwave.c:79:     for(w = 0; w < g_armwave_state.waves; w++) {
  79:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 345              		.loc 1 79 11 is_stmt 0 view .LVU60
 346 0134 0B80A0E1 		mov	r8, fp	@ ivtmp.45, ivtmp.52
 347 0138 0030A0E3 		mov	r3, #0	@ ivtmp.46,
 348              	.LVL12:
 349              	.L13:
  87:armwave.c     **** 
 350              		.loc 1 87 13 is_stmt 1 view .LVU61
 351              	@ armwave.c:87:             word = *(uint32_t*)(wave_base + yy);
  87:armwave.c     **** 
 352              		.loc 1 87 18 is_stmt 0 view .LVU62
 353 013c 041098E4 		ldr	r1, [r8], #4	@ word, MEM[base: _260, offset: 0B]
 354              	.LVL13:
  89:armwave.c     ****                 scale_value = word & 0xff;
 355              		.loc 1 89 13 is_stmt 1 view .LVU63
  90:armwave.c     ****                 
 356              		.loc 1 90 17 view .LVU64
 102:armwave.c     ****                     ((((yy + ys) * g_armwave_state.cmp_x_bitdepth_scale) >> AM_XCOORD_MULT_SHIFT) *
 357              		.loc 1 102 17 view .LVU65
 104:armwave.c     **** 
 105:armwave.c     ****                 //printf("write_buff=0x%08x value=%d\n", write_buffer, value);
 106:armwave.c     **** 
 107:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 358              		.loc 1 107 17 view .LVU66
 359              	@ armwave.c:103:                     ((((yy + ys) * g_armwave_state.cmp_x_bitdepth_scale) >> AM_XCO
 103:armwave.c     **** 
 360              		.loc 1 103 74 is_stmt 0 view .LVU67
 361 0140 23C8A0E1 		lsr	ip, r3, #16	@ tmp207, ivtmp.46,
 362              	@ armwave.c:103:                     ((((yy + ys) * g_armwave_state.cmp_x_bitdepth_scale) >> AM_XCO
 103:armwave.c     **** 
 363              		.loc 1 103 34 view .LVU68
 364 0144 03308EE0 		add	r3, lr, r3	@ _89, _64, ivtmp.46
 365              	.LVL14:
 366              	@ armwave.c:90:                 scale_value = word & 0xff;
  90:armwave.c     ****                 
 367              		.loc 1 90 29 view .LVU69
 368 0148 7120EFE6 		uxtb	r2, r1	@ scale_value, word
 369              	@ armwave.c:107:                 *(write_buffer + scale_value) += 1;
 370              		.loc 1 107 47 view .LVU70
 371 014c 962C2CE0 		mla	ip, r6, ip, r2	@ tmp210, _68, tmp207, scale_value
 372              	@ armwave.c:108:                 word >>= 8;
 108:armwave.c     ****                 word >>= 8;
 373              		.loc 1 108 22 view .LVU71
 374 0150 2124A0E1 		lsr	r2, r1, #8	@ word, word,
 375              	@ armwave.c:103:                     ((((yy + ys) * g_armwave_state.cmp_x_bitdepth_scale) >> AM_XCO
 103:armwave.c     **** 
 376              		.loc 1 103 74 view .LVU72
 377 0154 2308A0E1 		lsr	r0, r3, #16	@ tmp215, _89,
 378              	@ armwave.c:90:                 scale_value = word & 0xff;
  90:armwave.c     ****                 
 379              		.loc 1 90 29 view .LVU73
 380 0158 7220EFE6 		uxtb	r2, r2	@ scale_value, word
 381              	@ armwave.c:107:                 *(write_buffer + scale_value) += 1;
 107:armwave.c     ****                 word >>= 8;
 382              		.loc 1 107 47 view .LVU74
 383 015c 8CC0A0E1 		lsl	ip, ip, #1	@ tmp211, tmp210,
 384 0160 962020E0 		mla	r0, r6, r0, r2	@ tmp219, _68, tmp215, scale_value
 385              	@ armwave.c:103:                     ((((yy + ys) * g_armwave_state.cmp_x_bitdepth_scale) >> AM_XCO
 103:armwave.c     **** 
 386              		.loc 1 103 34 view .LVU75
 387 0164 03308EE0 		add	r3, lr, r3	@ _113, _64, _89
 388              	@ armwave.c:108:                 word >>= 8;
 389              		.loc 1 108 22 view .LVU76
 390 0168 2128A0E1 		lsr	r2, r1, #16	@ word, word,
 391              	@ armwave.c:107:                 *(write_buffer + scale_value) += 1;
 107:armwave.c     ****                 word >>= 8;
 392              		.loc 1 107 47 view .LVU77
 393 016c BC7094E1 		ldrh	r7, [r4, ip]	@ *_73, *_73
 394              	@ armwave.c:103:                     ((((yy + ys) * g_armwave_state.cmp_x_bitdepth_scale) >> AM_XCO
 103:armwave.c     **** 
 395              		.loc 1 103 74 view .LVU78
 396 0170 2398A0E1 		lsr	r9, r3, #16	@ tmp224, _113,
 397              	@ armwave.c:90:                 scale_value = word & 0xff;
  90:armwave.c     ****                 
 398              		.loc 1 90 29 view .LVU79
 399 0174 7220EFE6 		uxtb	r2, r2	@ scale_value, word
 400              	@ armwave.c:107:                 *(write_buffer + scale_value) += 1;
 107:armwave.c     ****                 word >>= 8;
 401              		.loc 1 107 47 view .LVU80
 402 0178 8000A0E1 		lsl	r0, r0, #1	@ tmp220, tmp219,
 403              	@ armwave.c:103:                     ((((yy + ys) * g_armwave_state.cmp_x_bitdepth_scale) >> AM_XCO
 103:armwave.c     **** 
 404              		.loc 1 103 34 view .LVU81
 405 017c 03308EE0 		add	r3, lr, r3	@ _137, _64, _113
 406              	@ armwave.c:107:                 *(write_buffer + scale_value) += 1;
 107:armwave.c     ****                 word >>= 8;
 407              		.loc 1 107 47 view .LVU82
 408 0180 962922E0 		mla	r2, r6, r9, r2	@ tmp228, _68, tmp224, scale_value
 409 0184 017087E2 		add	r7, r7, #1	@ tmp214, *_73,
 410 0188 BC7084E1 		strh	r7, [r4, ip]	@ movhi	@ tmp214, *_73
 411              		.loc 1 108 17 is_stmt 1 view .LVU83
 412              	.LVL15:
  90:armwave.c     ****                 
 413              		.loc 1 90 17 view .LVU84
 102:armwave.c     ****                     ((((yy + ys) * g_armwave_state.cmp_x_bitdepth_scale) >> AM_XCOORD_MULT_SHIFT) *
 414              		.loc 1 102 17 view .LVU85
 107:armwave.c     ****                 word >>= 8;
 415              		.loc 1 107 17 view .LVU86
 416              	@ armwave.c:103:                     ((((yy + ys) * g_armwave_state.cmp_x_bitdepth_scale) >> AM_XCO
 103:armwave.c     **** 
 417              		.loc 1 103 74 is_stmt 0 view .LVU87
 418 018c 2378A0E1 		lsr	r7, r3, #16	@ tmp233, _137,
 419              	@ armwave.c:107:                 *(write_buffer + scale_value) += 1;
 107:armwave.c     ****                 word >>= 8;
 420              		.loc 1 107 47 view .LVU88
 421 0190 B0C094E1 		ldrh	ip, [r4, r0]	@ *_97, *_97
 422              	@ armwave.c:108:                 word >>= 8;
 423              		.loc 1 108 22 view .LVU89
 424 0194 211CA0E1 		lsr	r1, r1, #24	@ word, word,
 425              	.LVL16:
 426              	@ armwave.c:107:                 *(write_buffer + scale_value) += 1;
 107:armwave.c     ****                 word >>= 8;
 427              		.loc 1 107 47 view .LVU90
 428 0198 8220A0E1 		lsl	r2, r2, #1	@ tmp229, tmp228,
 429 019c 961721E0 		mla	r1, r6, r7, r1	@ tmp236, _68, tmp233, word
 430 01a0 01C08CE2 		add	ip, ip, #1	@ tmp223, *_97,
 431 01a4 B0C084E1 		strh	ip, [r4, r0]	@ movhi	@ tmp223, *_97
 432              		.loc 1 108 17 is_stmt 1 view .LVU91
 433              	.LVL17:
  90:armwave.c     ****                 
 434              		.loc 1 90 17 view .LVU92
 102:armwave.c     ****                     ((((yy + ys) * g_armwave_state.cmp_x_bitdepth_scale) >> AM_XCOORD_MULT_SHIFT) *
 435              		.loc 1 102 17 view .LVU93
 107:armwave.c     ****                 word >>= 8;
 436              		.loc 1 107 17 view .LVU94
 437              	@ armwave.c:107:                 *(write_buffer + scale_value) += 1;
 107:armwave.c     ****                 word >>= 8;
 438              		.loc 1 107 47 is_stmt 0 view .LVU95
 439 01a8 B20094E1 		ldrh	r0, [r4, r2]	@ *_121, *_121
 440 01ac 8110A0E1 		lsl	r1, r1, #1	@ tmp237, tmp236,
 441 01b0 03308EE0 		add	r3, lr, r3	@ ivtmp.46, _64, _137
 442 01b4 010080E2 		add	r0, r0, #1	@ tmp232, *_121,
 443 01b8 B20084E1 		strh	r0, [r4, r2]	@ movhi	@ tmp232, *_121
 444              		.loc 1 108 17 is_stmt 1 view .LVU96
 445              	.LVL18:
  90:armwave.c     ****                 
 446              		.loc 1 90 17 view .LVU97
 102:armwave.c     ****                     ((((yy + ys) * g_armwave_state.cmp_x_bitdepth_scale) >> AM_XCOORD_MULT_SHIFT) *
 447              		.loc 1 102 17 view .LVU98
 107:armwave.c     ****                 word >>= 8;
 448              		.loc 1 107 17 view .LVU99
 449              	@ armwave.c:107:                 *(write_buffer + scale_value) += 1;
 107:armwave.c     ****                 word >>= 8;
 450              		.loc 1 107 47 is_stmt 0 view .LVU100
 451 01bc B12094E1 		ldrh	r2, [r4, r1]	@ *_145, *_145
 452              	@ armwave.c:84:         for(yy = 0; yy < height; yy += 4) {
  84:armwave.c     ****             //printf("w=%d stride=%d sly=%d wave_base=0x%08x yy=%d\n", w, g_armwave_state.wave_stri
 453              		.loc 1 84 9 view .LVU101
 454 01c0 08008AE0 		add	r0, r10, r8	@ tmp241, ivtmp.53, ivtmp.45
 455 01c4 000055E1 		cmp	r5, r0	@ height, tmp241
 456              	@ armwave.c:107:                 *(write_buffer + scale_value) += 1;
 107:armwave.c     ****                 word >>= 8;
 457              		.loc 1 107 47 view .LVU102
 458 01c8 012082E2 		add	r2, r2, #1	@ tmp240, *_145,
 459 01cc B12084E1 		strh	r2, [r4, r1]	@ movhi	@ tmp240, *_145
 460              		.loc 1 108 17 is_stmt 1 view .LVU103
 461              	.LVL19:
 462              	@ armwave.c:84:         for(yy = 0; yy < height; yy += 4) {
  84:armwave.c     ****             //printf("w=%d stride=%d sly=%d wave_base=0x%08x yy=%d\n", w, g_armwave_state.wave_stri
 463              		.loc 1 84 9 is_stmt 0 view .LVU104
 464 01d0 D9FFFF8A 		bhi	.L13		@,
 465              	@ armwave.c:79:     for(w = 0; w < g_armwave_state.waves; w++) {
  79:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 466              		.loc 1 79 44 view .LVU105
 467 01d4 1C309DE5 		ldr	r3, [sp, #28]	@ w, %sfp
 468              	@ armwave.c:79:     for(w = 0; w < g_armwave_state.waves; w++) {
  79:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 469              		.loc 1 79 5 view .LVU106
 470 01d8 20209DE5 		ldr	r2, [sp, #32]	@ _91, %sfp
 471              	@ armwave.c:79:     for(w = 0; w < g_armwave_state.waves; w++) {
  79:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 472              		.loc 1 79 44 view .LVU107
 473 01dc 013083E2 		add	r3, r3, #1	@ w, w,
 474 01e0 1C308DE5 		str	r3, [sp, #28]	@ w, %sfp
 475              	.LVL20:
 476              	@ armwave.c:79:     for(w = 0; w < g_armwave_state.waves; w++) {
  79:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 477              		.loc 1 79 5 view .LVU108
 478 01e4 020053E1 		cmp	r3, r2	@ w, _91
 479 01e8 24309DE5 		ldr	r3, [sp, #36]	@ _15, %sfp
 480              	.LVL21:
  79:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 481              		.loc 1 79 5 view .LVU109
 482 01ec 03B08BE0 		add	fp, fp, r3	@ ivtmp.52, ivtmp.52, _15
  79:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 483              		.loc 1 79 5 view .LVU110
 484 01f0 03A04AE0 		sub	r10, r10, r3	@ ivtmp.53, ivtmp.53, _15
 485 01f4 CEFFFF1A 		bne	.L14		@,
 486              	.LVL22:
 487              	.L11:
 488              	@ armwave.c:112: }
 109:armwave.c     ****             }
 110:armwave.c     ****         }
 111:armwave.c     ****     }
 112:armwave.c     **** }
 489              		.loc 1 112 1 view .LVU111
 490 01f8 2CD08DE2 		add	sp, sp, #44	@,,
 491              		.cfi_def_cfa_offset 36
 492              		@ sp needed	@
 493 01fc F08FBDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}	@
 494              	.LVL23:
 495              	.L22:
 496              		.loc 1 112 1 view .LVU112
 497              		.align	2
 498              	.L21:
 499 0200 00000000 		.word	g_armwave_state
 500 0204 20000000 		.word	.LC2
 501              		.cfi_endproc
 502              	.LFE59:
 504              		.align	2
 505              		.global	armwave_fill_pixbuf_scaled
 506              		.syntax unified
 507              		.arm
 508              		.fpu vfp
 510              	armwave_fill_pixbuf_scaled:
 511              	.LVL24:
 512              	.LFB60:
 113:armwave.c     **** 
 114:armwave.c     **** /*
 115:armwave.c     ****  * Fill a pixbuf with a multiple of a 256-height waveform.
 116:armwave.c     ****  * Rows are repeated as necessary.
 117:armwave.c     ****  */
 118:armwave.c     **** void armwave_fill_pixbuf_scaled(uint32_t *out_buffer)
 119:armwave.c     **** {
 513              		.loc 1 119 1 is_stmt 1 view -0
 514              		.cfi_startproc
 515              		@ args = 0, pretend = 0, frame = 24
 516              		@ frame_needed = 0, uses_anonymous_args = 0
 120:armwave.c     ****     uint32_t xx, yy, ye, y, word, wave_word, painted = 0;
 517              		.loc 1 120 5 view .LVU114
 121:armwave.c     ****     // uint32_t ysub;
 122:armwave.c     ****     int rr, gg, bb, n, nsub, npix, w;
 518              		.loc 1 122 5 view .LVU115
 123:armwave.c     ****     uint8_t r, g, b;
 519              		.loc 1 123 5 view .LVU116
 124:armwave.c     ****     int value; 
 520              		.loc 1 124 5 view .LVU117
 125:armwave.c     ****     // uint8_t row;
 126:armwave.c     ****     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 521              		.loc 1 126 5 view .LVU118
 522              	@ armwave.c:119: {
 119:armwave.c     ****     uint32_t xx, yy, ye, y, word, wave_word, painted = 0;
 523              		.loc 1 119 1 is_stmt 0 view .LVU119
 524 0208 F04F2DE9 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}	@
 525              		.cfi_def_cfa_offset 36
 526              		.cfi_offset 4, -36
 527              		.cfi_offset 5, -32
 528              		.cfi_offset 6, -28
 529              		.cfi_offset 7, -24
 530              		.cfi_offset 8, -20
 531              		.cfi_offset 9, -16
 532              		.cfi_offset 10, -12
 533              		.cfi_offset 11, -8
 534              		.cfi_offset 14, -4
 535              	@ armwave.c:130:     printf("output buffer: 0x%08x\n", out_buffer);
 127:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 128:armwave.c     ****     uint32_t offset;
 129:armwave.c     **** 
 130:armwave.c     ****     printf("output buffer: 0x%08x\n", out_buffer);
 536              		.loc 1 130 5 view .LVU120
 537 020c 0010A0E1 		mov	r1, r0	@, out_buffer
 538              	@ armwave.c:126:     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 126:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 539              		.loc 1 126 15 view .LVU121
 540 0210 1C629FE5 		ldr	r6, .L46	@ tmp255,
 541              	@ armwave.c:119: {
 119:armwave.c     ****     uint32_t xx, yy, ye, y, word, wave_word, painted = 0;
 542              		.loc 1 119 1 view .LVU122
 543 0214 0070A0E1 		mov	r7, r0	@ out_buffer, out_buffer
 544 0218 24D04DE2 		sub	sp, sp, #36	@,,
 545              		.cfi_def_cfa_offset 72
 546              	@ armwave.c:130:     printf("output buffer: 0x%08x\n", out_buffer);
 547              		.loc 1 130 5 view .LVU123
 548 021c 14029FE5 		ldr	r0, .L46+4	@,
 549              	.LVL25:
 550              	@ armwave.c:126:     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 126:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 551              		.loc 1 126 15 view .LVU124
 552 0220 049096E5 		ldr	r9, [r6, #4]	@ base_32ptr, g_armwave_state.ch1_buffer
 553              	.LVL26:
 127:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 554              		.loc 1 127 5 is_stmt 1 view .LVU125
 128:armwave.c     **** 
 555              		.loc 1 128 5 view .LVU126
 556              		.loc 1 130 5 view .LVU127
 557 0224 FEFFFFEB 		bl	printf		@
 558              	.LVL27:
 131:armwave.c     **** 
 132:armwave.c     ****     if(out_buffer == NULL)
 559              		.loc 1 132 5 view .LVU128
 560              	@ armwave.c:132:     if(out_buffer == NULL)
 561              		.loc 1 132 7 is_stmt 0 view .LVU129
 562 0228 000057E3 		cmp	r7, #0	@ out_buffer,
 563 022c 7B00000A 		beq	.L23		@,
 133:armwave.c     ****         return;
 134:armwave.c     **** 
 135:armwave.c     ****     npix = g_armwave_state.target_width * g_armwave_state.bitdepth_height; 
 564              		.loc 1 135 5 is_stmt 1 view .LVU130
 565              	@ armwave.c:135:     npix = g_armwave_state.target_width * g_armwave_state.bitdepth_height; 
 566              		.loc 1 135 27 is_stmt 0 view .LVU131
 567 0230 583096E5 		ldr	r3, [r6, #88]	@ _1, g_armwave_state.target_width
 568              	@ armwave.c:138:         g_armwave_state.target_width * g_armwave_state.target_height * 4, npix, \
 136:armwave.c     ****     
 137:armwave.c     ****     printf("memset %d bytes, npix %d, chbuff sz %d, base32_ptr 0x%08x, stack ~0x%08x\n", \
 138:armwave.c     ****         g_armwave_state.target_width * g_armwave_state.target_height * 4, npix, \
 569              		.loc 1 138 38 view .LVU132
 570 0234 5C1096E5 		ldr	r1, [r6, #92]	@ g_armwave_state.target_height, g_armwave_state.target_height
 571              	@ armwave.c:135:     npix = g_armwave_state.target_width * g_armwave_state.bitdepth_height; 
 135:armwave.c     ****     
 572              		.loc 1 135 10 view .LVU133
 573 0238 402096E5 		ldr	r2, [r6, #64]	@ g_armwave_state.bitdepth_height, g_armwave_state.bitdepth_height
 574              	@ armwave.c:137:     printf("memset %d bytes, npix %d, chbuff sz %d, base32_ptr 0x%08x, stack ~0x%0
 137:armwave.c     ****         g_armwave_state.target_width * g_armwave_state.target_height * 4, npix, \
 575              		.loc 1 137 5 view .LVU134
 576 023c 1C008DE2 		add	r0, sp, #28	@ tmp194,,
 577              	@ armwave.c:138:         g_armwave_state.target_width * g_armwave_state.target_height * 4, npix, \
 578              		.loc 1 138 38 view .LVU135
 579 0240 910301E0 		mul	r1, r1, r3	@ tmp190, g_armwave_state.target_height, _1
 580              	@ armwave.c:135:     npix = g_armwave_state.target_width * g_armwave_state.bitdepth_height; 
 135:armwave.c     ****     
 581              		.loc 1 135 10 view .LVU136
 582 0244 92030AE0 		mul	r10, r2, r3	@ npix, g_armwave_state.bitdepth_height, _1
 583              	.LVL28:
 137:armwave.c     ****         g_armwave_state.target_width * g_armwave_state.target_height * 4, npix, \
 584              		.loc 1 137 5 is_stmt 1 view .LVU137
 585 0248 0111A0E1 		lsl	r1, r1, #2	@, tmp190,
 586 024c 0A20A0E1 		mov	r2, r10	@, npix
 587 0250 04008DE5 		str	r0, [sp, #4]	@ tmp194,
 588 0254 503096E5 		ldr	r3, [r6, #80]	@, g_armwave_state.ch_buff_size
 589 0258 00908DE5 		str	r9, [sp]	@ base_32ptr,
 590 025c D8019FE5 		ldr	r0, .L46+8	@,
 591 0260 FEFFFFEB 		bl	printf		@
 592              	.LVL29:
 139:armwave.c     ****         g_armwave_state.ch_buff_size, base_32ptr, &w);
 140:armwave.c     **** 
 141:armwave.c     ****     // we don't really want to be doing this if possible;  os.madvise may be a better option
 142:armwave.c     ****     memset(out_buffer, 0x00, g_armwave_state.target_width * g_armwave_state.target_height * 4);
 593              		.loc 1 142 5 view .LVU138
 594              	@ armwave.c:142:     memset(out_buffer, 0x00, g_armwave_state.target_width * g_armwave_state.target
 595              		.loc 1 142 59 is_stmt 0 view .LVU139
 596 0264 583096E5 		ldr	r3, [r6, #88]	@ g_armwave_state.target_width, g_armwave_state.target_width
 597 0268 5C2096E5 		ldr	r2, [r6, #92]	@ g_armwave_state.target_height, g_armwave_state.target_height
 598              	@ armwave.c:142:     memset(out_buffer, 0x00, g_armwave_state.target_width * g_armwave_state.target
 599              		.loc 1 142 5 view .LVU140
 600 026c 0010A0E3 		mov	r1, #0	@,
 601 0270 0700A0E1 		mov	r0, r7	@, out_buffer
 602              	@ armwave.c:142:     memset(out_buffer, 0x00, g_armwave_state.target_width * g_armwave_state.target
 603              		.loc 1 142 59 view .LVU141
 604 0274 920302E0 		mul	r2, r2, r3	@ tmp197, g_armwave_state.target_height, g_armwave_state.target_width
 605              	@ armwave.c:142:     memset(out_buffer, 0x00, g_armwave_state.target_width * g_armwave_state.target
 606              		.loc 1 142 5 view .LVU142
 607 0278 0221A0E1 		lsl	r2, r2, #2	@, tmp197,
 608 027c FEFFFFEB 		bl	memset		@
 609              	.LVL30:
 143:armwave.c     **** 
 144:armwave.c     ****     printf("iter...\n");
 610              		.loc 1 144 5 is_stmt 1 view .LVU143
 611 0280 B8019FE5 		ldr	r0, .L46+12	@,
 612 0284 FEFFFFEB 		bl	puts		@
 613              	.LVL31:
 145:armwave.c     **** 
 146:armwave.c     ****     for(n = 0; n < npix; n += 2) {
 614              		.loc 1 146 5 view .LVU144
 615              		.loc 1 146 5 is_stmt 0 view .LVU145
 616 0288 00005AE3 		cmp	r10, #0	@ npix,
 617 028c 650000DA 		ble	.L33		@,
 618              	@ armwave.c:146:     for(n = 0; n < npix; n += 2) {
 619              		.loc 1 146 11 view .LVU146
 620 0290 0040A0E3 		mov	r4, #0	@ n,
 621              	@ armwave.c:150:         if(n % 200 == 0) {
 147:armwave.c     ****         //wave_word = g_armwave_state.ch1_buffer[n]
 148:armwave.c     ****         wave_word = *base_32ptr++;
 149:armwave.c     **** 
 150:armwave.c     ****         if(n % 200 == 0) {
 622              		.loc 1 150 14 view .LVU147
 623 0294 A8B19FE5 		ldr	fp, .L46+16	@ tmp208,
 624              	@ armwave.c:120:     uint32_t xx, yy, ye, y, word, wave_word, painted = 0;
 120:armwave.c     ****     // uint32_t ysub;
 625              		.loc 1 120 46 view .LVU148
 626 0298 08408DE5 		str	r4, [sp, #8]	@ n, %sfp
 627 029c 040000EA 		b	.L32		@
 628              	.LVL32:
 629              	.L27:
 151:armwave.c     ****            printf("%d,", n);
 152:armwave.c     ****         }
 153:armwave.c     **** 
 154:armwave.c     ****         if(COND_UNLIKELY(wave_word != 0)) {
 630              		.loc 1 154 9 is_stmt 1 view .LVU149
 631              	@ armwave.c:154:         if(COND_UNLIKELY(wave_word != 0)) {
 632              		.loc 1 154 11 is_stmt 0 view .LVU150
 633 02a0 000055E3 		cmp	r5, #0	@ wave_word,
 634 02a4 0F00001A 		bne	.L44		@,
 635              	.LVL33:
 636              	.L28:
 637              	@ armwave.c:146:     for(n = 0; n < npix; n += 2) {
 146:armwave.c     ****         //wave_word = g_armwave_state.ch1_buffer[n]
 638              		.loc 1 146 28 discriminator 2 view .LVU151
 639 02a8 024084E2 		add	r4, r4, #2	@ n, n,
 640              	.LVL34:
 641              	@ armwave.c:146:     for(n = 0; n < npix; n += 2) {
 146:armwave.c     ****         //wave_word = g_armwave_state.ch1_buffer[n]
 642              		.loc 1 146 5 discriminator 2 view .LVU152
 643 02ac 04005AE1 		cmp	r10, r4	@ npix, n
 644 02b0 570000DA 		ble	.L26		@,
 645              	.LVL35:
 646              	.L32:
 148:armwave.c     **** 
 647              		.loc 1 148 9 is_stmt 1 view .LVU153
 648              	@ armwave.c:150:         if(n % 200 == 0) {
 150:armwave.c     ****            printf("%d,", n);
 649              		.loc 1 150 14 is_stmt 0 view .LVU154
 650 02b4 9B24C3E0 		smull	r2, r3, fp, r4	@ tmp283, tmp207, tmp208, n
 651              	@ armwave.c:148:         wave_word = *base_32ptr++;
 148:armwave.c     **** 
 652              		.loc 1 148 19 view .LVU155
 653 02b8 045099E4 		ldr	r5, [r9], #4	@ wave_word, MEM[base: base_32ptr_79, offset: 4294967292B]
 654              	.LVL36:
 150:armwave.c     ****            printf("%d,", n);
 655              		.loc 1 150 9 is_stmt 1 view .LVU156
 656              	@ armwave.c:150:         if(n % 200 == 0) {
 150:armwave.c     ****            printf("%d,", n);
 657              		.loc 1 150 14 is_stmt 0 view .LVU157
 658 02bc C42FA0E1 		asr	r2, r4, #31	@ tmp210, n,
 659 02c0 433362E0 		rsb	r3, r2, r3, asr #6	@ tmp206, tmp210, tmp207,
 660 02c4 033183E0 		add	r3, r3, r3, lsl #2	@ tmp213, tmp206, tmp206,
 661 02c8 033183E0 		add	r3, r3, r3, lsl #2	@ tmp215, tmp213, tmp213,
 662              	@ armwave.c:150:         if(n % 200 == 0) {
 150:armwave.c     ****            printf("%d,", n);
 663              		.loc 1 150 11 view .LVU158
 664 02cc 830154E1 		cmp	r4, r3, lsl #3	@ n, tmp215,
 665 02d0 F2FFFF1A 		bne	.L27		@,
 666              	.LVL37:
 151:armwave.c     ****         }
 667              		.loc 1 151 12 is_stmt 1 view .LVU159
 668 02d4 0410A0E1 		mov	r1, r4	@, n
 669 02d8 68019FE5 		ldr	r0, .L46+20	@,
 670 02dc FEFFFFEB 		bl	printf		@
 671              	.LVL38:
 672              		.loc 1 154 9 view .LVU160
 673              	@ armwave.c:154:         if(COND_UNLIKELY(wave_word != 0)) {
 674              		.loc 1 154 11 is_stmt 0 view .LVU161
 675 02e0 000055E3 		cmp	r5, #0	@ wave_word,
 676 02e4 EFFFFF0A 		beq	.L28		@,
 677              	.LVL39:
 678              	.L44:
 155:armwave.c     ****             for(w = 0; w < 2; w++) {
 679              		.loc 1 155 13 is_stmt 1 view .LVU162
 680              	@ armwave.c:160:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 156:armwave.c     ****                 value = wave_word & 0xffff;
 157:armwave.c     ****                 wave_word >>= 16;
 158:armwave.c     **** 
 159:armwave.c     ****                 if(value != 0) {
 160:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 681              		.loc 1 160 52 is_stmt 0 view .LVU163
 682 02e8 FC36D6E1 		ldrsh	r3, [r6, #108]	@ _19, g_armwave_state.ch1_color.r
 683              	@ armwave.c:173:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 161:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 162:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 163:armwave.c     **** 
 164:armwave.c     ****                     r = MIN(rr, 255);
 165:armwave.c     ****                     g = MIN(gg, 255);
 166:armwave.c     ****                     b = MIN(bb, 255);
 167:armwave.c     **** 
 168:armwave.c     ****                     // Ensure 100% alpha channel, if it is used
 169:armwave.c     ****                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 170:armwave.c     **** 
 171:armwave.c     ****                     // Plot the pixels
 172:armwave.c     ****                     nsub = n + w;
 173:armwave.c     ****                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 684              		.loc 1 173 57 view .LVU164
 685 02ec 0A6AD6ED 		vldr.32	s13, [r6, #40]	@ _39, g_armwave_state.vscale_frac
 686              	@ armwave.c:155:             for(w = 0; w < 2; w++) {
 155:armwave.c     ****                 value = wave_word & 0xffff;
 687              		.loc 1 155 26 view .LVU165
 688 02f0 00E0A0E3 		mov	lr, #0	@ w.9_110,
 689              	@ armwave.c:160:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 160:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 690              		.loc 1 160 52 view .LVU166
 691 02f4 0C308DE5 		str	r3, [sp, #12]	@ _19, %sfp
 692              	@ armwave.c:161:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 161:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 693              		.loc 1 161 52 view .LVU167
 694 02f8 FE36D6E1 		ldrsh	r3, [r6, #110]	@ _22, g_armwave_state.ch1_color.g
 695 02fc 10308DE5 		str	r3, [sp, #16]	@ _22, %sfp
 696              	@ armwave.c:162:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 162:armwave.c     **** 
 697              		.loc 1 162 52 view .LVU168
 698 0300 F037D6E1 		ldrsh	r3, [r6, #112]	@ _25, g_armwave_state.ch1_color.b
 699 0304 14308DE5 		str	r3, [sp, #20]	@ _25, %sfp
 700 0308 020000EA 		b	.L31		@
 701              	.LVL40:
 702              	.L29:
 703              	@ armwave.c:155:             for(w = 0; w < 2; w++) {
 155:armwave.c     ****                 value = wave_word & 0xffff;
 704              		.loc 1 155 13 discriminator 2 view .LVU169
 705 030c 01005EE3 		cmp	lr, #1	@ w.9_110,
 706 0310 3A00000A 		beq	.L45		@,
 707              	.L34:
 155:armwave.c     ****                 value = wave_word & 0xffff;
 708              		.loc 1 155 13 discriminator 2 view .LVU170
 709 0314 01E0A0E3 		mov	lr, #1	@ w.9_110,
 710              	.L31:
 156:armwave.c     ****                 wave_word >>= 16;
 711              		.loc 1 156 17 is_stmt 1 view .LVU171
 712              	@ armwave.c:156:                 value = wave_word & 0xffff;
 156:armwave.c     ****                 wave_word >>= 16;
 713              		.loc 1 156 23 is_stmt 0 view .LVU172
 714 0318 7530FFE6 		uxth	r3, r5	@ value, wave_word
 715              	.LVL41:
 157:armwave.c     **** 
 716              		.loc 1 157 17 is_stmt 1 view .LVU173
 717              	@ armwave.c:159:                 if(value != 0) {
 159:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 718              		.loc 1 159 19 is_stmt 0 view .LVU174
 719 031c 000053E3 		cmp	r3, #0	@ value,
 720              	@ armwave.c:157:                 wave_word >>= 16;
 157:armwave.c     **** 
 721              		.loc 1 157 27 view .LVU175
 722 0320 2558A0E1 		lsr	r5, r5, #16	@ wave_word, wave_word,
 723              	.LVL42:
 159:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 724              		.loc 1 159 17 is_stmt 1 view .LVU176
 725              	@ armwave.c:159:                 if(value != 0) {
 159:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 726              		.loc 1 159 19 is_stmt 0 view .LVU177
 727 0324 F8FFFF0A 		beq	.L29		@,
 160:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 728              		.loc 1 160 21 is_stmt 1 view .LVU178
 729              	.LVL43:
 161:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 730              		.loc 1 161 21 view .LVU179
 162:armwave.c     **** 
 731              		.loc 1 162 21 view .LVU180
 164:armwave.c     ****                     g = MIN(gg, 255);
 732              		.loc 1 164 21 view .LVU181
 165:armwave.c     ****                     b = MIN(bb, 255);
 733              		.loc 1 165 21 view .LVU182
 166:armwave.c     **** 
 734              		.loc 1 166 21 view .LVU183
 169:armwave.c     **** 
 735              		.loc 1 169 21 view .LVU184
 736 0328 0E0084E0 		add	r0, r4, lr	@ _165, n, w.9_110
 737              	@ armwave.c:162:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 162:armwave.c     **** 
 738              		.loc 1 162 55 is_stmt 0 view .LVU185
 739 032c 14209DE5 		ldr	r2, [sp, #20]	@ _25, %sfp
 740              	@ armwave.c:173:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 741              		.loc 1 173 32 view .LVU186
 742 0330 7010EFE6 		uxtb	r1, r0	@ _37, _165
 743              	@ armwave.c:174:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 174:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 744              		.loc 1 174 41 view .LVU187
 745 0334 01C081E2 		add	ip, r1, #1	@ tmp241, _37,
 746              	@ armwave.c:173:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 173:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 747              		.loc 1 173 40 view .LVU188
 748 0338 901A07EE 		vmov	s15, r1	@ int	@ _37, _37
 749              	@ armwave.c:174:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 750              		.loc 1 174 41 view .LVU189
 751 033c 10CA07EE 		vmov	s14, ip	@ int	@ tmp241, tmp241
 752              	@ armwave.c:161:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 161:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 753              		.loc 1 161 55 view .LVU190
 754 0340 10109DE5 		ldr	r1, [sp, #16]	@ _22, %sfp
 755              	@ armwave.c:162:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 162:armwave.c     **** 
 756              		.loc 1 162 55 view .LVU191
 757 0344 930202E0 		mul	r2, r3, r2	@ tmp226, value, _25
 758              	@ armwave.c:173:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 173:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 759              		.loc 1 173 40 view .LVU192
 760 0348 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp239, _37
 761              	@ armwave.c:174:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 762              		.loc 1 174 46 view .LVU193
 763 034c C77AB8EE 		vcvt.f32.s32	s14, s14	@ tmp242, tmp241
 764              	@ armwave.c:161:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 161:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 765              		.loc 1 161 55 view .LVU194
 766 0350 930101E0 		mul	r1, r3, r1	@ tmp230, value, _22
 767              	@ armwave.c:160:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 160:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 768              		.loc 1 160 55 view .LVU195
 769 0354 0CC09DE5 		ldr	ip, [sp, #12]	@ _19, %sfp
 770              	@ armwave.c:162:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 162:armwave.c     **** 
 771              		.loc 1 162 24 view .LVU196
 772 0358 4224A0E1 		asr	r2, r2, #8	@ bb, tmp226,
 773              	.LVL44:
 774              	@ armwave.c:166:                     b = MIN(bb, 255);
 166:armwave.c     **** 
 775              		.loc 1 166 25 view .LVU197
 776 035c FF0052E3 		cmp	r2, #255	@ bb,
 777              	@ armwave.c:160:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 160:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 778              		.loc 1 160 55 view .LVU198
 779 0360 930C03E0 		mul	r3, r3, ip	@ tmp236, value, _19
 780              	.LVL45:
 781              	@ armwave.c:173:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 173:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 782              		.loc 1 173 40 view .LVU199
 783 0364 A67A67EE 		vmul.f32	s15, s15, s13	@ tmp240, tmp239, _39
 784              	@ armwave.c:174:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 785              		.loc 1 174 46 view .LVU200
 786 0368 267A27EE 		vmul.f32	s14, s14, s13	@ tmp243, tmp242, _39
 787              	@ armwave.c:161:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 161:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 788              		.loc 1 161 24 view .LVU201
 789 036c 4114A0E1 		asr	r1, r1, #8	@ gg, tmp230,
 790              	.LVL46:
 791              	@ armwave.c:166:                     b = MIN(bb, 255);
 166:armwave.c     **** 
 792              		.loc 1 166 25 view .LVU202
 793 0370 FF20A0A3 		movge	r2, #255	@ bb,
 794              	.LVL47:
 795              	@ armwave.c:165:                     g = MIN(gg, 255);
 165:armwave.c     ****                     b = MIN(bb, 255);
 796              		.loc 1 165 25 view .LVU203
 797 0374 FF0051E3 		cmp	r1, #255	@ gg,
 798 0378 FF10A0A3 		movge	r1, #255	@ gg,
 799              	.LVL48:
 800              	@ armwave.c:160:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 160:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 801              		.loc 1 160 24 view .LVU204
 802 037c 4334A0E1 		asr	r3, r3, #8	@ rr, tmp236,
 803              	.LVL49:
 804              	@ armwave.c:164:                     r = MIN(rr, 255);
 164:armwave.c     ****                     g = MIN(gg, 255);
 805              		.loc 1 164 25 view .LVU205
 806 0380 FF0053E3 		cmp	r3, #255	@ rr,
 807              	@ armwave.c:173:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 173:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 808              		.loc 1 173 24 view .LVU206
 809 0384 E77AFCEE 		vcvt.u32.f32	s15, s15	@ yy, tmp240
 810              	@ armwave.c:169:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 169:armwave.c     **** 
 811              		.loc 1 169 56 view .LVU207
 812 0388 0114A0E1 		lsl	r1, r1, #8	@ tmp231, gg,
 813              	@ armwave.c:164:                     r = MIN(rr, 255);
 164:armwave.c     ****                     g = MIN(gg, 255);
 814              		.loc 1 164 25 view .LVU208
 815 038c FF30A0A3 		movge	r3, #255	@ rr,
 816              	.LVL50:
 817              	@ armwave.c:169:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 169:armwave.c     **** 
 818              		.loc 1 169 44 view .LVU209
 819 0390 0228A0E1 		lsl	r2, r2, #16	@ tmp227, bb,
 820              	@ armwave.c:175:                     xx = (nsub >> 8) / 2;
 175:armwave.c     ****                     xx = (nsub >> 8) / 2;
 821              		.loc 1 175 32 view .LVU210
 822 0394 4004A0E1 		asr	r0, r0, #8	@ tmp244, _165,
 823              	@ armwave.c:169:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 169:armwave.c     **** 
 824              		.loc 1 169 44 view .LVU211
 825 0398 FF2802E2 		and	r2, r2, #16711680	@ tmp228, tmp227,
 826              	@ armwave.c:169:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 169:armwave.c     **** 
 827              		.loc 1 169 56 view .LVU212
 828 039c 7110FFE6 		uxth	r1, r1	@ tmp232, tmp231
 829              	@ armwave.c:169:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 169:armwave.c     **** 
 830              		.loc 1 169 51 view .LVU213
 831 03a0 011082E1 		orr	r1, r2, r1	@ tmp234, tmp228, tmp232
 832              	@ armwave.c:173:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 173:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 833              		.loc 1 173 24 view .LVU214
 834 03a4 908A17EE 		vmov	r8, s15	@ int	@ yy, yy
 835              	@ armwave.c:174:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 174:armwave.c     ****                     xx = (nsub >> 8) / 2;
 836              		.loc 1 174 24 view .LVU215
 837 03a8 C77AFCEE 		vcvt.u32.f32	s15, s14	@ ye, tmp243
 838              	@ armwave.c:169:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 169:armwave.c     **** 
 839              		.loc 1 169 62 view .LVU216
 840 03ac 7330EFE6 		uxtb	r3, r3	@ rr, rr
 841              	@ armwave.c:175:                     xx = (nsub >> 8) / 2;
 842              		.loc 1 175 38 view .LVU217
 843 03b0 A00F80E0 		add	r0, r0, r0, lsr #31	@ tmp246, tmp244, tmp244,
 844              	@ armwave.c:169:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 169:armwave.c     **** 
 845              		.loc 1 169 62 view .LVU218
 846 03b4 031081E1 		orr	r1, r1, r3	@ tmp238, tmp234, rr
 847              	@ armwave.c:169:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 169:armwave.c     **** 
 848              		.loc 1 169 26 view .LVU219
 849 03b8 FF1481E3 		orr	r1, r1, #-16777216	@ word, tmp238,
 850              	.LVL51:
 172:armwave.c     ****                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 851              		.loc 1 172 21 is_stmt 1 view .LVU220
 173:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 852              		.loc 1 173 21 view .LVU221
 174:armwave.c     ****                     xx = (nsub >> 8) / 2;
 853              		.loc 1 174 21 view .LVU222
 854              	@ armwave.c:175:                     xx = (nsub >> 8) / 2;
 855              		.loc 1 175 38 is_stmt 0 view .LVU223
 856 03bc C000A0E1 		asr	r0, r0, #1	@ xx, tmp246,
 857              	@ armwave.c:174:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 174:armwave.c     ****                     xx = (nsub >> 8) / 2;
 858              		.loc 1 174 24 view .LVU224
 859 03c0 90CA17EE 		vmov	ip, s15	@ int	@ ye, ye
 860              	.LVL52:
 861              		.loc 1 175 21 is_stmt 1 view .LVU225
 176:armwave.c     **** 
 177:armwave.c     ****                     for(y = yy; y < ye; y++) {
 862              		.loc 1 177 21 view .LVU226
 863              		.loc 1 177 21 is_stmt 0 view .LVU227
 864 03c4 0C0058E1 		cmp	r8, ip	@ yy, ye
 865 03c8 CFFFFF2A 		bcs	.L29		@,
 866 03cc 0830A0E1 		mov	r3, r8	@ y, yy
 867              	.LVL53:
 868              	.L30:
 178:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 869              		.loc 1 178 25 is_stmt 1 discriminator 3 view .LVU228
 179:armwave.c     ****                         *(out_buffer_base + offset) = word;
 870              		.loc 1 179 25 discriminator 3 view .LVU229
 871              	@ armwave.c:178:                         offset = (xx + (y * g_armwave_state.target_width)); 
 178:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 872              		.loc 1 178 43 is_stmt 0 discriminator 3 view .LVU230
 873 03d0 582096E5 		ldr	r2, [r6, #88]	@ g_armwave_state.target_width, g_armwave_state.target_width
 874              	@ armwave.c:179:                         *(out_buffer_base + offset) = word;
 875              		.loc 1 179 43 discriminator 3 view .LVU231
 876 03d4 920322E0 		mla	r2, r2, r3, r0	@ tmp251, g_armwave_state.target_width, y, xx
 877              	.LVL54:
 878              	@ armwave.c:177:                     for(y = yy; y < ye; y++) {
 177:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 879              		.loc 1 177 42 discriminator 3 view .LVU232
 880 03d8 013083E2 		add	r3, r3, #1	@ y, y,
 881              	.LVL55:
 882              	@ armwave.c:177:                     for(y = yy; y < ye; y++) {
 177:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 883              		.loc 1 177 21 discriminator 3 view .LVU233
 884 03dc 03005CE1 		cmp	ip, r3	@ ye, y
 885              	@ armwave.c:179:                         *(out_buffer_base + offset) = word;
 886              		.loc 1 179 53 discriminator 3 view .LVU234
 887 03e0 021187E7 		str	r1, [r7, r2, lsl #2]	@ word, *_50
 180:armwave.c     ****                         painted++;
 888              		.loc 1 180 25 is_stmt 1 discriminator 3 view .LVU235
 889              	.LVL56:
 890              	@ armwave.c:177:                     for(y = yy; y < ye; y++) {
 177:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 891              		.loc 1 177 21 is_stmt 0 discriminator 3 view .LVU236
 892 03e4 F9FFFF1A 		bne	.L30		@,
 177:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 893              		.loc 1 177 21 discriminator 3 view .LVU237
 894 03e8 08309DE5 		ldr	r3, [sp, #8]	@ painted, %sfp
 895              	.LVL57:
 177:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 896              		.loc 1 177 21 discriminator 3 view .LVU238
 897 03ec 08C04CE0 		sub	ip, ip, r8	@ tmp252, ye, yy
 898              	.LVL58:
 177:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 899              		.loc 1 177 21 discriminator 3 view .LVU239
 900 03f0 0C3083E0 		add	r3, r3, ip	@ painted, painted, tmp252
 901              	@ armwave.c:155:             for(w = 0; w < 2; w++) {
 155:armwave.c     ****                 value = wave_word & 0xffff;
 902              		.loc 1 155 13 view .LVU240
 903 03f4 01005EE3 		cmp	lr, #1	@ w.9_110,
 904 03f8 08308DE5 		str	r3, [sp, #8]	@ painted, %sfp
 905              	.LVL59:
 155:armwave.c     ****                 value = wave_word & 0xffff;
 906              		.loc 1 155 13 view .LVU241
 907 03fc C4FFFF1A 		bne	.L34		@,
 908              	.LVL60:
 909              	.L45:
 910              	@ armwave.c:146:     for(n = 0; n < npix; n += 2) {
 146:armwave.c     ****         //wave_word = g_armwave_state.ch1_buffer[n]
 911              		.loc 1 146 28 view .LVU242
 912 0400 024084E2 		add	r4, r4, #2	@ n, n,
 913              	.LVL61:
 146:armwave.c     ****         //wave_word = g_armwave_state.ch1_buffer[n]
 914              		.loc 1 146 28 view .LVU243
 915 0404 0230A0E3 		mov	r3, #2	@ tmp253,
 916              	@ armwave.c:146:     for(n = 0; n < npix; n += 2) {
 146:armwave.c     ****         //wave_word = g_armwave_state.ch1_buffer[n]
 917              		.loc 1 146 5 view .LVU244
 918 0408 04005AE1 		cmp	r10, r4	@ npix, n
 919 040c 1C308DE5 		str	r3, [sp, #28]	@ tmp253, w
 920              	.LVL62:
 146:armwave.c     ****         //wave_word = g_armwave_state.ch1_buffer[n]
 921              		.loc 1 146 5 view .LVU245
 922 0410 A7FFFFCA 		bgt	.L32		@,
 923              	.LVL63:
 924              	.L26:
 181:armwave.c     ****                     }
 182:armwave.c     ****                 }
 183:armwave.c     ****             }
 184:armwave.c     ****         }
 185:armwave.c     ****     }
 186:armwave.c     **** 
 187:armwave.c     ****     printf("...done paint %d pixels...\n", painted);
 925              		.loc 1 187 5 is_stmt 1 view .LVU246
 926 0414 08109DE5 		ldr	r1, [sp, #8]	@, %sfp
 927 0418 2C009FE5 		ldr	r0, .L46+24	@,
 928 041c FEFFFFEB 		bl	printf		@
 929              	.LVL64:
 930              	.L23:
 931              	@ armwave.c:188: }
 188:armwave.c     **** }
 932              		.loc 1 188 1 is_stmt 0 view .LVU247
 933 0420 24D08DE2 		add	sp, sp, #36	@,,
 934              		.cfi_remember_state
 935              		.cfi_def_cfa_offset 36
 936              		@ sp needed	@
 937 0424 F08FBDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}	@
 938              	.LVL65:
 939              	.L33:
 940              		.cfi_restore_state
 941              	@ armwave.c:120:     uint32_t xx, yy, ye, y, word, wave_word, painted = 0;
 120:armwave.c     ****     // uint32_t ysub;
 942              		.loc 1 120 46 view .LVU248
 943 0428 0030A0E3 		mov	r3, #0	@ painted,
 944 042c 08308DE5 		str	r3, [sp, #8]	@ painted, %sfp
 945 0430 F7FFFFEA 		b	.L26		@
 946              	.L47:
 947              		.align	2
 948              	.L46:
 949 0434 00000000 		.word	g_armwave_state
 950 0438 78000000 		.word	.LC3
 951 043c 90000000 		.word	.LC4
 952 0440 DC000000 		.word	.LC5
 953 0444 1F85EB51 		.word	1374389535
 954 0448 E4000000 		.word	.LC6
 955 044c E8000000 		.word	.LC7
 956              		.cfi_endproc
 957              	.LFE60:
 959              		.global	__aeabi_idiv
 960              		.align	2
 961              		.global	armwave_generate
 962              		.syntax unified
 963              		.arm
 964              		.fpu vfp
 966              	armwave_generate:
 967              	.LFB61:
 189:armwave.c     **** 
 190:armwave.c     **** /*
 191:armwave.c     ****  * Fill buffers with rendered waveform (only supports Ch1 so far.)
 192:armwave.c     ****  */
 193:armwave.c     **** void armwave_generate()
 194:armwave.c     **** {
 968              		.loc 1 194 1 is_stmt 1 view -0
 969              		.cfi_startproc
 970              		@ args = 0, pretend = 0, frame = 0
 971              		@ frame_needed = 0, uses_anonymous_args = 0
 195:armwave.c     ****     uint32_t yy;
 972              		.loc 1 195 5 view .LVU250
 196:armwave.c     ****     uint32_t xx_rem = g_armwave_state.wave_length, ypos = 0;
 973              		.loc 1 196 5 view .LVU251
 974              	.LVL66:
 197:armwave.c     **** 
 198:armwave.c     ****     memset(g_armwave_state.ch1_buffer, 0, g_armwave_state.ch_buff_size);
 975              		.loc 1 198 5 view .LVU252
 976              	@ armwave.c:194: {
 194:armwave.c     ****     uint32_t yy;
 977              		.loc 1 194 1 is_stmt 0 view .LVU253
 978 0450 F0402DE9 		push	{r4, r5, r6, r7, lr}	@
 979              		.cfi_def_cfa_offset 20
 980              		.cfi_offset 4, -20
 981              		.cfi_offset 5, -16
 982              		.cfi_offset 6, -12
 983              		.cfi_offset 7, -8
 984              		.cfi_offset 14, -4
 985              	@ armwave.c:198:     memset(g_armwave_state.ch1_buffer, 0, g_armwave_state.ch_buff_size);
 986              		.loc 1 198 5 view .LVU254
 987 0454 0010A0E3 		mov	r1, #0	@,
 988              	@ armwave.c:198:     memset(g_armwave_state.ch1_buffer, 0, g_armwave_state.ch_buff_size);
 989              		.loc 1 198 58 view .LVU255
 990 0458 84509FE5 		ldr	r5, .L56	@ tmp154,
 991              	@ armwave.c:194: {
 194:armwave.c     ****     uint32_t yy;
 992              		.loc 1 194 1 view .LVU256
 993 045c 0CD04DE2 		sub	sp, sp, #12	@,,
 994              		.cfi_def_cfa_offset 32
 995              	@ armwave.c:198:     memset(g_armwave_state.ch1_buffer, 0, g_armwave_state.ch_buff_size);
 996              		.loc 1 198 5 view .LVU257
 997 0460 502095E5 		ldr	r2, [r5, #80]	@, g_armwave_state.ch_buff_size
 998 0464 040095E5 		ldr	r0, [r5, #4]	@, g_armwave_state.ch1_buffer
 999 0468 FEFFFFEB 		bl	memset		@
 1000              	.LVL67:
 199:armwave.c     **** 
 200:armwave.c     ****     for(yy = 0; yy < (g_armwave_state.wave_length / g_armwave_state.slice_height); yy++) {
 1001              		.loc 1 200 5 is_stmt 1 view .LVU258
 1002              	@ armwave.c:200:     for(yy = 0; yy < (g_armwave_state.wave_length / g_armwave_state.slice_height);
 1003              		.loc 1 200 68 is_stmt 0 view .LVU259
 1004 046c 446095E5 		ldr	r6, [r5, #68]	@ _13, g_armwave_state.slice_height
 1005              	@ armwave.c:200:     for(yy = 0; yy < (g_armwave_state.wave_length / g_armwave_state.slice_height);
 1006              		.loc 1 200 51 view .LVU260
 1007 0470 4C0095E5 		ldr	r0, [r5, #76]	@, g_armwave_state.wave_length
 1008 0474 0610A0E1 		mov	r1, r6	@, _13
 1009 0478 FEFFFFEB 		bl	__aeabi_idiv		@
 1010              	.LVL68:
 1011              	@ armwave.c:200:     for(yy = 0; yy < (g_armwave_state.wave_length / g_armwave_state.slice_height);
 1012              		.loc 1 200 5 view .LVU261
 1013 047c 000050E3 		cmp	r0, #0	@,
 1014 0480 1500000A 		beq	.L48		@,
 1015              	@ armwave.c:202:         printf("armwave_generate: slice %d (y=%d, h=%d, xpos=%d)\n", \
 201:armwave.c     ****     //for(yy = 0; yy < 10; yy++) {
 202:armwave.c     ****         printf("armwave_generate: slice %d (y=%d, h=%d, xpos=%d)\n", \
 1016              		.loc 1 202 9 view .LVU262
 1017 0484 5C709FE5 		ldr	r7, .L56+4	@ tmp155,
 1018              	@ armwave.c:200:     for(yy = 0; yy < (g_armwave_state.wave_length / g_armwave_state.slice_height);
 200:armwave.c     ****     //for(yy = 0; yy < 10; yy++) {
 1019              		.loc 1 200 12 view .LVU263
 1020 0488 0040A0E3 		mov	r4, #0	@ yy,
 1021              	.LVL69:
 1022              	.L50:
 1023              		.loc 1 202 9 is_stmt 1 discriminator 3 view .LVU264
 1024 048c 940601E0 		mul	r1, r4, r6	@ _5, yy, _13
 1025              	@ armwave.c:204:             (yy * g_armwave_state.slice_height * g_armwave_state.cmp_x_bitdepth_sc
 203:armwave.c     ****             yy, yy * g_armwave_state.slice_height, g_armwave_state.slice_height, 
 204:armwave.c     ****             (yy * g_armwave_state.slice_height * g_armwave_state.cmp_x_bitdepth_scale) >> AM_XCOORD
 1026              		.loc 1 204 48 is_stmt 0 discriminator 3 view .LVU265
 1027 0490 24C095E5 		ldr	ip, [r5, #36]	@ g_armwave_state.cmp_x_bitdepth_scale, g_armwave_state.cmp_x_bitdepth_scale
 1028              	@ armwave.c:202:         printf("armwave_generate: slice %d (y=%d, h=%d, xpos=%d)\n", \
 202:armwave.c     ****             yy, yy * g_armwave_state.slice_height, g_armwave_state.slice_height, 
 1029              		.loc 1 202 9 discriminator 3 view .LVU266
 1030 0494 0630A0E1 		mov	r3, r6	@, _13
 1031 0498 0120A0E1 		mov	r2, r1	@, _5
 1032              	@ armwave.c:204:             (yy * g_armwave_state.slice_height * g_armwave_state.cmp_x_bitdepth_sc
 1033              		.loc 1 204 48 discriminator 3 view .LVU267
 1034 049c 9C010CE0 		mul	ip, ip, r1	@ tmp143, g_armwave_state.cmp_x_bitdepth_scale, _5
 1035              	@ armwave.c:202:         printf("armwave_generate: slice %d (y=%d, h=%d, xpos=%d)\n", \
 202:armwave.c     ****             yy, yy * g_armwave_state.slice_height, g_armwave_state.slice_height, 
 1036              		.loc 1 202 9 discriminator 3 view .LVU268
 1037 04a0 0700A0E1 		mov	r0, r7	@, tmp155
 1038 04a4 0410A0E1 		mov	r1, r4	@, yy
 1039 04a8 2CC8A0E1 		lsr	ip, ip, #16	@ tmp145, tmp143,
 1040 04ac 00C08DE5 		str	ip, [sp]	@ tmp145,
 1041 04b0 FEFFFFEB 		bl	printf		@
 1042              	.LVL70:
 205:armwave.c     **** 
 206:armwave.c     ****         render_nonaa_to_buffer_1ch_slice(yy * g_armwave_state.slice_height, g_armwave_state.slice_h
 1043              		.loc 1 206 9 is_stmt 1 discriminator 3 view .LVU269
 1044              	@ armwave.c:206:         render_nonaa_to_buffer_1ch_slice(yy * g_armwave_state.slice_height, g_armw
 1045              		.loc 1 206 62 is_stmt 0 discriminator 3 view .LVU270
 1046 04b4 441095E5 		ldr	r1, [r5, #68]	@ _10, g_armwave_state.slice_height
 1047              	@ armwave.c:206:         render_nonaa_to_buffer_1ch_slice(yy * g_armwave_state.slice_height, g_armw
 1048              		.loc 1 206 9 discriminator 3 view .LVU271
 1049 04b8 940100E0 		mul	r0, r4, r1	@, yy,
 1050 04bc FEFFFFEB 		bl	render_nonaa_to_buffer_1ch_slice		@
 1051              	.LVL71:
 207:armwave.c     ****         xx_rem -= g_armwave_state.slice_height;
 1052              		.loc 1 207 9 is_stmt 1 discriminator 3 view .LVU272
 208:armwave.c     ****         ypos += g_armwave_state.slice_height;   
 1053              		.loc 1 208 9 discriminator 3 view .LVU273
 1054              	@ armwave.c:200:     for(yy = 0; yy < (g_armwave_state.wave_length / g_armwave_state.slice_height);
 200:armwave.c     ****     //for(yy = 0; yy < 10; yy++) {
 1055              		.loc 1 200 68 is_stmt 0 discriminator 3 view .LVU274
 1056 04c0 446095E5 		ldr	r6, [r5, #68]	@ _13, g_armwave_state.slice_height
 1057              	@ armwave.c:200:     for(yy = 0; yy < (g_armwave_state.wave_length / g_armwave_state.slice_height);
 200:armwave.c     ****     //for(yy = 0; yy < 10; yy++) {
 1058              		.loc 1 200 51 discriminator 3 view .LVU275
 1059 04c4 4C0095E5 		ldr	r0, [r5, #76]	@, g_armwave_state.wave_length
 1060 04c8 0610A0E1 		mov	r1, r6	@, _13
 1061 04cc FEFFFFEB 		bl	__aeabi_idiv		@
 1062              	.LVL72:
 1063              	@ armwave.c:200:     for(yy = 0; yy < (g_armwave_state.wave_length / g_armwave_state.slice_height);
 200:armwave.c     ****     //for(yy = 0; yy < 10; yy++) {
 1064              		.loc 1 200 86 discriminator 3 view .LVU276
 1065 04d0 014084E2 		add	r4, r4, #1	@ yy, yy,
 1066              	.LVL73:
 1067              	@ armwave.c:200:     for(yy = 0; yy < (g_armwave_state.wave_length / g_armwave_state.slice_height);
 200:armwave.c     ****     //for(yy = 0; yy < 10; yy++) {
 1068              		.loc 1 200 5 discriminator 3 view .LVU277
 1069 04d4 040050E1 		cmp	r0, r4	@, yy
 1070 04d8 EBFFFF8A 		bhi	.L50		@,
 1071              	.LVL74:
 1072              	.L48:
 1073              	@ armwave.c:217: }
 209:armwave.c     ****     }
 210:armwave.c     **** 
 211:armwave.c     ****     /*
 212:armwave.c     ****     printf("armwave_generate: slice %d (y=%d, h=%d, xpos=%d) last\n", \
 213:armwave.c     ****             yy, ypos, g_armwave_state.slice_height, 
 214:armwave.c     ****             (yy * g_armwave_state.slice_height * g_armwave_state.cmp_x_bitdepth_scale) >> AM_XCOORD
 215:armwave.c     ****     render_nonaa_to_buffer_1ch_slice(ypos, xx_rem);
 216:armwave.c     ****     */
 217:armwave.c     **** }
 1074              		.loc 1 217 1 view .LVU278
 1075 04dc 0CD08DE2 		add	sp, sp, #12	@,,
 1076              		.cfi_def_cfa_offset 20
 1077              		@ sp needed	@
 1078 04e0 F080BDE8 		pop	{r4, r5, r6, r7, pc}	@
 1079              	.L57:
 1080              		.align	2
 1081              	.L56:
 1082 04e4 00000000 		.word	g_armwave_state
 1083 04e8 04010000 		.word	.LC8
 1084              		.cfi_endproc
 1085              	.LFE61:
 1087              		.align	2
 1088              		.global	armwave_setup_render
 1089              		.syntax unified
 1090              		.arm
 1091              		.fpu vfp
 1093              	armwave_setup_render:
 1094              	.LVL75:
 1095              	.LFB62:
 218:armwave.c     **** 
 219:armwave.c     **** /*
 220:armwave.c     ****  * Setup the renderer with passed parameters.
 221:armwave.c     ****  */
 222:armwave.c     **** void armwave_setup_render(uint32_t start_point, uint32_t end_point, uint32_t waves_max, uint32_t wa
 223:armwave.c     **** {
 1096              		.loc 1 223 1 is_stmt 1 view -0
 1097              		.cfi_startproc
 1098              		@ args = 12, pretend = 0, frame = 0
 1099              		@ frame_needed = 0, uses_anonymous_args = 0
 224:armwave.c     ****     uint32_t length, xx;
 1100              		.loc 1 224 5 view .LVU280
 225:armwave.c     ****     float points_per_pixel;
 1101              		.loc 1 225 5 view .LVU281
 226:armwave.c     **** 
 227:armwave.c     ****     printf("s=%d e=%d w=%d ws=%d tw=%d th=%d rf=0x%08x\n", start_point, end_point, waves_max, wave_
 1102              		.loc 1 227 5 view .LVU282
 1103              	@ armwave.c:223: {
 223:armwave.c     ****     uint32_t length, xx;
 1104              		.loc 1 223 1 is_stmt 0 view .LVU283
 1105 04ec F0432DE9 		push	{r4, r5, r6, r7, r8, r9, lr}	@
 1106              		.cfi_def_cfa_offset 28
 1107              		.cfi_offset 4, -28
 1108              		.cfi_offset 5, -24
 1109              		.cfi_offset 6, -20
 1110              		.cfi_offset 7, -16
 1111              		.cfi_offset 8, -12
 1112              		.cfi_offset 9, -8
 1113              		.cfi_offset 14, -4
 1114 04f0 14D04DE2 		sub	sp, sp, #20	@,,
 1115              		.cfi_def_cfa_offset 48
 1116              	@ armwave.c:223: {
 223:armwave.c     ****     uint32_t length, xx;
 1117              		.loc 1 223 1 view .LVU284
 1118 04f4 0040A0E1 		mov	r4, r0	@ start_point, start_point
 1119 04f8 D063CDE1 		ldrd	r6, [sp, #48]	@,,
 1120 04fc 38C09DE5 		ldr	ip, [sp, #56]	@ render_flags, render_flags
 1121 0500 0150A0E1 		mov	r5, r1	@ end_point, end_point
 1122              	@ armwave.c:227:     printf("s=%d e=%d w=%d ws=%d tw=%d th=%d rf=0x%08x\n", start_point, end_point,
 1123              		.loc 1 227 5 view .LVU285
 1124 0504 00308DE5 		str	r3, [sp]	@ wave_stride,
 1125              	@ armwave.c:223: {
 223:armwave.c     ****     uint32_t length, xx;
 1126              		.loc 1 223 1 view .LVU286
 1127 0508 0280A0E1 		mov	r8, r2	@ waves_max, waves_max
 1128 050c 0390A0E1 		mov	r9, r3	@ wave_stride, wave_stride
 1129              	@ armwave.c:227:     printf("s=%d e=%d w=%d ws=%d tw=%d th=%d rf=0x%08x\n", start_point, end_point,
 1130              		.loc 1 227 5 view .LVU287
 1131 0510 F460CDE1 		strd	r6, [sp, #4]	@,,
 1132 0514 0230A0E1 		mov	r3, r2	@, waves_max
 1133              	.LVL76:
 1134              		.loc 1 227 5 view .LVU288
 1135 0518 0CC08DE5 		str	ip, [sp, #12]	@ render_flags,
 1136 051c 0120A0E1 		mov	r2, r1	@, end_point
 1137              	.LVL77:
 1138              		.loc 1 227 5 view .LVU289
 1139 0520 0010A0E1 		mov	r1, r0	@, start_point
 1140              	.LVL78:
 1141              		.loc 1 227 5 view .LVU290
 1142 0524 8C019FE5 		ldr	r0, .L68+12	@,
 1143              	.LVL79:
 1144              		.loc 1 227 5 view .LVU291
 1145 0528 FEFFFFEB 		bl	printf		@
 1146              	.LVL80:
 228:armwave.c     **** 
 229:armwave.c     ****     // TODO these asserts should instead raise PyExc
 230:armwave.c     ****     assert(start_point < end_point);
 1147              		.loc 1 230 5 is_stmt 1 view .LVU292
 1148 052c 050054E1 		cmp	r4, r5	@ start_point, end_point
 1149 0530 5100002A 		bcs	.L66		@,
 231:armwave.c     **** 
 232:armwave.c     ****     /*
 233:armwave.c     ****     // target_height must be a power of two.  Only 256, 512, 1024 and 2048 height buffers are suppo
 234:armwave.c     ****     assert(target_height == 256 || target_height == 512 || target_height == 1024 || target_height =
 235:armwave.c     ****     if(target_height == 256) {
 236:armwave.c     ****         g_armwave_state.row_shift = 8;
 237:armwave.c     ****         g_armwave_state.row_mask = 0x0ff;
 238:armwave.c     ****     } else if(target_height == 512) {
 239:armwave.c     ****         g_armwave_state.row_shift = 9;
 240:armwave.c     ****         g_armwave_state.row_mask = 0x1ff;
 241:armwave.c     ****     } else if(target_height == 1024) {
 242:armwave.c     ****         g_armwave_state.row_shift = 10;
 243:armwave.c     ****         g_armwave_state.row_mask = 0x3ff;
 244:armwave.c     ****     } else if(target_height == 2048) {
 245:armwave.c     ****         g_armwave_state.row_shift = 11;
 246:armwave.c     ****         g_armwave_state.row_mask = 0x7ff;
 247:armwave.c     ****     }
 248:armwave.c     ****     */
 249:armwave.c     **** 
 250:armwave.c     ****     // Calculate the size of each buffer.  Buffers are rotated by 90 degrees to improve cache coher
 251:armwave.c     ****     g_armwave_state.xstride = target_height;
 1150              		.loc 1 251 5 view .LVU293
 1151              	@ armwave.c:262:     g_armwave_state.wave_length = end_point - start_point;
 252:armwave.c     ****     g_armwave_state.vscale_frac = target_height / 255.0f;
 253:armwave.c     ****     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 254:armwave.c     ****     g_armwave_state.wave_stride = wave_stride;
 255:armwave.c     ****     g_armwave_state.waves_max = waves_max;
 256:armwave.c     ****     g_armwave_state.waves = waves_max;  // Need a function to be able to change this on the fly
 257:armwave.c     ****     g_armwave_state.size = target_height * target_width;
 258:armwave.c     ****     g_armwave_state.bitdepth_height = 256 * sizeof(bufftyp_t);  // Always 256 possible levels in 8-
 259:armwave.c     ****     g_armwave_state.ch_buff_size = (g_armwave_state.bitdepth_height + 4) * (target_width + 4) * siz
 260:armwave.c     ****     g_armwave_state.target_width = target_width;
 261:armwave.c     ****     g_armwave_state.target_height = target_height;
 262:armwave.c     ****     g_armwave_state.wave_length = end_point - start_point;
 1152              		.loc 1 262 45 is_stmt 0 view .LVU294
 1153 0534 045045E0 		sub	r5, r5, r4	@ _13, end_point, start_point
 1154              	.LVL81:
 1155              	@ armwave.c:266:         ((g_armwave_state.target_width * (1.0f / g_armwave_state.wave_length))) * 
 263:armwave.c     **** 
 264:armwave.c     ****     // Calculate compound scaler
 265:armwave.c     ****     g_armwave_state.cmp_x_bitdepth_scale = \
 266:armwave.c     ****         ((g_armwave_state.target_width * (1.0f / g_armwave_state.wave_length))) * (1 << AM_XCOORD_M
 1156              		.loc 1 266 48 view .LVU295
 1157 0538 5B5A9FED 		vldr.32	s10, .L68	@ tmp187,
 1158 053c 905A07EE 		vmov	s15, r5	@ int	@ _13, _13
 1159              	@ armwave.c:252:     g_armwave_state.vscale_frac = target_height / 255.0f;
 252:armwave.c     ****     g_armwave_state.vscale_frac = target_height / 255.0f;
 1160              		.loc 1 252 49 view .LVU296
 1161 0540 5A7A9FED 		vldr.32	s14, .L68+4	@ tmp165,
 1162              	@ armwave.c:266:         ((g_armwave_state.target_width * (1.0f / g_armwave_state.wave_length))) * 
 1163              		.loc 1 266 81 view .LVU297
 1164 0544 5A6A9FED 		vldr.32	s12, .L68+8	@ tmp191,
 1165              	@ armwave.c:259:     g_armwave_state.ch_buff_size = (g_armwave_state.bitdepth_height + 4) * (target
 259:armwave.c     ****     g_armwave_state.target_width = target_width;
 1166              		.loc 1 259 90 view .LVU298
 1167 0548 043086E2 		add	r3, r6, #4	@ tmp176, target_width,
 1168              	@ armwave.c:266:         ((g_armwave_state.target_width * (1.0f / g_armwave_state.wave_length))) * 
 1169              		.loc 1 266 48 view .LVU299
 1170 054c E76AF8EE 		vcvt.f32.s32	s13, s15	@ tmp185, _13
 1171              	@ armwave.c:252:     g_armwave_state.vscale_frac = target_height / 255.0f;
 252:armwave.c     ****     g_armwave_state.vscale_frac = target_height / 255.0f;
 1172              		.loc 1 252 49 view .LVU300
 1173 0550 907A07EE 		vmov	s15, r7	@ int	@ target_height, target_height
 1174              	@ armwave.c:251:     g_armwave_state.xstride = target_height;
 251:armwave.c     ****     g_armwave_state.vscale_frac = target_height / 255.0f;
 1175              		.loc 1 251 29 view .LVU301
 1176 0554 60419FE5 		ldr	r4, .L68+16	@ tmp222,
 1177              	.LVL82:
 1178              	@ armwave.c:257:     g_armwave_state.size = target_height * target_width;
 257:armwave.c     ****     g_armwave_state.bitdepth_height = 256 * sizeof(bufftyp_t);  // Always 256 possible levels in 8-
 1179              		.loc 1 257 42 view .LVU302
 1180 0558 970601E0 		mul	r1, r7, r6	@ tmp173, target_height, target_width
 1181              	@ armwave.c:252:     g_armwave_state.vscale_frac = target_height / 255.0f;
 252:armwave.c     ****     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 1182              		.loc 1 252 49 view .LVU303
 1183 055c 675AF8EE 		vcvt.f32.u32	s11, s15	@ tmp164, target_height
 1184              	@ armwave.c:259:     g_armwave_state.ch_buff_size = (g_armwave_state.bitdepth_height + 4) * (target
 259:armwave.c     ****     g_armwave_state.target_width = target_width;
 1185              		.loc 1 259 95 view .LVU304
 1186 0560 833383E0 		add	r3, r3, r3, lsl #7	@ tmp179, tmp176, tmp176,
 1187              	@ armwave.c:268:     printf("ch_buff_size=%d, cmp_x_bitdepth_scale=%d (0x%08x), targ_width=%d, wave
 267:armwave.c     **** 
 268:armwave.c     ****     printf("ch_buff_size=%d, cmp_x_bitdepth_scale=%d (0x%08x), targ_width=%d, wave_length=%d, scale
 1188              		.loc 1 268 5 view .LVU305
 1189 0564 0128A0E3 		mov	r2, #65536	@ tmp194,
 1190              	@ armwave.c:266:         ((g_armwave_state.target_width * (1.0f / g_armwave_state.wave_length))) * 
 266:armwave.c     **** 
 1191              		.loc 1 266 48 view .LVU306
 1192 0568 267AC5EE 		vdiv.f32	s15, s10, s13	@ tmp186, tmp187, tmp185
 1193              	@ armwave.c:268:     printf("ch_buff_size=%d, cmp_x_bitdepth_scale=%d (0x%08x), targ_width=%d, wave
 1194              		.loc 1 268 5 view .LVU307
 1195 056c 04508DE5 		str	r5, [sp, #4]	@ _13,
 1196 0570 00608DE5 		str	r6, [sp]	@ target_width,
 1197              	@ armwave.c:259:     g_armwave_state.ch_buff_size = (g_armwave_state.bitdepth_height + 4) * (target
 259:armwave.c     ****     g_armwave_state.target_width = target_width;
 1198              		.loc 1 259 95 view .LVU308
 1199 0574 8331A0E1 		lsl	r3, r3, #3	@ tmp180, tmp179,
 1200              	@ armwave.c:251:     g_armwave_state.xstride = target_height;
 251:armwave.c     ****     g_armwave_state.vscale_frac = target_height / 255.0f;
 1201              		.loc 1 251 29 view .LVU309
 1202 0578 2C7084E5 		str	r7, [r4, #44]	@ target_height, g_armwave_state.xstride
 252:armwave.c     ****     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 1203              		.loc 1 252 5 is_stmt 1 view .LVU310
 1204              	@ armwave.c:254:     g_armwave_state.wave_stride = wave_stride;
 254:armwave.c     ****     g_armwave_state.waves_max = waves_max;
 1205              		.loc 1 254 33 is_stmt 0 view .LVU311
 1206 057c 349084E5 		str	r9, [r4, #52]	@ wave_stride, g_armwave_state.wave_stride
 1207              	@ armwave.c:255:     g_armwave_state.waves_max = waves_max;
 255:armwave.c     ****     g_armwave_state.waves = waves_max;  // Need a function to be able to change this on the fly
 1208              		.loc 1 255 31 view .LVU312
 1209 0580 3C8084E5 		str	r8, [r4, #60]	@ waves_max, g_armwave_state.waves_max
 1210              	@ armwave.c:256:     g_armwave_state.waves = waves_max;  // Need a function to be able to change th
 256:armwave.c     ****     g_armwave_state.size = target_height * target_width;
 1211              		.loc 1 256 27 view .LVU313
 1212 0584 388084E5 		str	r8, [r4, #56]	@ waves_max, g_armwave_state.waves
 1213              	@ armwave.c:261:     g_armwave_state.target_height = target_height;
 261:armwave.c     ****     g_armwave_state.wave_length = end_point - start_point;
 1214              		.loc 1 261 35 view .LVU314
 1215 0588 F865C4E1 		strd	r6, [r4, #88]	@, tmp222,
 1216              	@ armwave.c:268:     printf("ch_buff_size=%d, cmp_x_bitdepth_scale=%d (0x%08x), targ_width=%d, wave
 1217              		.loc 1 268 5 view .LVU315
 1218 058c 08208DE5 		str	r2, [sp, #8]	@ tmp194,
 1219              	@ armwave.c:258:     g_armwave_state.bitdepth_height = 256 * sizeof(bufftyp_t);  // Always 256 poss
 258:armwave.c     ****     g_armwave_state.ch_buff_size = (g_armwave_state.bitdepth_height + 4) * (target_width + 4) * siz
 1220              		.loc 1 258 37 view .LVU316
 1221 0590 022CA0E3 		mov	r2, #512	@ tmp175,
 1222              	@ armwave.c:257:     g_armwave_state.size = target_height * target_width;
 257:armwave.c     ****     g_armwave_state.bitdepth_height = 256 * sizeof(bufftyp_t);  // Always 256 possible levels in 8-
 1223              		.loc 1 257 26 view .LVU317
 1224 0594 541084E5 		str	r1, [r4, #84]	@ tmp173, g_armwave_state.size
 1225              	@ armwave.c:258:     g_armwave_state.bitdepth_height = 256 * sizeof(bufftyp_t);  // Always 256 poss
 258:armwave.c     ****     g_armwave_state.ch_buff_size = (g_armwave_state.bitdepth_height + 4) * (target_width + 4) * siz
 1226              		.loc 1 258 37 view .LVU318
 1227 0598 402084E5 		str	r2, [r4, #64]	@ tmp175, g_armwave_state.bitdepth_height
 1228              	@ armwave.c:268:     printf("ch_buff_size=%d, cmp_x_bitdepth_scale=%d (0x%08x), targ_width=%d, wave
 1229              		.loc 1 268 5 view .LVU319
 1230 059c 0310A0E1 		mov	r1, r3	@, tmp180
 1231              	@ armwave.c:259:     g_armwave_state.ch_buff_size = (g_armwave_state.bitdepth_height + 4) * (target
 259:armwave.c     ****     g_armwave_state.target_width = target_width;
 1232              		.loc 1 259 34 view .LVU320
 1233 05a0 503084E5 		str	r3, [r4, #80]	@ tmp180, g_armwave_state.ch_buff_size
 1234              	@ armwave.c:252:     g_armwave_state.vscale_frac = target_height / 255.0f;
 252:armwave.c     ****     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 1235              		.loc 1 252 49 view .LVU321
 1236 05a4 876AC5EE 		vdiv.f32	s13, s11, s14	@ _3, tmp164, tmp165
 1237              	@ armwave.c:266:         ((g_armwave_state.target_width * (1.0f / g_armwave_state.wave_length))) * 
 266:armwave.c     **** 
 1238              		.loc 1 266 40 view .LVU322
 1239 05a8 106A07EE 		vmov	s14, r6	@ int	@ target_width, target_width
 1240              	@ armwave.c:262:     g_armwave_state.wave_length = end_point - start_point;
 262:armwave.c     **** 
 1241              		.loc 1 262 33 view .LVU323
 1242 05ac 4C5084E5 		str	r5, [r4, #76]	@ _13, g_armwave_state.wave_length
 1243              	@ armwave.c:268:     printf("ch_buff_size=%d, cmp_x_bitdepth_scale=%d (0x%08x), targ_width=%d, wave
 1244              		.loc 1 268 5 view .LVU324
 1245 05b0 08019FE5 		ldr	r0, .L68+20	@,
 1246              	@ armwave.c:266:         ((g_armwave_state.target_width * (1.0f / g_armwave_state.wave_length))) * 
 266:armwave.c     **** 
 1247              		.loc 1 266 40 view .LVU325
 1248 05b4 C77AB8EE 		vcvt.f32.s32	s14, s14	@ tmp188, target_width
 1249 05b8 877A67EE 		vmul.f32	s15, s15, s14	@ tmp189, tmp186, tmp188
 1250              	@ armwave.c:253:     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 253:armwave.c     ****     g_armwave_state.wave_stride = wave_stride;
 1251              		.loc 1 253 30 view .LVU326
 1252 05bc E67ABDEE 		vcvt.s32.f32	s14, s13	@ tmp168, _3
 1253              	@ armwave.c:252:     g_armwave_state.vscale_frac = target_height / 255.0f;
 252:armwave.c     ****     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 1254              		.loc 1 252 33 view .LVU327
 1255 05c0 0A6AC4ED 		vstr.32	s13, [r4, #40]	@ _3, g_armwave_state.vscale_frac
 253:armwave.c     ****     g_armwave_state.wave_stride = wave_stride;
 1256              		.loc 1 253 5 is_stmt 1 view .LVU328
 1257              	@ armwave.c:266:         ((g_armwave_state.target_width * (1.0f / g_armwave_state.wave_length))) * 
 266:armwave.c     **** 
 1258              		.loc 1 266 81 is_stmt 0 view .LVU329
 1259 05c4 867A67EE 		vmul.f32	s15, s15, s12	@ tmp190, tmp189, tmp191
 1260              	@ armwave.c:253:     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 253:armwave.c     ****     g_armwave_state.wave_stride = wave_stride;
 1261              		.loc 1 253 30 view .LVU330
 1262 05c8 0C7A84ED 		vstr.32	s14, [r4, #48]	@ int	@ tmp168, g_armwave_state.vscale
 254:armwave.c     ****     g_armwave_state.waves_max = waves_max;
 1263              		.loc 1 254 5 is_stmt 1 view .LVU331
 255:armwave.c     ****     g_armwave_state.waves = waves_max;  // Need a function to be able to change this on the fly
 1264              		.loc 1 255 5 view .LVU332
 256:armwave.c     ****     g_armwave_state.size = target_height * target_width;
 1265              		.loc 1 256 5 view .LVU333
 257:armwave.c     ****     g_armwave_state.bitdepth_height = 256 * sizeof(bufftyp_t);  // Always 256 possible levels in 8-
 1266              		.loc 1 257 5 view .LVU334
 258:armwave.c     ****     g_armwave_state.ch_buff_size = (g_armwave_state.bitdepth_height + 4) * (target_width + 4) * siz
 1267              		.loc 1 258 5 view .LVU335
 259:armwave.c     ****     g_armwave_state.target_width = target_width;
 1268              		.loc 1 259 5 view .LVU336
 260:armwave.c     ****     g_armwave_state.target_height = target_height;
 1269              		.loc 1 260 5 view .LVU337
 261:armwave.c     ****     g_armwave_state.wave_length = end_point - start_point;
 1270              		.loc 1 261 5 view .LVU338
 262:armwave.c     **** 
 1271              		.loc 1 262 5 view .LVU339
 265:armwave.c     ****         ((g_armwave_state.target_width * (1.0f / g_armwave_state.wave_length))) * (1 << AM_XCOORD_M
 1272              		.loc 1 265 5 view .LVU340
 1273              	@ armwave.c:265:     g_armwave_state.cmp_x_bitdepth_scale = \
 265:armwave.c     ****         ((g_armwave_state.target_width * (1.0f / g_armwave_state.wave_length))) * (1 << AM_XCOORD_M
 1274              		.loc 1 265 42 is_stmt 0 view .LVU341
 1275 05cc E77AFCEE 		vcvt.u32.f32	s15, s15	@ _20, tmp190
 1276 05d0 90CA17EE 		vmov	ip, s15	@ int	@ _20, _20
 1277              	@ armwave.c:268:     printf("ch_buff_size=%d, cmp_x_bitdepth_scale=%d (0x%08x), targ_width=%d, wave
 1278              		.loc 1 268 5 view .LVU342
 1279 05d4 903A17EE 		vmov	r3, s15	@ int	@, _20
 1280              	@ armwave.c:265:     g_armwave_state.cmp_x_bitdepth_scale = \
 265:armwave.c     ****         ((g_armwave_state.target_width * (1.0f / g_armwave_state.wave_length))) * (1 << AM_XCOORD_M
 1281              		.loc 1 265 42 view .LVU343
 1282 05d8 097AC4ED 		vstr.32	s15, [r4, #36]	@ int	@ _20, g_armwave_state.cmp_x_bitdepth_scale
 1283              		.loc 1 268 5 is_stmt 1 view .LVU344
 1284 05dc 0C20A0E1 		mov	r2, ip	@, tmp3
 1285 05e0 FEFFFFEB 		bl	printf		@
 1286              	.LVL83:
 269:armwave.c     ****         g_armwave_state.ch_buff_size, g_armwave_state.cmp_x_bitdepth_scale, \
 270:armwave.c     ****         g_armwave_state.cmp_x_bitdepth_scale, g_armwave_state.target_width, g_armwave_state.wave_le
 271:armwave.c     ****         (1 << AM_XCOORD_MULT_SHIFT));
 272:armwave.c     **** 
 273:armwave.c     ****     // In 1ch mode, target 1024 x 16 render buffer, reading 16 bytes at a time from each wave, reta
 274:armwave.c     ****     // In 2ch mode, target two 1024 x 8 render buffers, reading 16 bytes at a time from each wave
 275:armwave.c     ****     // In 4ch mode, target four 1024 x 4 render buffers, reading 16 bytes at a time from each wave
 276:armwave.c     ****     g_armwave_state.slice_height = 64; // 64;  
 1287              		.loc 1 276 5 view .LVU345
 1288              	@ armwave.c:278:     if(g_armwave_state.ch1_buffer != NULL)
 277:armwave.c     **** 
 278:armwave.c     ****     if(g_armwave_state.ch1_buffer != NULL)
 1289              		.loc 1 278 23 is_stmt 0 view .LVU346
 1290 05e4 040094E5 		ldr	r0, [r4, #4]	@ _21, g_armwave_state.ch1_buffer
 1291              	@ armwave.c:276:     g_armwave_state.slice_height = 64; // 64;  
 276:armwave.c     **** 
 1292              		.loc 1 276 34 view .LVU347
 1293 05e8 4030A0E3 		mov	r3, #64	@ tmp196,
 1294              	@ armwave.c:278:     if(g_armwave_state.ch1_buffer != NULL)
 1295              		.loc 1 278 7 view .LVU348
 1296 05ec 000050E3 		cmp	r0, #0	@ _21,
 1297              	@ armwave.c:276:     g_armwave_state.slice_height = 64; // 64;  
 276:armwave.c     **** 
 1298              		.loc 1 276 34 view .LVU349
 1299 05f0 443084E5 		str	r3, [r4, #68]	@ tmp196, g_armwave_state.slice_height
 1300              		.loc 1 278 5 is_stmt 1 view .LVU350
 1301              	@ armwave.c:278:     if(g_armwave_state.ch1_buffer != NULL)
 1302              		.loc 1 278 7 is_stmt 0 view .LVU351
 1303 05f4 0000000A 		beq	.L60		@,
 279:armwave.c     ****         free(g_armwave_state.ch1_buffer);
 1304              		.loc 1 279 9 is_stmt 1 view .LVU352
 1305 05f8 FEFFFFEB 		bl	free		@
 1306              	.LVL84:
 1307              	.L60:
 280:armwave.c     **** 
 281:armwave.c     ****     g_armwave_state.ch1_buffer = calloc(g_armwave_state.ch_buff_size, 1);
 1308              		.loc 1 281 5 view .LVU353
 1309              	@ armwave.c:281:     g_armwave_state.ch1_buffer = calloc(g_armwave_state.ch_buff_size, 1);
 1310              		.loc 1 281 56 is_stmt 0 view .LVU354
 1311 05fc 508094E5 		ldr	r8, [r4, #80]	@ _22, g_armwave_state.ch_buff_size
 1312              	.LVL85:
 1313              	@ armwave.c:281:     g_armwave_state.ch1_buffer = calloc(g_armwave_state.ch_buff_size, 1);
 1314              		.loc 1 281 34 view .LVU355
 1315 0600 0110A0E3 		mov	r1, #1	@,
 1316 0604 0800A0E1 		mov	r0, r8	@, _22
 1317 0608 FEFFFFEB 		bl	calloc		@
 1318              	.LVL86:
 1319              	@ armwave.c:283:     if(g_armwave_state.ch1_buffer == NULL) {
 282:armwave.c     **** 
 283:armwave.c     ****     if(g_armwave_state.ch1_buffer == NULL) {
 1320              		.loc 1 283 7 view .LVU356
 1321 060c 000050E3 		cmp	r0, #0	@ tmp199,
 1322              	@ armwave.c:281:     g_armwave_state.ch1_buffer = calloc(g_armwave_state.ch_buff_size, 1);
 281:armwave.c     **** 
 1323              		.loc 1 281 34 view .LVU357
 1324 0610 0070A0E1 		mov	r7, r0	@ tmp199,
 1325              	@ armwave.c:281:     g_armwave_state.ch1_buffer = calloc(g_armwave_state.ch_buff_size, 1);
 281:armwave.c     **** 
 1326              		.loc 1 281 32 view .LVU358
 1327 0614 040084E5 		str	r0, [r4, #4]	@ tmp199, g_armwave_state.ch1_buffer
 1328              		.loc 1 283 5 is_stmt 1 view .LVU359
 1329              	@ armwave.c:283:     if(g_armwave_state.ch1_buffer == NULL) {
 1330              		.loc 1 283 7 is_stmt 0 view .LVU360
 1331 0618 1C00000A 		beq	.L67		@,
 284:armwave.c     ****         fprintf(stderr, "malloc failure allocating %d bytes (g_armwave_state.ch1_buffer)\n", g_armw
 285:armwave.c     ****         exit(-1);
 286:armwave.c     ****     }
 287:armwave.c     **** 
 288:armwave.c     ****     // Precompute the x-coord to pixel lookup to reduce ALU load
 289:armwave.c     ****     length = end_point - start_point;
 1332              		.loc 1 289 5 is_stmt 1 view .LVU361
 1333              	.LVL87:
 290:armwave.c     ****     points_per_pixel = length / ((float)(target_width));
 1334              		.loc 1 290 5 view .LVU362
 291:armwave.c     ****     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice_height;
 1335              		.loc 1 291 5 view .LVU363
 1336              	@ armwave.c:290:     points_per_pixel = length / ((float)(target_width));
 290:armwave.c     ****     points_per_pixel = length / ((float)(target_width));
 1337              		.loc 1 290 31 is_stmt 0 view .LVU364
 1338 061c 905A07EE 		vmov	s15, r5	@ int	@ _13, _13
 1339              	@ armwave.c:290:     points_per_pixel = length / ((float)(target_width));
 290:armwave.c     ****     points_per_pixel = length / ((float)(target_width));
 1340              		.loc 1 290 34 view .LVU365
 1341 0620 106A07EE 		vmov	s14, r6	@ int	@ target_width, target_width
 1342              	@ armwave.c:291:     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice
 1343              		.loc 1 291 60 view .LVU366
 1344 0624 116AD4ED 		vldr.32	s13, [r4, #68]	@ int	@ tmp232, g_armwave_state.slice_height
 1345              	@ armwave.c:305:     g_armwave_state.out_pixbuf = malloc(sizeof(uint32_t) * g_armwave_state.size);
 292:armwave.c     **** 
 293:armwave.c     ****     /*
 294:armwave.c     ****     g_armwave_state.xcoord_to_xpixel = malloc(length * sizeof(uint16_t));
 295:armwave.c     **** 
 296:armwave.c     ****     assert(g_armwave_state.xcoord_to_xpixel != NULL);
 297:armwave.c     **** 
 298:armwave.c     ****     for(xx = 0; xx < length; xx++) {
 299:armwave.c     ****         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 300:armwave.c     **** 
 301:armwave.c     ****         // printf("xcoord_to_xpixel[%5d] = %5d (scale:%8.3f)\n", xx, g_armwave_state.xcoord_to_xpix
 302:armwave.c     ****     }
 303:armwave.c     ****     */
 304:armwave.c     **** 
 305:armwave.c     ****     g_armwave_state.out_pixbuf = malloc(sizeof(uint32_t) * g_armwave_state.size);
 1346              		.loc 1 305 34 view .LVU367
 1347 0628 540094E5 		ldr	r0, [r4, #84]	@ g_armwave_state.size, g_armwave_state.size
 1348              	@ armwave.c:290:     points_per_pixel = length / ((float)(target_width));
 290:armwave.c     ****     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice_height;
 1349              		.loc 1 290 31 view .LVU368
 1350 062c 677AF8EE 		vcvt.f32.u32	s15, s15	@ tmp204, _13
 1351              	@ armwave.c:290:     points_per_pixel = length / ((float)(target_width));
 290:armwave.c     ****     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice_height;
 1352              		.loc 1 290 34 view .LVU369
 1353 0630 477AB8EE 		vcvt.f32.u32	s14, s14	@ tmp205, target_width
 1354              	@ armwave.c:291:     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice
 291:armwave.c     ****     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice_height;
 1355              		.loc 1 291 60 view .LVU370
 1356 0634 E66AB8EE 		vcvt.f32.s32	s12, s13	@ tmp208, tmp232
 1357              	@ armwave.c:305:     g_armwave_state.out_pixbuf = malloc(sizeof(uint32_t) * g_armwave_state.size);
 1358              		.loc 1 305 34 view .LVU371
 1359 0638 0001A0E1 		lsl	r0, r0, #2	@, g_armwave_state.size,
 1360              	@ armwave.c:290:     points_per_pixel = length / ((float)(target_width));
 290:armwave.c     ****     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice_height;
 1361              		.loc 1 290 22 view .LVU372
 1362 063c 876AC7EE 		vdiv.f32	s13, s15, s14	@ points_per_pixel, tmp204, tmp205
 1363              	.LVL88:
 1364              	@ armwave.c:291:     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice
 291:armwave.c     ****     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice_height;
 1365              		.loc 1 291 60 view .LVU373
 1366 0640 867A66EE 		vmul.f32	s15, s13, s12	@ tmp210, points_per_pixel, tmp208
 1367              	@ armwave.c:291:     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice
 291:armwave.c     ****     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice_height;
 1368              		.loc 1 291 41 view .LVU374
 1369 0644 E77AFDEE 		vcvt.s32.f32	s15, s15	@ tmp211, tmp210
 1370 0648 127AC4ED 		vstr.32	s15, [r4, #72]	@ int	@ tmp211, g_armwave_state.slice_record_height
 1371              		.loc 1 305 5 is_stmt 1 view .LVU375
 1372              	@ armwave.c:305:     g_armwave_state.out_pixbuf = malloc(sizeof(uint32_t) * g_armwave_state.size);
 1373              		.loc 1 305 34 is_stmt 0 view .LVU376
 1374 064c FEFFFFEB 		bl	malloc		@
 1375              	.LVL89:
 1376              	@ armwave.c:307:     printf("Ptrs: 0x%08x 0x%08x 0x%08x 0x%08x \n", \
 306:armwave.c     **** 
 307:armwave.c     ****     printf("Ptrs: 0x%08x 0x%08x 0x%08x 0x%08x \n", \
 1377              		.loc 1 307 5 view .LVU377
 1378 0650 182094E5 		ldr	r2, [r4, #24]	@ g_armwave_state.test_wave_buffer, g_armwave_state.test_wave_buffer
 1379 0654 0710A0E1 		mov	r1, r7	@, tmp199
 1380 0658 30208DE5 		str	r2, [sp, #48]	@ g_armwave_state.test_wave_buffer,
 1381 065c 842094E5 		ldr	r2, [r4, #132]	@, g_armwave_state.xcoord_to_xpixel
 1382              	@ armwave.c:305:     g_armwave_state.out_pixbuf = malloc(sizeof(uint32_t) * g_armwave_state.size);
 305:armwave.c     **** 
 1383              		.loc 1 305 34 view .LVU378
 1384 0660 00C0A0E1 		mov	ip, r0	@ tmp215,
 1385              	@ armwave.c:307:     printf("Ptrs: 0x%08x 0x%08x 0x%08x 0x%08x \n", \
 1386              		.loc 1 307 5 view .LVU379
 1387 0664 0030A0E1 		mov	r3, r0	@, tmp215
 1388              	@ armwave.c:305:     g_armwave_state.out_pixbuf = malloc(sizeof(uint32_t) * g_armwave_state.size);
 305:armwave.c     **** 
 1389              		.loc 1 305 32 view .LVU380
 1390 0668 68C084E5 		str	ip, [r4, #104]	@ tmp215, g_armwave_state.out_pixbuf
 1391              		.loc 1 307 5 is_stmt 1 view .LVU381
 1392 066c 50009FE5 		ldr	r0, .L68+24	@,
 1393              	@ armwave.c:314: }
 308:armwave.c     ****         (uint32_t)g_armwave_state.ch1_buffer, \
 309:armwave.c     ****         (uint32_t)g_armwave_state.xcoord_to_xpixel, \
 310:armwave.c     ****         (uint32_t)g_armwave_state.out_pixbuf, \
 311:armwave.c     ****         (uint32_t)g_armwave_state.test_wave_buffer);
 312:armwave.c     **** 
 313:armwave.c     ****      //malloc_stats();
 314:armwave.c     **** }
 1394              		.loc 1 314 1 is_stmt 0 view .LVU382
 1395 0670 14D08DE2 		add	sp, sp, #20	@,,
 1396              		.cfi_remember_state
 1397              		.cfi_def_cfa_offset 28
 1398              		@ sp needed	@
 1399 0674 F043BDE8 		pop	{r4, r5, r6, r7, r8, r9, lr}	@
 1400              		.cfi_restore 14
 1401              		.cfi_restore 9
 1402              		.cfi_restore 8
 1403              		.cfi_restore 7
 1404              		.cfi_restore 6
 1405              		.cfi_restore 5
 1406              		.cfi_restore 4
 1407              		.cfi_def_cfa_offset 0
 1408              	.LVL90:
 1409              	@ armwave.c:307:     printf("Ptrs: 0x%08x 0x%08x 0x%08x 0x%08x \n", \
 307:armwave.c     ****         (uint32_t)g_armwave_state.ch1_buffer, \
 1410              		.loc 1 307 5 view .LVU383
 1411 0678 FEFFFFEA 		b	printf		@
 1412              	.LVL91:
 1413              	.L66:
 1414              		.cfi_restore_state
 230:armwave.c     **** 
 1415              		.loc 1 230 5 is_stmt 1 discriminator 1 view .LVU384
 1416 067c 44309FE5 		ldr	r3, .L68+28	@,
 1417 0680 E620A0E3 		mov	r2, #230	@,
 1418 0684 40109FE5 		ldr	r1, .L68+32	@,
 1419 0688 40009FE5 		ldr	r0, .L68+36	@,
 1420 068c FEFFFFEB 		bl	__assert_fail		@
 1421              	.LVL92:
 1422              	.L67:
 284:armwave.c     ****         exit(-1);
 1423              		.loc 1 284 9 view .LVU385
 1424 0690 3C309FE5 		ldr	r3, .L68+40	@ tmp202,
 1425 0694 0820A0E1 		mov	r2, r8	@, _22
 1426 0698 38109FE5 		ldr	r1, .L68+44	@,
 1427 069c 000093E5 		ldr	r0, [r3]	@, stderr
 1428 06a0 FEFFFFEB 		bl	fprintf		@
 1429              	.LVL93:
 285:armwave.c     ****     }
 1430              		.loc 1 285 9 view .LVU386
 1431 06a4 0000E0E3 		mvn	r0, #0	@,
 1432 06a8 FEFFFFEB 		bl	exit		@
 1433              	.LVL94:
 1434              	.L69:
 1435              		.align	2
 1436              	.L68:
 1437 06ac 0000803F 		.word	1065353216
 1438 06b0 00007F43 		.word	1132396544
 1439 06b4 00008047 		.word	1199570944
 1440 06b8 38010000 		.word	.LC9
 1441 06bc 00000000 		.word	g_armwave_state
 1442 06c0 88010000 		.word	.LC12
 1443 06c4 2C020000 		.word	.LC14
 1444 06c8 00000000 		.word	.LANCHOR0
 1445 06cc 64010000 		.word	.LC10
 1446 06d0 70010000 		.word	.LC11
 1447 06d4 00000000 		.word	stderr
 1448 06d8 E8010000 		.word	.LC13
 1449              		.cfi_endproc
 1450              	.LFE62:
 1452              		.align	2
 1453              		.global	armwave_set_wave_pointer
 1454              		.syntax unified
 1455              		.arm
 1456              		.fpu vfp
 1458              	armwave_set_wave_pointer:
 1459              	.LVL95:
 1460              	.LFB63:
 315:armwave.c     **** 
 316:armwave.c     **** /*
 317:armwave.c     ****  * Set wave buffer pointer.  This needs to be changed to support disjointed buffers
 318:armwave.c     ****  * in the future.
 319:armwave.c     ****  */
 320:armwave.c     **** void armwave_set_wave_pointer(uint8_t *wave_buffer)
 321:armwave.c     **** {
 1461              		.loc 1 321 1 view -0
 1462              		.cfi_startproc
 1463              		@ args = 0, pretend = 0, frame = 0
 1464              		@ frame_needed = 0, uses_anonymous_args = 0
 322:armwave.c     ****     assert(wave_buffer != NULL);
 1465              		.loc 1 322 5 view .LVU388
 1466 06dc 000050E3 		cmp	r0, #0	@ wave_buffer
 1467              		.loc 1 322 5 is_stmt 0 view .LVU389
 1468 06e0 0200000A 		beq	.L75		@,
 323:armwave.c     ****     g_armwave_state.wave_buffer = wave_buffer;
 1469              		.loc 1 323 5 is_stmt 1 view .LVU390
 1470              	@ armwave.c:323:     g_armwave_state.wave_buffer = wave_buffer;
 1471              		.loc 1 323 33 is_stmt 0 view .LVU391
 1472 06e4 1C309FE5 		ldr	r3, .L76	@ tmp116,
 1473 06e8 140083E5 		str	r0, [r3, #20]	@ wave_buffer, g_armwave_state.wave_buffer
 1474 06ec 1EFF2FE1 		bx	lr	@
 1475              	.L75:
 322:armwave.c     ****     assert(wave_buffer != NULL);
 1476              		.loc 1 322 5 is_stmt 1 discriminator 1 view .LVU392
 1477              	@ armwave.c:321: {
 321:armwave.c     ****     assert(wave_buffer != NULL);
 1478              		.loc 1 321 1 is_stmt 0 discriminator 1 view .LVU393
 1479 06f0 10402DE9 		push	{r4, lr}	@
 1480              		.cfi_def_cfa_offset 8
 1481              		.cfi_offset 4, -8
 1482              		.cfi_offset 14, -4
 1483              	@ armwave.c:322:     assert(wave_buffer != NULL);
 322:armwave.c     ****     assert(wave_buffer != NULL);
 1484              		.loc 1 322 5 discriminator 1 view .LVU394
 1485 06f4 10309FE5 		ldr	r3, .L76+4	@,
 1486 06f8 10209FE5 		ldr	r2, .L76+8	@,
 1487 06fc 10109FE5 		ldr	r1, .L76+12	@,
 1488 0700 10009FE5 		ldr	r0, .L76+16	@,
 1489              	.LVL96:
 322:armwave.c     ****     assert(wave_buffer != NULL);
 1490              		.loc 1 322 5 discriminator 1 view .LVU395
 1491 0704 FEFFFFEB 		bl	__assert_fail		@
 1492              	.LVL97:
 1493              	.L77:
 1494              		.align	2
 1495              	.L76:
 1496 0708 00000000 		.word	g_armwave_state
 1497 070c 18000000 		.word	.LANCHOR0+24
 1498 0710 42010000 		.word	322
 1499 0714 64010000 		.word	.LC10
 1500 0718 50020000 		.word	.LC15
 1501              		.cfi_endproc
 1502              	.LFE63:
 1504              		.align	2
 1505              		.global	armwave_set_wave_pointer_as_testbuf
 1506              		.syntax unified
 1507              		.arm
 1508              		.fpu vfp
 1510              	armwave_set_wave_pointer_as_testbuf:
 1511              	.LVL98:
 1512              	.LFB64:
 324:armwave.c     **** }
 325:armwave.c     **** 
 326:armwave.c     **** /*
 327:armwave.c     ****  * Set the wave buffer pointer as the test waveform buffer filled by such functions
 328:armwave.c     ****  * as `armwave_test_create_square` and `armwave_test_create_am_sine`.
 329:armwave.c     ****  */
 330:armwave.c     **** void armwave_set_wave_pointer_as_testbuf(int set)
 331:armwave.c     **** {
 1513              		.loc 1 331 1 is_stmt 1 view -0
 1514              		.cfi_startproc
 1515              		@ args = 0, pretend = 0, frame = 0
 1516              		@ frame_needed = 0, uses_anonymous_args = 0
 1517              		@ link register save eliminated.
 332:armwave.c     ****     if(set > g_armwave_state.test_wave_buffer_nsets) {
 1518              		.loc 1 332 5 view .LVU397
 1519              	@ armwave.c:332:     if(set > g_armwave_state.test_wave_buffer_nsets) {
 1520              		.loc 1 332 29 is_stmt 0 view .LVU398
 1521 071c 24309FE5 		ldr	r3, .L81	@ tmp117,
 1522              	@ armwave.c:332:     if(set > g_armwave_state.test_wave_buffer_nsets) {
 1523              		.loc 1 332 7 view .LVU399
 1524 0720 202093E5 		ldr	r2, [r3, #32]	@ g_armwave_state.test_wave_buffer_nsets, g_armwave_state.test_wave_buffer_nsets
 1525 0724 000052E1 		cmp	r2, r0	@ g_armwave_state.test_wave_buffer_nsets, set
 1526 0728 0400003A 		bcc	.L80		@,
 333:armwave.c     ****         printf("armwave_set_wave_pointer_as_testbuf: error, nsets exceeded\n");
 334:armwave.c     ****         return;
 335:armwave.c     ****     }
 336:armwave.c     **** 
 337:armwave.c     ****     g_armwave_state.wave_buffer = g_armwave_state.test_wave_buffer + (g_armwave_state.test_wave_buf
 1527              		.loc 1 337 5 is_stmt 1 view .LVU400
 1528              	@ armwave.c:337:     g_armwave_state.wave_buffer = g_armwave_state.test_wave_buffer + (g_armwave_st
 1529              		.loc 1 337 111 is_stmt 0 view .LVU401
 1530 072c 1C1093E5 		ldr	r1, [r3, #28]	@ g_armwave_state.test_wave_buffer_stride, g_armwave_state.test_wave_buffer_stri
 1531              	@ armwave.c:337:     g_armwave_state.wave_buffer = g_armwave_state.test_wave_buffer + (g_armwave_st
 1532              		.loc 1 337 68 view .LVU402
 1533 0730 182093E5 		ldr	r2, [r3, #24]	@ g_armwave_state.test_wave_buffer, g_armwave_state.test_wave_buffer
 1534 0734 912020E0 		mla	r0, r1, r0, r2	@ tmp125, g_armwave_state.test_wave_buffer_stride, set, g_armwave_state.test_wa
 1535              	.LVL99:
 1536              	@ armwave.c:337:     g_armwave_state.wave_buffer = g_armwave_state.test_wave_buffer + (g_armwave_st
 1537              		.loc 1 337 33 view .LVU403
 1538 0738 140083E5 		str	r0, [r3, #20]	@ tmp125, g_armwave_state.wave_buffer
 1539              	@ armwave.c:338: }
 338:armwave.c     **** }
 1540              		.loc 1 338 1 view .LVU404
 1541 073c 1EFF2FE1 		bx	lr	@
 1542              	.LVL100:
 1543              	.L80:
 333:armwave.c     ****         printf("armwave_set_wave_pointer_as_testbuf: error, nsets exceeded\n");
 1544              		.loc 1 333 9 is_stmt 1 view .LVU405
 1545 0740 04009FE5 		ldr	r0, .L81+4	@,
 1546              	.LVL101:
 333:armwave.c     ****         printf("armwave_set_wave_pointer_as_testbuf: error, nsets exceeded\n");
 1547              		.loc 1 333 9 is_stmt 0 view .LVU406
 1548 0744 FEFFFFEA 		b	puts		@
 1549              	.LVL102:
 1550              	.L82:
 1551              		.align	2
 1552              	.L81:
 1553 0748 00000000 		.word	g_armwave_state
 1554 074c 64020000 		.word	.LC16
 1555              		.cfi_endproc
 1556              	.LFE64:
 1558              		.align	2
 1559              		.global	armwave_set_wave_pointer_u32
 1560              		.syntax unified
 1561              		.arm
 1562              		.fpu vfp
 1564              	armwave_set_wave_pointer_u32:
 1565              	.LVL103:
 1566              	.LFB65:
 339:armwave.c     **** 
 340:armwave.c     **** /*
 341:armwave.c     ****  * Set wave buffer pointer from a 32-bit uint.  This needs to be changed to support 
 342:armwave.c     ****  * disjointed buffers in the future.
 343:armwave.c     ****  */
 344:armwave.c     **** void armwave_set_wave_pointer_u32(uint32_t wave_buffer_ptr)
 345:armwave.c     **** {
 1567              		.loc 1 345 1 is_stmt 1 view -0
 1568              		.cfi_startproc
 1569              		@ args = 0, pretend = 0, frame = 0
 1570              		@ frame_needed = 0, uses_anonymous_args = 0
 346:armwave.c     ****     assert(wave_buffer_ptr != 0);
 1571              		.loc 1 346 5 view .LVU408
 1572 0750 000050E3 		cmp	r0, #0	@ wave_buffer_ptr
 1573              		.loc 1 346 5 is_stmt 0 view .LVU409
 1574 0754 0200000A 		beq	.L88		@,
 347:armwave.c     ****     g_armwave_state.wave_buffer = (uint8_t*)wave_buffer_ptr;
 1575              		.loc 1 347 5 is_stmt 1 view .LVU410
 1576              	@ armwave.c:347:     g_armwave_state.wave_buffer = (uint8_t*)wave_buffer_ptr;
 1577              		.loc 1 347 33 is_stmt 0 view .LVU411
 1578 0758 1C309FE5 		ldr	r3, .L89	@ tmp117,
 1579 075c 140083E5 		str	r0, [r3, #20]	@ wave_buffer_ptr, g_armwave_state.wave_buffer
 1580 0760 1EFF2FE1 		bx	lr	@
 1581              	.L88:
 346:armwave.c     ****     assert(wave_buffer_ptr != 0);
 1582              		.loc 1 346 5 is_stmt 1 discriminator 1 view .LVU412
 1583              	@ armwave.c:345: {
 345:armwave.c     ****     assert(wave_buffer_ptr != 0);
 1584              		.loc 1 345 1 is_stmt 0 discriminator 1 view .LVU413
 1585 0764 10402DE9 		push	{r4, lr}	@
 1586              		.cfi_def_cfa_offset 8
 1587              		.cfi_offset 4, -8
 1588              		.cfi_offset 14, -4
 1589              	@ armwave.c:346:     assert(wave_buffer_ptr != 0);
 346:armwave.c     ****     assert(wave_buffer_ptr != 0);
 1590              		.loc 1 346 5 discriminator 1 view .LVU414
 1591 0768 10309FE5 		ldr	r3, .L89+4	@,
 1592 076c 10209FE5 		ldr	r2, .L89+8	@,
 1593 0770 10109FE5 		ldr	r1, .L89+12	@,
 1594 0774 10009FE5 		ldr	r0, .L89+16	@,
 1595              	.LVL104:
 346:armwave.c     ****     assert(wave_buffer_ptr != 0);
 1596              		.loc 1 346 5 discriminator 1 view .LVU415
 1597 0778 FEFFFFEB 		bl	__assert_fail		@
 1598              	.LVL105:
 1599              	.L90:
 1600              		.align	2
 1601              	.L89:
 1602 077c 00000000 		.word	g_armwave_state
 1603 0780 34000000 		.word	.LANCHOR0+52
 1604 0784 5A010000 		.word	346
 1605 0788 64010000 		.word	.LC10
 1606 078c A0020000 		.word	.LC17
 1607              		.cfi_endproc
 1608              	.LFE65:
 1610              		.align	2
 1611              		.global	armwave_clear_buffer
 1612              		.syntax unified
 1613              		.arm
 1614              		.fpu vfp
 1616              	armwave_clear_buffer:
 1617              	.LVL106:
 1618              	.LFB66:
 348:armwave.c     **** }
 349:armwave.c     **** 
 350:armwave.c     **** /*
 351:armwave.c     ****  * Clear the working buffer (fill it with all zeros.)
 352:armwave.c     ****  */
 353:armwave.c     **** void armwave_clear_buffer(uint32_t flags)
 354:armwave.c     **** {
 1619              		.loc 1 354 1 is_stmt 1 view -0
 1620              		.cfi_startproc
 1621              		@ args = 0, pretend = 0, frame = 0
 1622              		@ frame_needed = 0, uses_anonymous_args = 0
 1623              		@ link register save eliminated.
 355:armwave.c     ****     // Flags ignored, only one buffer cleared
 356:armwave.c     ****     memset(g_armwave_state.ch1_buffer, 0, g_armwave_state.ch_buff_size);
 1624              		.loc 1 356 5 view .LVU417
 1625              	@ armwave.c:356:     memset(g_armwave_state.ch1_buffer, 0, g_armwave_state.ch_buff_size);
 1626              		.loc 1 356 58 is_stmt 0 view .LVU418
 1627 0790 0C309FE5 		ldr	r3, .L92	@ tmp114,
 1628              	@ armwave.c:356:     memset(g_armwave_state.ch1_buffer, 0, g_armwave_state.ch_buff_size);
 1629              		.loc 1 356 5 view .LVU419
 1630 0794 0010A0E3 		mov	r1, #0	@,
 1631 0798 502093E5 		ldr	r2, [r3, #80]	@, g_armwave_state.ch_buff_size
 1632 079c 040093E5 		ldr	r0, [r3, #4]	@, g_armwave_state.ch1_buffer
 1633              	.LVL107:
 1634              		.loc 1 356 5 view .LVU420
 1635 07a0 FEFFFFEA 		b	memset		@
 1636              	.LVL108:
 1637              	.L93:
 1638              		.align	2
 1639              	.L92:
 1640 07a4 00000000 		.word	g_armwave_state
 1641              		.cfi_endproc
 1642              	.LFE66:
 1644              		.align	2
 1645              		.global	armwave_set_channel_colour
 1646              		.syntax unified
 1647              		.arm
 1648              		.fpu vfp
 1650              	armwave_set_channel_colour:
 1651              	.LVL109:
 1652              	.LFB67:
 357:armwave.c     **** }
 358:armwave.c     **** 
 359:armwave.c     **** /*
 360:armwave.c     ****  * Set the render colour for a channel.  R/G/B may exceed 255 for saturation effects.
 361:armwave.c     ****  */
 362:armwave.c     **** void armwave_set_channel_colour(int ch, int r, int g, int b)
 363:armwave.c     **** {
 1653              		.loc 1 363 1 is_stmt 1 view -0
 1654              		.cfi_startproc
 1655              		@ args = 0, pretend = 0, frame = 0
 1656              		@ frame_needed = 0, uses_anonymous_args = 0
 1657              		@ link register save eliminated.
 364:armwave.c     ****     // Only 1ch supported for now
 365:armwave.c     ****     switch(ch) {
 1658              		.loc 1 365 5 view .LVU422
 1659 07a8 010050E3 		cmp	r0, #1	@ ch,
 366:armwave.c     ****         case 1:
 367:armwave.c     ****             g_armwave_state.ch1_color.r = r;
 1660              		.loc 1 367 13 view .LVU423
 1661              	@ armwave.c:367:             g_armwave_state.ch1_color.r = r;
 1662              		.loc 1 367 41 is_stmt 0 view .LVU424
 1663 07ac 0C009F05 		ldreq	r0, .L96	@ tmp117,
 1664              	.LVL110:
 1665              		.loc 1 367 41 view .LVU425
 1666 07b0 BC16C001 		strheq	r1, [r0, #108]	@ movhi	@ r, g_armwave_state.ch1_color.r
 368:armwave.c     ****             g_armwave_state.ch1_color.g = g;
 1667              		.loc 1 368 13 is_stmt 1 view .LVU426
 1668              	@ armwave.c:368:             g_armwave_state.ch1_color.g = g;
 1669              		.loc 1 368 41 is_stmt 0 view .LVU427
 1670 07b4 BE26C001 		strheq	r2, [r0, #110]	@ movhi	@ g, g_armwave_state.ch1_color.g
 369:armwave.c     ****             g_armwave_state.ch1_color.b = b;
 1671              		.loc 1 369 13 is_stmt 1 view .LVU428
 1672              	@ armwave.c:369:             g_armwave_state.ch1_color.b = b;
 1673              		.loc 1 369 41 is_stmt 0 view .LVU429
 1674 07b8 B037C001 		strheq	r3, [r0, #112]	@ movhi	@ b, g_armwave_state.ch1_color.b
 370:armwave.c     ****             break;
 1675              		.loc 1 370 13 is_stmt 1 view .LVU430
 1676              	@ armwave.c:372: }
 371:armwave.c     ****     }
 372:armwave.c     **** }
 1677              		.loc 1 372 1 is_stmt 0 view .LVU431
 1678 07bc 1EFF2FE1 		bx	lr	@
 1679              	.L97:
 1680              		.align	2
 1681              	.L96:
 1682 07c0 00000000 		.word	g_armwave_state
 1683              		.cfi_endproc
 1684              	.LFE67:
 1686              		.align	2
 1687              		.global	armwave_dump_ppm_debug
 1688              		.syntax unified
 1689              		.arm
 1690              		.fpu vfp
 1692              	armwave_dump_ppm_debug:
 1693              	.LVL111:
 1694              	.LFB68:
 373:armwave.c     **** 
 374:armwave.c     **** /*
 375:armwave.c     ****  * Dump a ppm of a buffer to a file.
 376:armwave.c     ****  */
 377:armwave.c     **** void armwave_dump_ppm_debug(uint32_t *buffer, char *fn)
 378:armwave.c     **** {
 1695              		.loc 1 378 1 is_stmt 1 view -0
 1696              		.cfi_startproc
 1697              		@ args = 0, pretend = 0, frame = 0
 1698              		@ frame_needed = 0, uses_anonymous_args = 0
 379:armwave.c     ****     FILE *fp = fopen(fn, "wb");
 1699              		.loc 1 379 5 view .LVU433
 1700              	@ armwave.c:378: {
 378:armwave.c     ****     FILE *fp = fopen(fn, "wb");
 1701              		.loc 1 378 1 is_stmt 0 view .LVU434
 1702 07c4 0130A0E1 		mov	r3, r1	@ fn, fn
 1703 07c8 F0432DE9 		push	{r4, r5, r6, r7, r8, r9, lr}	@
 1704              		.cfi_def_cfa_offset 28
 1705              		.cfi_offset 4, -28
 1706              		.cfi_offset 5, -24
 1707              		.cfi_offset 6, -20
 1708              		.cfi_offset 7, -16
 1709              		.cfi_offset 8, -12
 1710              		.cfi_offset 9, -8
 1711              		.cfi_offset 14, -4
 1712 07cc 0080A0E1 		mov	r8, r0	@ buffer, buffer
 1713 07d0 0CD04DE2 		sub	sp, sp, #12	@,,
 1714              		.cfi_def_cfa_offset 40
 1715              	@ armwave.c:379:     FILE *fp = fopen(fn, "wb");
 1716              		.loc 1 379 16 view .LVU435
 1717 07d4 C4109FE5 		ldr	r1, .L106	@,
 1718              	.LVL112:
 1719              		.loc 1 379 16 view .LVU436
 1720 07d8 0300A0E1 		mov	r0, r3	@, fn
 1721              	.LVL113:
 1722              		.loc 1 379 16 view .LVU437
 1723 07dc FEFFFFEB 		bl	fopen64		@
 1724              	.LVL114:
 1725              	@ armwave.c:386:     fprintf(fp, "%d %d\n", g_armwave_state.target_width, g_armwave_state.target_he
 380:armwave.c     ****     uint32_t data;
 381:armwave.c     ****     int xx, yy;
 382:armwave.c     **** 
 383:armwave.c     ****     //printf("in_buffer=0x%08x\n", buffer);
 384:armwave.c     **** 
 385:armwave.c     ****     fputs("P3\n", fp);
 386:armwave.c     ****     fprintf(fp, "%d %d\n", g_armwave_state.target_width, g_armwave_state.target_height);
 1726              		.loc 1 386 5 view .LVU438
 1727 07e0 BC609FE5 		ldr	r6, .L106+4	@ tmp150,
 1728              	@ armwave.c:385:     fputs("P3\n", fp);
 385:armwave.c     ****     fprintf(fp, "%d %d\n", g_armwave_state.target_width, g_armwave_state.target_height);
 1729              		.loc 1 385 5 view .LVU439
 1730 07e4 0320A0E3 		mov	r2, #3	@,
 1731 07e8 0110A0E3 		mov	r1, #1	@,
 1732              	@ armwave.c:379:     FILE *fp = fopen(fn, "wb");
 379:armwave.c     ****     uint32_t data;
 1733              		.loc 1 379 16 view .LVU440
 1734 07ec 0070A0E1 		mov	r7, r0	@ fp,
 1735              	.LVL115:
 380:armwave.c     ****     uint32_t data;
 1736              		.loc 1 380 5 is_stmt 1 view .LVU441
 381:armwave.c     **** 
 1737              		.loc 1 381 5 view .LVU442
 385:armwave.c     ****     fprintf(fp, "%d %d\n", g_armwave_state.target_width, g_armwave_state.target_height);
 1738              		.loc 1 385 5 view .LVU443
 1739 07f0 0030A0E1 		mov	r3, r0	@, fp
 1740 07f4 AC009FE5 		ldr	r0, .L106+8	@,
 1741              	.LVL116:
 385:armwave.c     ****     fprintf(fp, "%d %d\n", g_armwave_state.target_width, g_armwave_state.target_height);
 1742              		.loc 1 385 5 is_stmt 0 view .LVU444
 1743 07f8 FEFFFFEB 		bl	fwrite		@
 1744              	.LVL117:
 1745              		.loc 1 386 5 is_stmt 1 view .LVU445
 1746 07fc D825C6E1 		ldrd	r2, [r6, #88]	@, tmp150,
 1747 0800 A4109FE5 		ldr	r1, .L106+12	@,
 1748 0804 0700A0E1 		mov	r0, r7	@, fp
 1749 0808 FEFFFFEB 		bl	fprintf		@
 1750              	.LVL118:
 387:armwave.c     ****     fputs("255\n", fp);
 1751              		.loc 1 387 5 view .LVU446
 1752 080c 0420A0E3 		mov	r2, #4	@,
 1753 0810 0730A0E1 		mov	r3, r7	@, fp
 1754 0814 0110A0E3 		mov	r1, #1	@,
 1755 0818 90009FE5 		ldr	r0, .L106+16	@,
 1756 081c FEFFFFEB 		bl	fwrite		@
 1757              	.LVL119:
 388:armwave.c     **** 
 389:armwave.c     ****     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 1758              		.loc 1 389 5 view .LVU447
 1759              	@ armwave.c:389:     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 1760              		.loc 1 389 37 is_stmt 0 view .LVU448
 1761 0820 5C2096E5 		ldr	r2, [r6, #92]	@ prephitmp_53, g_armwave_state.target_height
 1762              	@ armwave.c:389:     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 1763              		.loc 1 389 5 view .LVU449
 1764 0824 000052E3 		cmp	r2, #0	@ prephitmp_53,
 1765 0828 180000DA 		ble	.L99		@,
 1766 082c 583096E5 		ldr	r3, [r6, #88]	@ _13, g_armwave_state.target_width
 1767              	@ armwave.c:394:             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >>
 390:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 391:armwave.c     ****             data = *(buffer + (xx + (yy * g_armwave_state.target_width)));
 392:armwave.c     ****             //printf("xx,yy=%4d,%4d, word=0x%08x\n", xx, yy, data);
 393:armwave.c     **** 
 394:armwave.c     ****             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >> 16) & 0xff);
 1768              		.loc 1 394 13 view .LVU450
 1769 0830 7C909FE5 		ldr	r9, .L106+20	@ tmp152,
 1770              	@ armwave.c:389:     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 389:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1771              		.loc 1 389 12 view .LVU451
 1772 0834 0050A0E3 		mov	r5, #0	@ yy,
 1773              	.LVL120:
 1774              	.L100:
 1775              	@ armwave.c:390:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 390:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1776              		.loc 1 390 9 view .LVU452
 1777 0838 000053E3 		cmp	r3, #0	@ _13,
 1778              	@ armwave.c:390:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 390:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1779              		.loc 1 390 16 view .LVU453
 1780 083c 0040A0C3 		movgt	r4, #0	@ xx,
 1781              	@ armwave.c:390:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 390:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1782              		.loc 1 390 9 view .LVU454
 1783 0840 0F0000DA 		ble	.L102		@,
 1784              	.LVL121:
 1785              	.L101:
 391:armwave.c     ****             //printf("xx,yy=%4d,%4d, word=0x%08x\n", xx, yy, data);
 1786              		.loc 1 391 13 is_stmt 1 discriminator 3 view .LVU455
 1787              	@ armwave.c:391:             data = *(buffer + (xx + (yy * g_armwave_state.target_width)));
 391:armwave.c     ****             //printf("xx,yy=%4d,%4d, word=0x%08x\n", xx, yy, data);
 1788              		.loc 1 391 29 is_stmt 0 discriminator 3 view .LVU456
 1789 0844 954323E0 		mla	r3, r5, r3, r4	@ tmp141, yy, _13, xx
 1790              	@ armwave.c:394:             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >>
 1791              		.loc 1 394 13 discriminator 3 view .LVU457
 1792 0848 0910A0E1 		mov	r1, r9	@, tmp152
 1793 084c 0700A0E1 		mov	r0, r7	@, fp
 1794              	@ armwave.c:391:             data = *(buffer + (xx + (yy * g_armwave_state.target_width)));
 391:armwave.c     ****             //printf("xx,yy=%4d,%4d, word=0x%08x\n", xx, yy, data);
 1795              		.loc 1 391 18 discriminator 3 view .LVU458
 1796 0850 032198E7 		ldr	r2, [r8, r3, lsl #2]	@ data, *_7
 1797              	.LVL122:
 1798              		.loc 1 394 13 is_stmt 1 discriminator 3 view .LVU459
 1799              	@ armwave.c:390:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 390:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1800              		.loc 1 390 58 is_stmt 0 discriminator 3 view .LVU460
 1801 0854 014084E2 		add	r4, r4, #1	@ xx, xx,
 1802              	.LVL123:
 1803              	@ armwave.c:394:             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >>
 1804              		.loc 1 394 81 discriminator 3 view .LVU461
 1805 0858 22C8A0E1 		lsr	ip, r2, #16	@ tmp146, data,
 1806              	@ armwave.c:394:             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >>
 1807              		.loc 1 394 61 discriminator 3 view .LVU462
 1808 085c 2234A0E1 		lsr	r3, r2, #8	@ tmp142, data,
 1809              	@ armwave.c:394:             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >>
 1810              		.loc 1 394 13 discriminator 3 view .LVU463
 1811 0860 7CC0EFE6 		uxtb	ip, ip	@ tmp147, tmp146
 1812 0864 7330EFE6 		uxtb	r3, r3	@, tmp142
 1813 0868 00C08DE5 		str	ip, [sp]	@ tmp147,
 1814 086c 7220EFE6 		uxtb	r2, r2	@, data
 1815              	.LVL124:
 1816              		.loc 1 394 13 discriminator 3 view .LVU464
 1817 0870 FEFFFFEB 		bl	fprintf		@
 1818              	.LVL125:
 1819              	@ armwave.c:390:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 390:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1820              		.loc 1 390 41 discriminator 3 view .LVU465
 1821 0874 583096E5 		ldr	r3, [r6, #88]	@ _13, g_armwave_state.target_width
 1822              	@ armwave.c:390:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 390:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1823              		.loc 1 390 9 discriminator 3 view .LVU466
 1824 0878 040053E1 		cmp	r3, r4	@ _13, xx
 1825 087c F0FFFFCA 		bgt	.L101		@,
 1826 0880 5C2096E5 		ldr	r2, [r6, #92]	@ prephitmp_53, g_armwave_state.target_height
 1827              	.LVL126:
 1828              	.L102:
 1829              	@ armwave.c:389:     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 389:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1830              		.loc 1 389 55 discriminator 2 view .LVU467
 1831 0884 015085E2 		add	r5, r5, #1	@ yy, yy,
 1832              	.LVL127:
 1833              	@ armwave.c:389:     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 389:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1834              		.loc 1 389 5 discriminator 2 view .LVU468
 1835 0888 020055E1 		cmp	r5, r2	@ yy, prephitmp_53
 1836 088c E9FFFFBA 		blt	.L100		@,
 1837              	.LVL128:
 1838              	.L99:
 395:armwave.c     ****         }
 396:armwave.c     ****     }
 397:armwave.c     **** 
 398:armwave.c     ****     fclose(fp);
 1839              		.loc 1 398 5 is_stmt 1 view .LVU469
 1840 0890 0700A0E1 		mov	r0, r7	@, fp
 1841              	@ armwave.c:399: }
 399:armwave.c     **** }
 1842              		.loc 1 399 1 is_stmt 0 view .LVU470
 1843 0894 0CD08DE2 		add	sp, sp, #12	@,,
 1844              		.cfi_def_cfa_offset 28
 1845              		@ sp needed	@
 1846 0898 F043BDE8 		pop	{r4, r5, r6, r7, r8, r9, lr}	@
 1847              		.cfi_restore 14
 1848              		.cfi_restore 9
 1849              		.cfi_restore 8
 1850              		.cfi_restore 7
 1851              		.cfi_restore 6
 1852              		.cfi_restore 5
 1853              		.cfi_restore 4
 1854              		.cfi_def_cfa_offset 0
 1855              	.LVL129:
 1856              	@ armwave.c:398:     fclose(fp);
 398:armwave.c     **** }
 1857              		.loc 1 398 5 view .LVU471
 1858 089c FEFFFFEA 		b	fclose		@
 1859              	.LVL130:
 1860              	.L107:
 398:armwave.c     **** }
 1861              		.loc 1 398 5 view .LVU472
 1862              		.align	2
 1863              	.L106:
 1864 08a0 B8020000 		.word	.LC18
 1865 08a4 00000000 		.word	g_armwave_state
 1866 08a8 BC020000 		.word	.LC19
 1867 08ac C0020000 		.word	.LC20
 1868 08b0 C8020000 		.word	.LC21
 1869 08b4 D0020000 		.word	.LC22
 1870              		.cfi_endproc
 1871              	.LFE68:
 1873              		.align	2
 1874              		.global	armwave_test_init
 1875              		.syntax unified
 1876              		.arm
 1877              		.fpu vfp
 1879              	armwave_test_init:
 1880              	.LVL131:
 1881              	.LFB69:
 400:armwave.c     **** 
 401:armwave.c     **** /*
 402:armwave.c     ****  * Initialise some test functionry.
 403:armwave.c     ****  */
 404:armwave.c     **** void armwave_test_init(int wave_size, int nwaves, int render_width, int render_height)
 405:armwave.c     **** {
 1882              		.loc 1 405 1 is_stmt 1 view -0
 1883              		.cfi_startproc
 1884              		@ args = 0, pretend = 0, frame = 0
 1885              		@ frame_needed = 0, uses_anonymous_args = 0
 406:armwave.c     ****     test_create_gamma();
 1886              		.loc 1 406 5 view .LVU474
 1887              	.LBB12:
 1888              	.LBI12:
  34:armwave.c     **** {
 1889              		.loc 1 34 6 view .LVU475
  34:armwave.c     **** {
 1890              		.loc 1 34 6 is_stmt 0 view .LVU476
 1891              	.LBE12:
 1892              	@ armwave.c:405: {
 405:armwave.c     ****     test_create_gamma();
 1893              		.loc 1 405 1 view .LVU477
 1894 08b8 F0472DE9 		push	{r4, r5, r6, r7, r8, r9, r10, lr}	@
 1895              		.cfi_def_cfa_offset 32
 1896              		.cfi_offset 4, -32
 1897              		.cfi_offset 5, -28
 1898              		.cfi_offset 6, -24
 1899              		.cfi_offset 7, -20
 1900              		.cfi_offset 8, -16
 1901              		.cfi_offset 9, -12
 1902              		.cfi_offset 10, -8
 1903              		.cfi_offset 14, -4
 1904 08bc 068B2DED 		vpush.64	{d8, d9, d10}	@
 1905              		.cfi_def_cfa_offset 56
 1906              		.cfi_offset 80, -56
 1907              		.cfi_offset 81, -52
 1908              		.cfi_offset 82, -48
 1909              		.cfi_offset 83, -44
 1910              		.cfi_offset 84, -40
 1911              		.cfi_offset 85, -36
 1912 08c0 BC409FE5 		ldr	r4, .L112+20	@ ivtmp.87,
 1913              	.LBB15:
 1914              	.LBB13:
 1915              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1916              		.loc 1 40 32 view .LVU478
 1917 08c4 2DAA9FED 		vldr.32	s20, .L112+16	@ tmp136,
 1918              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1919              		.loc 1 40 26 view .LVU479
 1920 08c8 289B9FED 		vldr.64	d9, .L112	@ tmp151,
 1921              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1922              		.loc 1 40 49 view .LVU480
 1923 08cc 298B9FED 		vldr.64	d8, .L112+8	@ tmp139,
 1924 08d0 01C084E2 		add	ip, r4, #1	@ _38, ivtmp.87,
 1925              	.LBE13:
 1926              	.LBE15:
 1927              	@ armwave.c:405: {
 405:armwave.c     ****     test_create_gamma();
 1928              		.loc 1 405 1 view .LVU481
 1929 08d4 10D04DE2 		sub	sp, sp, #16	@,,
 1930              		.cfi_def_cfa_offset 72
 1931              	@ armwave.c:405: {
 405:armwave.c     ****     test_create_gamma();
 1932              		.loc 1 405 1 view .LVU482
 1933 08d8 0060A0E1 		mov	r6, r0	@ wave_size, wave_size
 1934 08dc 0170A0E1 		mov	r7, r1	@ nwaves, nwaves
 1935 08e0 0280A0E1 		mov	r8, r2	@ render_width, render_width
 1936 08e4 0390A0E1 		mov	r9, r3	@ render_height, render_height
 1937 08e8 01AC84E2 		add	r10, r4, #256	@ _39, ivtmp.87,
 1938 08ec 01506CE2 		rsb	r5, ip, #1	@ tmp150, _38,
 1939              	.LVL132:
 1940              	.L109:
 1941              	.LBB16:
 1942              	.LBB14:
  40:armwave.c     ****     }
 1943              		.loc 1 40 9 is_stmt 1 view .LVU483
 1944              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1945              		.loc 1 40 32 is_stmt 0 view .LVU484
 1946 08f0 043085E0 		add	r3, r5, r4	@ tmp133, tmp150, ivtmp.87
 1947              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1948              		.loc 1 40 26 view .LVU485
 1949 08f4 491BB0EE 		vmov.f64	d1, d9	@, tmp151
 1950              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1951              		.loc 1 40 32 view .LVU486
 1952 08f8 903A07EE 		vmov	s15, r3	@ int	@ tmp133, tmp133
 1953 08fc E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp134, tmp133
 1954 0900 8A0A87EE 		vdiv.f32	s0, s15, s20	@ tmp135, tmp134, tmp136
 1955              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1956              		.loc 1 40 26 view .LVU487
 1957 0904 C00AB7EE 		vcvt.f64.f32	d0, s0	@, tmp135
 1958 0908 FEFFFFEB 		bl	pow		@
 1959              	.LVL133:
 1960              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1961              		.loc 1 40 49 view .LVU488
 1962 090c 080B20EE 		vmul.f64	d0, d0, d8	@ tmp138,, tmp139
 1963              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1964              		.loc 1 40 24 view .LVU489
 1965 0910 C07BFCEE 		vcvt.u32.f64	s15, d0	@ tmp140, tmp138
 1966 0914 900A17EE 		vmov	r0, s15	@ int	@ tmp140, tmp140
 1967 0918 0100E4E5 		strb	r0, [r4, #1]!	@ tmp140, MEM[base: _37, offset: 0B]
 1968              	.LVL134:
 1969              	@ armwave.c:39:     for(i = 0; i < 256; i++) {
  39:armwave.c     ****         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 1970              		.loc 1 39 5 view .LVU490
 1971 091c 0A0054E1 		cmp	r4, r10	@ ivtmp.87, _39
 1972 0920 F2FFFF1A 		bne	.L109		@,
 1973              	.LVL135:
  39:armwave.c     ****         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 1974              		.loc 1 39 5 view .LVU491
 1975              	.LBE14:
 1976              	.LBE16:
 407:armwave.c     **** 
 408:armwave.c     ****     // make ch1 yellowish by default
 409:armwave.c     ****     armwave_set_channel_colour(1, 2550, 1780, 250);
 1977              		.loc 1 409 5 is_stmt 1 view .LVU492
 1978              	.LBB17:
 1979              	.LBI17:
 362:armwave.c     **** {
 1980              		.loc 1 362 6 view .LVU493
 1981              	.LBB18:
 365:armwave.c     ****         case 1:
 1982              		.loc 1 365 5 view .LVU494
 367:armwave.c     ****             g_armwave_state.ch1_color.g = g;
 1983              		.loc 1 367 13 view .LVU495
 368:armwave.c     ****             g_armwave_state.ch1_color.b = b;
 1984              		.loc 1 368 13 view .LVU496
 1985              	@ armwave.c:367:             g_armwave_state.ch1_color.r = r;
 367:armwave.c     ****             g_armwave_state.ch1_color.g = g;
 1986              		.loc 1 367 41 is_stmt 0 view .LVU497
 1987 0924 5CC09FE5 		ldr	ip, .L112+24	@ tmp142,
 1988 0928 5C409FE5 		ldr	r4, .L112+28	@ tmp143,
 1989              	.LBE18:
 1990              	.LBE17:
 1991              	@ armwave.c:411:     armwave_setup_render(0, wave_size, nwaves, wave_size, render_width, render_hei
 410:armwave.c     **** 
 411:armwave.c     ****     armwave_setup_render(0, wave_size, nwaves, wave_size, render_width, render_height, 0x00000000);
 1992              		.loc 1 411 5 view .LVU498
 1993 092c 0000A0E3 		mov	r0, #0	@ tmp147,
 1994              	.LBB22:
 1995              	.LBB19:
 1996              	@ armwave.c:369:             g_armwave_state.ch1_color.b = b;
 369:armwave.c     ****             break;
 1997              		.loc 1 369 41 view .LVU499
 1998 0930 FAE0A0E3 		mov	lr, #250	@ tmp146,
 1999              	.LBE19:
 2000              	.LBE22:
 2001              	@ armwave.c:411:     armwave_setup_render(0, wave_size, nwaves, wave_size, render_width, render_hei
 2002              		.loc 1 411 5 view .LVU500
 2003 0934 08008DE5 		str	r0, [sp, #8]	@ tmp147,
 2004 0938 04908DE5 		str	r9, [sp, #4]	@ render_height,
 2005 093c 00808DE5 		str	r8, [sp]	@ render_width,
 2006 0940 0610A0E1 		mov	r1, r6	@, tmp3
 2007 0944 0720A0E1 		mov	r2, r7	@, nwaves
 2008              	.LBB23:
 2009              	.LBB20:
 2010              	@ armwave.c:367:             g_armwave_state.ch1_color.r = r;
 367:armwave.c     ****             g_armwave_state.ch1_color.g = g;
 2011              		.loc 1 367 41 view .LVU501
 2012 0948 6C408CE5 		str	r4, [ip, #108]	@ tmp143, MEM[(short int *)&g_armwave_state + 108B]
 369:armwave.c     ****             break;
 2013              		.loc 1 369 13 is_stmt 1 view .LVU502
 2014              	.LBE20:
 2015              	.LBE23:
 2016              	@ armwave.c:411:     armwave_setup_render(0, wave_size, nwaves, wave_size, render_width, render_hei
 2017              		.loc 1 411 5 is_stmt 0 view .LVU503
 2018 094c 0630A0E1 		mov	r3, r6	@, wave_size
 2019              	.LBB24:
 2020              	.LBB21:
 2021              	@ armwave.c:369:             g_armwave_state.ch1_color.b = b;
 369:armwave.c     ****             break;
 2022              		.loc 1 369 41 view .LVU504
 2023 0950 B0E7CCE1 		strh	lr, [ip, #112]	@ movhi	@ tmp146, g_armwave_state.ch1_color.b
 370:armwave.c     ****     }
 2024              		.loc 1 370 13 is_stmt 1 view .LVU505
 2025              	.LVL136:
 370:armwave.c     ****     }
 2026              		.loc 1 370 13 is_stmt 0 view .LVU506
 2027              	.LBE21:
 2028              	.LBE24:
 2029              		.loc 1 411 5 is_stmt 1 view .LVU507
 2030 0954 FEFFFFEB 		bl	armwave_setup_render		@
 2031              	.LVL137:
 412:armwave.c     **** 
 413:armwave.c     ****     printf("armwave version: %s\n", ARMWAVE_VER);
 2032              		.loc 1 413 5 view .LVU508
 2033 0958 30109FE5 		ldr	r1, .L112+32	@,
 2034 095c 30009FE5 		ldr	r0, .L112+36	@,
 2035              	@ armwave.c:414: }
 414:armwave.c     **** }
 2036              		.loc 1 414 1 is_stmt 0 view .LVU509
 2037 0960 10D08DE2 		add	sp, sp, #16	@,,
 2038              		.cfi_def_cfa_offset 56
 2039              		@ sp needed	@
 2040 0964 068BBDEC 		vldm	sp!, {d8-d10}	@,
 2041              		.cfi_restore 84
 2042              		.cfi_restore 85
 2043              		.cfi_restore 82
 2044              		.cfi_restore 83
 2045              		.cfi_restore 80
 2046              		.cfi_restore 81
 2047              		.cfi_def_cfa_offset 32
 2048 0968 F047BDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, lr}	@
 2049              		.cfi_restore 14
 2050              		.cfi_restore 10
 2051              		.cfi_restore 9
 2052              		.cfi_restore 8
 2053              		.cfi_restore 7
 2054              		.cfi_restore 6
 2055              		.cfi_restore 5
 2056              		.cfi_restore 4
 2057              		.cfi_def_cfa_offset 0
 2058              	.LVL138:
 2059              	@ armwave.c:413:     printf("armwave version: %s\n", ARMWAVE_VER);
 413:armwave.c     **** }
 2060              		.loc 1 413 5 view .LVU510
 2061 096c FEFFFFEA 		b	printf		@
 2062              	.LVL139:
 2063              	.L113:
 2064              		.align	3
 2065              	.L112:
 2066 0970 000000C0 		.word	-1073741824
 2067 0974 CCCCEC3F 		.word	1072483532
 2068 0978 00000000 		.word	0
 2069 097c 00E06F40 		.word	1081073664
 2070 0980 00007F43 		.word	1132396544
 2071 0984 FFFFFFFF 		.word	gamma_table-1
 2072 0988 00000000 		.word	g_armwave_state
 2073 098c F609F406 		.word	116656630
 2074 0990 00000000 		.word	.LC0
 2075 0994 08000000 		.word	.LC1
 2076              		.cfi_endproc
 2077              	.LFE69:
 2079              		.align	2
 2080              		.global	armwave_test_fill_outbuf
 2081              		.syntax unified
 2082              		.arm
 2083              		.fpu vfp
 2085              	armwave_test_fill_outbuf:
 2086              	.LFB70:
 415:armwave.c     **** 
 416:armwave.c     **** /*
 417:armwave.c     ****  * Render image to the local allocated buffer.
 418:armwave.c     ****  */
 419:armwave.c     **** void armwave_test_fill_outbuf()
 420:armwave.c     **** {
 2087              		.loc 1 420 1 is_stmt 1 view -0
 2088              		.cfi_startproc
 2089              		@ args = 0, pretend = 0, frame = 0
 2090              		@ frame_needed = 0, uses_anonymous_args = 0
 2091              		@ link register save eliminated.
 421:armwave.c     ****     armwave_fill_pixbuf_scaled(g_armwave_state.out_pixbuf);
 2092              		.loc 1 421 5 view .LVU512
 2093 0998 04309FE5 		ldr	r3, .L115	@ tmp111,
 2094 099c 680093E5 		ldr	r0, [r3, #104]	@, g_armwave_state.out_pixbuf
 2095 09a0 FEFFFFEA 		b	armwave_fill_pixbuf_scaled		@
 2096              	.LVL140:
 2097              	.L116:
 2098              		.align	2
 2099              	.L115:
 2100 09a4 00000000 		.word	g_armwave_state
 2101              		.cfi_endproc
 2102              	.LFE70:
 2104              		.align	2
 2105              		.global	armwave_test_dump_buffer_to_ppm
 2106              		.syntax unified
 2107              		.arm
 2108              		.fpu vfp
 2110              	armwave_test_dump_buffer_to_ppm:
 2111              	.LVL141:
 2112              	.LFB71:
 422:armwave.c     **** }
 423:armwave.c     **** 
 424:armwave.c     **** /*
 425:armwave.c     ****  * Dump the working local allocated buffer to a ppm file for debug.
 426:armwave.c     ****  */
 427:armwave.c     **** void armwave_test_dump_buffer_to_ppm(char *fn)
 428:armwave.c     **** {
 2113              		.loc 1 428 1 view -0
 2114              		.cfi_startproc
 2115              		@ args = 0, pretend = 0, frame = 0
 2116              		@ frame_needed = 0, uses_anonymous_args = 0
 2117              		@ link register save eliminated.
 429:armwave.c     ****     armwave_dump_ppm_debug(g_armwave_state.out_pixbuf, fn);
 2118              		.loc 1 429 5 view .LVU514
 2119 09a8 08309FE5 		ldr	r3, .L118	@ tmp112,
 2120 09ac 0010A0E1 		mov	r1, r0	@, fn
 2121 09b0 680093E5 		ldr	r0, [r3, #104]	@, g_armwave_state.out_pixbuf
 2122              	.LVL142:
 2123              		.loc 1 429 5 is_stmt 0 view .LVU515
 2124 09b4 FEFFFFEA 		b	armwave_dump_ppm_debug		@
 2125              	.LVL143:
 2126              	.L119:
 2127              		.loc 1 429 5 view .LVU516
 2128              		.align	2
 2129              	.L118:
 2130 09b8 00000000 		.word	g_armwave_state
 2131              		.cfi_endproc
 2132              	.LFE71:
 2134              		.align	2
 2135              		.global	armwave_test_fill_gdkbuf
 2136              		.syntax unified
 2137              		.arm
 2138              		.fpu vfp
 2140              	armwave_test_fill_gdkbuf:
 2141              	.LVL144:
 2142              	.LFB72:
 430:armwave.c     **** }
 431:armwave.c     **** 
 432:armwave.c     **** /*
 433:armwave.c     ****  * Render GDK buffer with test funtionry.
 434:armwave.c     ****  */
 435:armwave.c     **** void armwave_test_fill_gdkbuf(PyObject *buf)
 436:armwave.c     **** {
 2143              		.loc 1 436 1 is_stmt 1 view -0
 2144              		.cfi_startproc
 2145              		@ args = 0, pretend = 0, frame = 0
 2146              		@ frame_needed = 0, uses_anonymous_args = 0
 2147              		@ link register save eliminated.
 437:armwave.c     ****     //PyObject *mv;
 438:armwave.c     ****     //Py_buffer *buf = malloc(sizeof(Py_buffer));
 439:armwave.c     **** 
 440:armwave.c     ****     // Holy jesus dear mother of God, what have we done?
 441:armwave.c     ****     void *out_pixbuf = ((uint32_t ***)buf)[2][10];
 2148              		.loc 1 441 5 view .LVU518
 442:armwave.c     ****     
 443:armwave.c     ****     // TODO: use armwave_fill_pixbuf_256 for 256-height buffers for performance?
 444:armwave.c     ****     armwave_fill_pixbuf_scaled(out_pixbuf);
 2149              		.loc 1 444 5 view .LVU519
 2150              	@ armwave.c:441:     void *out_pixbuf = ((uint32_t ***)buf)[2][10];
 441:armwave.c     ****     
 2151              		.loc 1 441 11 is_stmt 0 view .LVU520
 2152 09bc 083090E5 		ldr	r3, [r0, #8]	@ MEM[(uint32_t * * *)buf_2(D) + 8B], MEM[(uint32_t * * *)buf_2(D) + 8B]
 2153              	@ armwave.c:444:     armwave_fill_pixbuf_scaled(out_pixbuf);
 2154              		.loc 1 444 5 view .LVU521
 2155 09c0 280093E5 		ldr	r0, [r3, #40]	@, MEM[(uint32_t * *)_1 + 40B]
 2156              	.LVL145:
 2157              		.loc 1 444 5 view .LVU522
 2158 09c4 FEFFFFEA 		b	armwave_fill_pixbuf_scaled		@
 2159              	.LVL146:
 2160              		.loc 1 444 5 view .LVU523
 2161              		.cfi_endproc
 2162              	.LFE72:
 2164              		.align	2
 2165              		.global	armwave_test_buffer_alloc
 2166              		.syntax unified
 2167              		.arm
 2168              		.fpu vfp
 2170              	armwave_test_buffer_alloc:
 2171              	.LVL147:
 2172              	.LFB73:
 445:armwave.c     **** }
 446:armwave.c     **** 
 447:armwave.c     **** /*
 448:armwave.c     ****  * Allocate a test buffer, freeing any existing buffer.
 449:armwave.c     ****  */
 450:armwave.c     **** void armwave_test_buffer_alloc(int nsets)
 451:armwave.c     **** {
 2173              		.loc 1 451 1 is_stmt 1 view -0
 2174              		.cfi_startproc
 2175              		@ args = 0, pretend = 0, frame = 0
 2176              		@ frame_needed = 0, uses_anonymous_args = 0
 452:armwave.c     ****     if(g_armwave_state.test_wave_buffer != NULL) {
 2177              		.loc 1 452 5 view .LVU525
 2178              	@ armwave.c:451: {
 451:armwave.c     ****     if(g_armwave_state.test_wave_buffer != NULL) {
 2179              		.loc 1 451 1 is_stmt 0 view .LVU526
 2180 09c8 70402DE9 		push	{r4, r5, r6, lr}	@
 2181              		.cfi_def_cfa_offset 16
 2182              		.cfi_offset 4, -16
 2183              		.cfi_offset 5, -12
 2184              		.cfi_offset 6, -8
 2185              		.cfi_offset 14, -4
 2186              	@ armwave.c:451: {
 451:armwave.c     ****     if(g_armwave_state.test_wave_buffer != NULL) {
 2187              		.loc 1 451 1 view .LVU527
 2188 09cc 0060A0E1 		mov	r6, r0	@ nsets, nsets
 2189              	@ armwave.c:452:     if(g_armwave_state.test_wave_buffer != NULL) {
 2190              		.loc 1 452 23 view .LVU528
 2191 09d0 44409FE5 		ldr	r4, .L128	@ tmp128,
 2192 09d4 180094E5 		ldr	r0, [r4, #24]	@ _1, g_armwave_state.test_wave_buffer
 2193              	.LVL148:
 2194              	@ armwave.c:452:     if(g_armwave_state.test_wave_buffer != NULL) {
 2195              		.loc 1 452 7 view .LVU529
 2196 09d8 000050E3 		cmp	r0, #0	@ _1,
 2197 09dc 0000000A 		beq	.L122		@,
 453:armwave.c     ****         free(g_armwave_state.test_wave_buffer);
 2198              		.loc 1 453 9 is_stmt 1 view .LVU530
 2199 09e0 FEFFFFEB 		bl	free		@
 2200              	.LVL149:
 2201              	.L122:
 454:armwave.c     ****     }
 455:armwave.c     **** 
 456:armwave.c     ****     //printf("armwave_test_buffer_alloc: length=%d max=%d\n", g_armwave_state.wave_length, g_armwav
 457:armwave.c     **** 
 458:armwave.c     ****     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armwave_state.waves_m
 2202              		.loc 1 458 5 view .LVU531
 2203              	@ armwave.c:458:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 2204              		.loc 1 458 75 is_stmt 0 view .LVU532
 2205 09e4 4C3094E5 		ldr	r3, [r4, #76]	@ g_armwave_state.wave_length, g_armwave_state.wave_length
 2206 09e8 3C5094E5 		ldr	r5, [r4, #60]	@ g_armwave_state.waves_max, g_armwave_state.waves_max
 2207              	@ armwave.c:458:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 2208              		.loc 1 458 40 view .LVU533
 2209 09ec 0610A0E1 		mov	r1, r6	@, nsets
 2210              	@ armwave.c:458:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 2211              		.loc 1 458 75 view .LVU534
 2212 09f0 950305E0 		mul	r5, r5, r3	@ _4, g_armwave_state.waves_max, g_armwave_state.wave_length
 2213              	@ armwave.c:458:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 2214              		.loc 1 458 40 view .LVU535
 2215 09f4 0500A0E1 		mov	r0, r5	@, _4
 2216 09f8 FEFFFFEB 		bl	calloc		@
 2217              	.LVL150:
 2218              	@ armwave.c:460:     if(g_armwave_state.test_wave_buffer == NULL) {
 459:armwave.c     **** 
 460:armwave.c     ****     if(g_armwave_state.test_wave_buffer == NULL) {
 2219              		.loc 1 460 7 view .LVU536
 2220 09fc 000050E3 		cmp	r0, #0	@ tmp124,
 2221              	@ armwave.c:458:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 458:armwave.c     **** 
 2222              		.loc 1 458 38 view .LVU537
 2223 0a00 180084E5 		str	r0, [r4, #24]	@ tmp124, g_armwave_state.test_wave_buffer
 2224              		.loc 1 460 5 is_stmt 1 view .LVU538
 2225              	@ armwave.c:460:     if(g_armwave_state.test_wave_buffer == NULL) {
 2226              		.loc 1 460 7 is_stmt 0 view .LVU539
 2227 0a04 7080BD18 		popne	{r4, r5, r6, pc}	@
 461:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes, %d sets)\
 2228              		.loc 1 461 9 is_stmt 1 view .LVU540
 2229 0a08 960501E0 		mul	r1, r6, r5	@, nsets, _4
 2230 0a0c 0620A0E1 		mov	r2, r6	@, nsets
 2231 0a10 08009FE5 		ldr	r0, .L128+4	@,
 2232              	@ armwave.c:465: }
 462:armwave.c     ****             g_armwave_state.wave_length * g_armwave_state.waves_max * nsets, nsets);
 463:armwave.c     ****         return;
 464:armwave.c     ****     }
 465:armwave.c     **** }
 2233              		.loc 1 465 1 is_stmt 0 view .LVU541
 2234 0a14 7040BDE8 		pop	{r4, r5, r6, lr}	@
 2235              		.cfi_restore 14
 2236              		.cfi_restore 6
 2237              		.cfi_restore 5
 2238              		.cfi_restore 4
 2239              		.cfi_def_cfa_offset 0
 2240              	.LVL151:
 2241              	@ armwave.c:461:         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d
 461:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes, %d sets)\
 2242              		.loc 1 461 9 view .LVU542
 2243 0a18 FEFFFFEA 		b	printf		@
 2244              	.LVL152:
 2245              	.L129:
 461:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes, %d sets)\
 2246              		.loc 1 461 9 view .LVU543
 2247              		.align	2
 2248              	.L128:
 2249 0a1c 00000000 		.word	g_armwave_state
 2250 0a20 E0020000 		.word	.LC23
 2251              		.cfi_endproc
 2252              	.LFE73:
 2254              		.align	2
 2255              		.global	armwave_fill_pixbuf_into_pybuffer
 2256              		.syntax unified
 2257              		.arm
 2258              		.fpu vfp
 2260              	armwave_fill_pixbuf_into_pybuffer:
 2261              	.LVL153:
 2262              	.LFB74:
 466:armwave.c     **** 
 467:armwave.c     **** /*
 468:armwave.c     ****  * Fill a pixbuf PyBuffer with a rendered waveform.
 469:armwave.c     ****  */
 470:armwave.c     **** PyObject *armwave_fill_pixbuf_into_pybuffer(PyObject *buf_obj)
 471:armwave.c     **** {
 2263              		.loc 1 471 1 is_stmt 1 view -0
 2264              		.cfi_startproc
 2265              		@ args = 0, pretend = 0, frame = 48
 2266              		@ frame_needed = 0, uses_anonymous_args = 0
 472:armwave.c     ****     Py_buffer buffer;
 2267              		.loc 1 472 5 view .LVU545
 473:armwave.c     ****     int ret;
 2268              		.loc 1 473 5 view .LVU546
 474:armwave.c     **** 
 475:armwave.c     ****     //printf("armwave_fill_pixbuf_into_pybuffer: start\n");
 476:armwave.c     **** 
 477:armwave.c     ****     ret = PyObject_GetBuffer(buf_obj, &buffer, PyBUF_SIMPLE | PyBUF_WRITABLE);
 2269              		.loc 1 477 5 view .LVU547
 2270              	@ armwave.c:471: {
 471:armwave.c     ****     Py_buffer buffer;
 2271              		.loc 1 471 1 is_stmt 0 view .LVU548
 2272 0a24 04E02DE5 		str	lr, [sp, #-4]!	@,
 2273              		.cfi_def_cfa_offset 4
 2274              		.cfi_offset 14, -4
 2275 0a28 34D04DE2 		sub	sp, sp, #52	@,,
 2276              		.cfi_def_cfa_offset 56
 2277              	@ armwave.c:477:     ret = PyObject_GetBuffer(buf_obj, &buffer, PyBUF_SIMPLE | PyBUF_WRITABLE);
 2278              		.loc 1 477 11 view .LVU549
 2279 0a2c 04108DE2 		add	r1, sp, #4	@ tmp131,,
 2280 0a30 0120A0E3 		mov	r2, #1	@,
 2281 0a34 FEFFFFEB 		bl	PyObject_GetBuffer		@
 2282              	.LVL154:
 478:armwave.c     **** 
 479:armwave.c     ****     if(ret != 0) {
 2283              		.loc 1 479 5 is_stmt 1 view .LVU550
 2284              	@ armwave.c:479:     if(ret != 0) {
 2285              		.loc 1 479 7 is_stmt 0 view .LVU551
 2286 0a38 000050E3 		cmp	r0, #0	@,
 2287 0a3c 0A00001A 		bne	.L134		@,
 480:armwave.c     ****         printf("armwave_fill_pixbuf_into_pybuffer: PyObject_GetBuffer() failed, returning PyFalse\n
 481:armwave.c     ****         Py_RETURN_FALSE;
 482:armwave.c     ****     }
 483:armwave.c     **** 
 484:armwave.c     ****     //printf("PyObject_GetBuffer did not trigger assert: buffer->buf=0x%08x, buffer->obj=0x%08x, bu
 485:armwave.c     **** 
 486:armwave.c     ****     armwave_fill_pixbuf_scaled(buffer.buf);
 2288              		.loc 1 486 5 is_stmt 1 view .LVU552
 2289 0a40 04009DE5 		ldr	r0, [sp, #4]	@, buffer.buf
 2290              	.LVL155:
 2291              		.loc 1 486 5 is_stmt 0 view .LVU553
 2292 0a44 FEFFFFEB 		bl	armwave_fill_pixbuf_scaled		@
 2293              	.LVL156:
 487:armwave.c     ****     //printf("armwave_fill_pixbuf_into_pybuffer: buffer fill done\n");
 488:armwave.c     **** 
 489:armwave.c     ****     PyBuffer_Release(&buffer);
 2294              		.loc 1 489 5 is_stmt 1 view .LVU554
 2295 0a48 04008DE2 		add	r0, sp, #4	@ tmp132,,
 2296 0a4c FEFFFFEB 		bl	PyBuffer_Release		@
 2297              	.LVL157:
 490:armwave.c     ****     //printf("armwave_fill_pixbuf_into_pybuffer: done\n");
 491:armwave.c     **** 
 492:armwave.c     ****     Py_RETURN_TRUE;
 2298              		.loc 1 492 5 view .LVU555
 2299              	.LBB25:
 2300              	.LBI25:
 2301              		.file 2 "/usr/local/include/python3.8/object.h"
   1:/usr/local/include/python3.8/object.h **** #ifndef Py_OBJECT_H
   2:/usr/local/include/python3.8/object.h **** #define Py_OBJECT_H
   3:/usr/local/include/python3.8/object.h **** 
   4:/usr/local/include/python3.8/object.h **** #include "pymem.h"   /* _Py_tracemalloc_config */
   5:/usr/local/include/python3.8/object.h **** 
   6:/usr/local/include/python3.8/object.h **** #ifdef __cplusplus
   7:/usr/local/include/python3.8/object.h **** extern "C" {
   8:/usr/local/include/python3.8/object.h **** #endif
   9:/usr/local/include/python3.8/object.h **** 
  10:/usr/local/include/python3.8/object.h **** 
  11:/usr/local/include/python3.8/object.h **** /* Object and type object interface */
  12:/usr/local/include/python3.8/object.h **** 
  13:/usr/local/include/python3.8/object.h **** /*
  14:/usr/local/include/python3.8/object.h **** Objects are structures allocated on the heap.  Special rules apply to
  15:/usr/local/include/python3.8/object.h **** the use of objects to ensure they are properly garbage-collected.
  16:/usr/local/include/python3.8/object.h **** Objects are never allocated statically or on the stack; they must be
  17:/usr/local/include/python3.8/object.h **** accessed through special macros and functions only.  (Type objects are
  18:/usr/local/include/python3.8/object.h **** exceptions to the first rule; the standard types are represented by
  19:/usr/local/include/python3.8/object.h **** statically initialized type objects, although work on type/class unification
  20:/usr/local/include/python3.8/object.h **** for Python 2.2 made it possible to have heap-allocated type objects too).
  21:/usr/local/include/python3.8/object.h **** 
  22:/usr/local/include/python3.8/object.h **** An object has a 'reference count' that is increased or decreased when a
  23:/usr/local/include/python3.8/object.h **** pointer to the object is copied or deleted; when the reference count
  24:/usr/local/include/python3.8/object.h **** reaches zero there are no references to the object left and it can be
  25:/usr/local/include/python3.8/object.h **** removed from the heap.
  26:/usr/local/include/python3.8/object.h **** 
  27:/usr/local/include/python3.8/object.h **** An object has a 'type' that determines what it represents and what kind
  28:/usr/local/include/python3.8/object.h **** of data it contains.  An object's type is fixed when it is created.
  29:/usr/local/include/python3.8/object.h **** Types themselves are represented as objects; an object contains a
  30:/usr/local/include/python3.8/object.h **** pointer to the corresponding type object.  The type itself has a type
  31:/usr/local/include/python3.8/object.h **** pointer pointing to the object representing the type 'type', which
  32:/usr/local/include/python3.8/object.h **** contains a pointer to itself!.
  33:/usr/local/include/python3.8/object.h **** 
  34:/usr/local/include/python3.8/object.h **** Objects do not float around in memory; once allocated an object keeps
  35:/usr/local/include/python3.8/object.h **** the same size and address.  Objects that must hold variable-size data
  36:/usr/local/include/python3.8/object.h **** can contain pointers to variable-size parts of the object.  Not all
  37:/usr/local/include/python3.8/object.h **** objects of the same type have the same size; but the size cannot change
  38:/usr/local/include/python3.8/object.h **** after allocation.  (These restrictions are made so a reference to an
  39:/usr/local/include/python3.8/object.h **** object can be simply a pointer -- moving an object would require
  40:/usr/local/include/python3.8/object.h **** updating all the pointers, and changing an object's size would require
  41:/usr/local/include/python3.8/object.h **** moving it if there was another object right next to it.)
  42:/usr/local/include/python3.8/object.h **** 
  43:/usr/local/include/python3.8/object.h **** Objects are always accessed through pointers of the type 'PyObject *'.
  44:/usr/local/include/python3.8/object.h **** The type 'PyObject' is a structure that only contains the reference count
  45:/usr/local/include/python3.8/object.h **** and the type pointer.  The actual memory allocated for an object
  46:/usr/local/include/python3.8/object.h **** contains other data that can only be accessed after casting the pointer
  47:/usr/local/include/python3.8/object.h **** to a pointer to a longer structure type.  This longer type must start
  48:/usr/local/include/python3.8/object.h **** with the reference count and type fields; the macro PyObject_HEAD should be
  49:/usr/local/include/python3.8/object.h **** used for this (to accommodate for future changes).  The implementation
  50:/usr/local/include/python3.8/object.h **** of a particular object type can cast the object pointer to the proper
  51:/usr/local/include/python3.8/object.h **** type and back.
  52:/usr/local/include/python3.8/object.h **** 
  53:/usr/local/include/python3.8/object.h **** A standard interface exists for objects that contain an array of items
  54:/usr/local/include/python3.8/object.h **** whose size is determined when the object is allocated.
  55:/usr/local/include/python3.8/object.h **** */
  56:/usr/local/include/python3.8/object.h **** 
  57:/usr/local/include/python3.8/object.h **** /* Py_DEBUG implies Py_REF_DEBUG. */
  58:/usr/local/include/python3.8/object.h **** #if defined(Py_DEBUG) && !defined(Py_REF_DEBUG)
  59:/usr/local/include/python3.8/object.h **** #define Py_REF_DEBUG
  60:/usr/local/include/python3.8/object.h **** #endif
  61:/usr/local/include/python3.8/object.h **** 
  62:/usr/local/include/python3.8/object.h **** #if defined(Py_LIMITED_API) && defined(Py_REF_DEBUG)
  63:/usr/local/include/python3.8/object.h **** #error Py_LIMITED_API is incompatible with Py_DEBUG, Py_TRACE_REFS, and Py_REF_DEBUG
  64:/usr/local/include/python3.8/object.h **** #endif
  65:/usr/local/include/python3.8/object.h **** 
  66:/usr/local/include/python3.8/object.h **** 
  67:/usr/local/include/python3.8/object.h **** #ifdef Py_TRACE_REFS
  68:/usr/local/include/python3.8/object.h **** /* Define pointers to support a doubly-linked list of all live heap objects. */
  69:/usr/local/include/python3.8/object.h **** #define _PyObject_HEAD_EXTRA            \
  70:/usr/local/include/python3.8/object.h ****     struct _object *_ob_next;           \
  71:/usr/local/include/python3.8/object.h ****     struct _object *_ob_prev;
  72:/usr/local/include/python3.8/object.h **** 
  73:/usr/local/include/python3.8/object.h **** #define _PyObject_EXTRA_INIT 0, 0,
  74:/usr/local/include/python3.8/object.h **** 
  75:/usr/local/include/python3.8/object.h **** #else
  76:/usr/local/include/python3.8/object.h **** #define _PyObject_HEAD_EXTRA
  77:/usr/local/include/python3.8/object.h **** #define _PyObject_EXTRA_INIT
  78:/usr/local/include/python3.8/object.h **** #endif
  79:/usr/local/include/python3.8/object.h **** 
  80:/usr/local/include/python3.8/object.h **** /* PyObject_HEAD defines the initial segment of every PyObject. */
  81:/usr/local/include/python3.8/object.h **** #define PyObject_HEAD                   PyObject ob_base;
  82:/usr/local/include/python3.8/object.h **** 
  83:/usr/local/include/python3.8/object.h **** #define PyObject_HEAD_INIT(type)        \
  84:/usr/local/include/python3.8/object.h ****     { _PyObject_EXTRA_INIT              \
  85:/usr/local/include/python3.8/object.h ****     1, type },
  86:/usr/local/include/python3.8/object.h **** 
  87:/usr/local/include/python3.8/object.h **** #define PyVarObject_HEAD_INIT(type, size)       \
  88:/usr/local/include/python3.8/object.h ****     { PyObject_HEAD_INIT(type) size },
  89:/usr/local/include/python3.8/object.h **** 
  90:/usr/local/include/python3.8/object.h **** /* PyObject_VAR_HEAD defines the initial segment of all variable-size
  91:/usr/local/include/python3.8/object.h ****  * container objects.  These end with a declaration of an array with 1
  92:/usr/local/include/python3.8/object.h ****  * element, but enough space is malloc'ed so that the array actually
  93:/usr/local/include/python3.8/object.h ****  * has room for ob_size elements.  Note that ob_size is an element count,
  94:/usr/local/include/python3.8/object.h ****  * not necessarily a byte count.
  95:/usr/local/include/python3.8/object.h ****  */
  96:/usr/local/include/python3.8/object.h **** #define PyObject_VAR_HEAD      PyVarObject ob_base;
  97:/usr/local/include/python3.8/object.h **** #define Py_INVALID_SIZE (Py_ssize_t)-1
  98:/usr/local/include/python3.8/object.h **** 
  99:/usr/local/include/python3.8/object.h **** /* Nothing is actually declared to be a PyObject, but every pointer to
 100:/usr/local/include/python3.8/object.h ****  * a Python object can be cast to a PyObject*.  This is inheritance built
 101:/usr/local/include/python3.8/object.h ****  * by hand.  Similarly every pointer to a variable-size Python object can,
 102:/usr/local/include/python3.8/object.h ****  * in addition, be cast to PyVarObject*.
 103:/usr/local/include/python3.8/object.h ****  */
 104:/usr/local/include/python3.8/object.h **** typedef struct _object {
 105:/usr/local/include/python3.8/object.h ****     _PyObject_HEAD_EXTRA
 106:/usr/local/include/python3.8/object.h ****     Py_ssize_t ob_refcnt;
 107:/usr/local/include/python3.8/object.h ****     struct _typeobject *ob_type;
 108:/usr/local/include/python3.8/object.h **** } PyObject;
 109:/usr/local/include/python3.8/object.h **** 
 110:/usr/local/include/python3.8/object.h **** /* Cast argument to PyObject* type. */
 111:/usr/local/include/python3.8/object.h **** #define _PyObject_CAST(op) ((PyObject*)(op))
 112:/usr/local/include/python3.8/object.h **** 
 113:/usr/local/include/python3.8/object.h **** typedef struct {
 114:/usr/local/include/python3.8/object.h ****     PyObject ob_base;
 115:/usr/local/include/python3.8/object.h ****     Py_ssize_t ob_size; /* Number of items in variable part */
 116:/usr/local/include/python3.8/object.h **** } PyVarObject;
 117:/usr/local/include/python3.8/object.h **** 
 118:/usr/local/include/python3.8/object.h **** /* Cast argument to PyVarObject* type. */
 119:/usr/local/include/python3.8/object.h **** #define _PyVarObject_CAST(op) ((PyVarObject*)(op))
 120:/usr/local/include/python3.8/object.h **** 
 121:/usr/local/include/python3.8/object.h **** #define Py_REFCNT(ob)           (_PyObject_CAST(ob)->ob_refcnt)
 122:/usr/local/include/python3.8/object.h **** #define Py_TYPE(ob)             (_PyObject_CAST(ob)->ob_type)
 123:/usr/local/include/python3.8/object.h **** #define Py_SIZE(ob)             (_PyVarObject_CAST(ob)->ob_size)
 124:/usr/local/include/python3.8/object.h **** 
 125:/usr/local/include/python3.8/object.h **** /*
 126:/usr/local/include/python3.8/object.h **** Type objects contain a string containing the type name (to help somewhat
 127:/usr/local/include/python3.8/object.h **** in debugging), the allocation parameters (see PyObject_New() and
 128:/usr/local/include/python3.8/object.h **** PyObject_NewVar()),
 129:/usr/local/include/python3.8/object.h **** and methods for accessing objects of the type.  Methods are optional, a
 130:/usr/local/include/python3.8/object.h **** nil pointer meaning that particular kind of access is not available for
 131:/usr/local/include/python3.8/object.h **** this type.  The Py_DECREF() macro uses the tp_dealloc method without
 132:/usr/local/include/python3.8/object.h **** checking for a nil pointer; it should always be implemented except if
 133:/usr/local/include/python3.8/object.h **** the implementation can guarantee that the reference count will never
 134:/usr/local/include/python3.8/object.h **** reach zero (e.g., for statically allocated type objects).
 135:/usr/local/include/python3.8/object.h **** 
 136:/usr/local/include/python3.8/object.h **** NB: the methods for certain type groups are now contained in separate
 137:/usr/local/include/python3.8/object.h **** method blocks.
 138:/usr/local/include/python3.8/object.h **** */
 139:/usr/local/include/python3.8/object.h **** 
 140:/usr/local/include/python3.8/object.h **** typedef PyObject * (*unaryfunc)(PyObject *);
 141:/usr/local/include/python3.8/object.h **** typedef PyObject * (*binaryfunc)(PyObject *, PyObject *);
 142:/usr/local/include/python3.8/object.h **** typedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);
 143:/usr/local/include/python3.8/object.h **** typedef int (*inquiry)(PyObject *);
 144:/usr/local/include/python3.8/object.h **** typedef Py_ssize_t (*lenfunc)(PyObject *);
 145:/usr/local/include/python3.8/object.h **** typedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);
 146:/usr/local/include/python3.8/object.h **** typedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);
 147:/usr/local/include/python3.8/object.h **** typedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);
 148:/usr/local/include/python3.8/object.h **** typedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);
 149:/usr/local/include/python3.8/object.h **** typedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);
 150:/usr/local/include/python3.8/object.h **** 
 151:/usr/local/include/python3.8/object.h **** typedef int (*objobjproc)(PyObject *, PyObject *);
 152:/usr/local/include/python3.8/object.h **** typedef int (*visitproc)(PyObject *, void *);
 153:/usr/local/include/python3.8/object.h **** typedef int (*traverseproc)(PyObject *, visitproc, void *);
 154:/usr/local/include/python3.8/object.h **** 
 155:/usr/local/include/python3.8/object.h **** 
 156:/usr/local/include/python3.8/object.h **** typedef void (*freefunc)(void *);
 157:/usr/local/include/python3.8/object.h **** typedef void (*destructor)(PyObject *);
 158:/usr/local/include/python3.8/object.h **** typedef PyObject *(*getattrfunc)(PyObject *, char *);
 159:/usr/local/include/python3.8/object.h **** typedef PyObject *(*getattrofunc)(PyObject *, PyObject *);
 160:/usr/local/include/python3.8/object.h **** typedef int (*setattrfunc)(PyObject *, char *, PyObject *);
 161:/usr/local/include/python3.8/object.h **** typedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);
 162:/usr/local/include/python3.8/object.h **** typedef PyObject *(*reprfunc)(PyObject *);
 163:/usr/local/include/python3.8/object.h **** typedef Py_hash_t (*hashfunc)(PyObject *);
 164:/usr/local/include/python3.8/object.h **** typedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);
 165:/usr/local/include/python3.8/object.h **** typedef PyObject *(*getiterfunc) (PyObject *);
 166:/usr/local/include/python3.8/object.h **** typedef PyObject *(*iternextfunc) (PyObject *);
 167:/usr/local/include/python3.8/object.h **** typedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);
 168:/usr/local/include/python3.8/object.h **** typedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);
 169:/usr/local/include/python3.8/object.h **** typedef int (*initproc)(PyObject *, PyObject *, PyObject *);
 170:/usr/local/include/python3.8/object.h **** typedef PyObject *(*newfunc)(struct _typeobject *, PyObject *, PyObject *);
 171:/usr/local/include/python3.8/object.h **** typedef PyObject *(*allocfunc)(struct _typeobject *, Py_ssize_t);
 172:/usr/local/include/python3.8/object.h **** 
 173:/usr/local/include/python3.8/object.h **** #ifdef Py_LIMITED_API
 174:/usr/local/include/python3.8/object.h **** /* In Py_LIMITED_API, PyTypeObject is an opaque structure. */
 175:/usr/local/include/python3.8/object.h **** typedef struct _typeobject PyTypeObject;
 176:/usr/local/include/python3.8/object.h **** #else
 177:/usr/local/include/python3.8/object.h **** /* PyTypeObject is defined in cpython/object.h */
 178:/usr/local/include/python3.8/object.h **** #endif
 179:/usr/local/include/python3.8/object.h **** 
 180:/usr/local/include/python3.8/object.h **** typedef struct{
 181:/usr/local/include/python3.8/object.h ****     int slot;    /* slot id, see below */
 182:/usr/local/include/python3.8/object.h ****     void *pfunc; /* function pointer */
 183:/usr/local/include/python3.8/object.h **** } PyType_Slot;
 184:/usr/local/include/python3.8/object.h **** 
 185:/usr/local/include/python3.8/object.h **** typedef struct{
 186:/usr/local/include/python3.8/object.h ****     const char* name;
 187:/usr/local/include/python3.8/object.h ****     int basicsize;
 188:/usr/local/include/python3.8/object.h ****     int itemsize;
 189:/usr/local/include/python3.8/object.h ****     unsigned int flags;
 190:/usr/local/include/python3.8/object.h ****     PyType_Slot *slots; /* terminated by slot==0. */
 191:/usr/local/include/python3.8/object.h **** } PyType_Spec;
 192:/usr/local/include/python3.8/object.h **** 
 193:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);
 194:/usr/local/include/python3.8/object.h **** #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
 195:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);
 196:/usr/local/include/python3.8/object.h **** #endif
 197:/usr/local/include/python3.8/object.h **** #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
 198:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void*) PyType_GetSlot(struct _typeobject*, int);
 199:/usr/local/include/python3.8/object.h **** #endif
 200:/usr/local/include/python3.8/object.h **** 
 201:/usr/local/include/python3.8/object.h **** /* Generic type check */
 202:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyType_IsSubtype(struct _typeobject *, struct _typeobject *);
 203:/usr/local/include/python3.8/object.h **** #define PyObject_TypeCheck(ob, tp) \
 204:/usr/local/include/python3.8/object.h ****     (Py_TYPE(ob) == (tp) || PyType_IsSubtype(Py_TYPE(ob), (tp)))
 205:/usr/local/include/python3.8/object.h **** 
 206:/usr/local/include/python3.8/object.h **** PyAPI_DATA(struct _typeobject) PyType_Type; /* built-in 'type' */
 207:/usr/local/include/python3.8/object.h **** PyAPI_DATA(struct _typeobject) PyBaseObject_Type; /* built-in 'object' */
 208:/usr/local/include/python3.8/object.h **** PyAPI_DATA(struct _typeobject) PySuper_Type; /* built-in 'super' */
 209:/usr/local/include/python3.8/object.h **** 
 210:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(unsigned long) PyType_GetFlags(struct _typeobject*);
 211:/usr/local/include/python3.8/object.h **** 
 212:/usr/local/include/python3.8/object.h **** #define PyType_Check(op) \
 213:/usr/local/include/python3.8/object.h ****     PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS)
 214:/usr/local/include/python3.8/object.h **** #define PyType_CheckExact(op) (Py_TYPE(op) == &PyType_Type)
 215:/usr/local/include/python3.8/object.h **** 
 216:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyType_Ready(struct _typeobject *);
 217:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyType_GenericAlloc(struct _typeobject *, Py_ssize_t);
 218:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyType_GenericNew(struct _typeobject *,
 219:/usr/local/include/python3.8/object.h ****                                                PyObject *, PyObject *);
 220:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(unsigned int) PyType_ClearCache(void);
 221:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) PyType_Modified(struct _typeobject *);
 222:/usr/local/include/python3.8/object.h **** 
 223:/usr/local/include/python3.8/object.h **** /* Generic operations on objects */
 224:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);
 225:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);
 226:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);
 227:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);
 228:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);
 229:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);
 230:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);
 231:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);
 232:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);
 233:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);
 234:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);
 235:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);
 236:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);
 237:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);
 238:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *,
 239:/usr/local/include/python3.8/object.h ****                                               PyObject *, PyObject *);
 240:/usr/local/include/python3.8/object.h **** #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
 241:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);
 242:/usr/local/include/python3.8/object.h **** #endif
 243:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(Py_hash_t) PyObject_Hash(PyObject *);
 244:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(Py_hash_t) PyObject_HashNotImplemented(PyObject *);
 245:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_IsTrue(PyObject *);
 246:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_Not(PyObject *);
 247:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyCallable_Check(PyObject *);
 248:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);
 249:/usr/local/include/python3.8/object.h **** 
 250:/usr/local/include/python3.8/object.h **** /* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a
 251:/usr/local/include/python3.8/object.h ****    list of strings.  PyObject_Dir(NULL) is like builtins.dir(),
 252:/usr/local/include/python3.8/object.h ****    returning the names of the current locals.  In this case, if there are
 253:/usr/local/include/python3.8/object.h ****    no current locals, NULL is returned, and PyErr_Occurred() is false.
 254:/usr/local/include/python3.8/object.h **** */
 255:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);
 256:/usr/local/include/python3.8/object.h **** 
 257:/usr/local/include/python3.8/object.h **** 
 258:/usr/local/include/python3.8/object.h **** /* Helpers for printing recursive container types */
 259:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) Py_ReprEnter(PyObject *);
 260:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) Py_ReprLeave(PyObject *);
 261:/usr/local/include/python3.8/object.h **** 
 262:/usr/local/include/python3.8/object.h **** /* Flag bits for printing: */
 263:/usr/local/include/python3.8/object.h **** #define Py_PRINT_RAW    1       /* No string quotes etc. */
 264:/usr/local/include/python3.8/object.h **** 
 265:/usr/local/include/python3.8/object.h **** /*
 266:/usr/local/include/python3.8/object.h **** Type flags (tp_flags)
 267:/usr/local/include/python3.8/object.h **** 
 268:/usr/local/include/python3.8/object.h **** These flags are used to change expected features and behavior for a
 269:/usr/local/include/python3.8/object.h **** particular type.
 270:/usr/local/include/python3.8/object.h **** 
 271:/usr/local/include/python3.8/object.h **** Arbitration of the flag bit positions will need to be coordinated among
 272:/usr/local/include/python3.8/object.h **** all extension writers who publicly release their extensions (this will
 273:/usr/local/include/python3.8/object.h **** be fewer than you might expect!).
 274:/usr/local/include/python3.8/object.h **** 
 275:/usr/local/include/python3.8/object.h **** Most flags were removed as of Python 3.0 to make room for new flags.  (Some
 276:/usr/local/include/python3.8/object.h **** flags are not for backwards compatibility but to indicate the presence of an
 277:/usr/local/include/python3.8/object.h **** optional feature; these flags remain of course.)
 278:/usr/local/include/python3.8/object.h **** 
 279:/usr/local/include/python3.8/object.h **** Type definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.
 280:/usr/local/include/python3.8/object.h **** 
 281:/usr/local/include/python3.8/object.h **** Code can use PyType_HasFeature(type_ob, flag_value) to test whether the
 282:/usr/local/include/python3.8/object.h **** given type object has a specified feature.
 283:/usr/local/include/python3.8/object.h **** */
 284:/usr/local/include/python3.8/object.h **** 
 285:/usr/local/include/python3.8/object.h **** /* Set if the type object is dynamically allocated */
 286:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HEAPTYPE (1UL << 9)
 287:/usr/local/include/python3.8/object.h **** 
 288:/usr/local/include/python3.8/object.h **** /* Set if the type allows subclassing */
 289:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_BASETYPE (1UL << 10)
 290:/usr/local/include/python3.8/object.h **** 
 291:/usr/local/include/python3.8/object.h **** /* Set if the type implements the vectorcall protocol (PEP 590) */
 292:/usr/local/include/python3.8/object.h **** #ifndef Py_LIMITED_API
 293:/usr/local/include/python3.8/object.h **** #define _Py_TPFLAGS_HAVE_VECTORCALL (1UL << 11)
 294:/usr/local/include/python3.8/object.h **** #endif
 295:/usr/local/include/python3.8/object.h **** 
 296:/usr/local/include/python3.8/object.h **** /* Set if the type is 'ready' -- fully initialized */
 297:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_READY (1UL << 12)
 298:/usr/local/include/python3.8/object.h **** 
 299:/usr/local/include/python3.8/object.h **** /* Set while the type is being 'readied', to prevent recursive ready calls */
 300:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_READYING (1UL << 13)
 301:/usr/local/include/python3.8/object.h **** 
 302:/usr/local/include/python3.8/object.h **** /* Objects support garbage collection (see objimpl.h) */
 303:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HAVE_GC (1UL << 14)
 304:/usr/local/include/python3.8/object.h **** 
 305:/usr/local/include/python3.8/object.h **** /* These two bits are preserved for Stackless Python, next after this is 17 */
 306:/usr/local/include/python3.8/object.h **** #ifdef STACKLESS
 307:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3UL << 15)
 308:/usr/local/include/python3.8/object.h **** #else
 309:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0
 310:/usr/local/include/python3.8/object.h **** #endif
 311:/usr/local/include/python3.8/object.h **** 
 312:/usr/local/include/python3.8/object.h **** /* Objects behave like an unbound method */
 313:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_METHOD_DESCRIPTOR (1UL << 17)
 314:/usr/local/include/python3.8/object.h **** 
 315:/usr/local/include/python3.8/object.h **** /* Objects support type attribute cache */
 316:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HAVE_VERSION_TAG   (1UL << 18)
 317:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_VALID_VERSION_TAG  (1UL << 19)
 318:/usr/local/include/python3.8/object.h **** 
 319:/usr/local/include/python3.8/object.h **** /* Type is abstract and cannot be instantiated */
 320:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_IS_ABSTRACT (1UL << 20)
 321:/usr/local/include/python3.8/object.h **** 
 322:/usr/local/include/python3.8/object.h **** /* These flags are used to determine if a type is a subclass. */
 323:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_LONG_SUBCLASS        (1UL << 24)
 324:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_LIST_SUBCLASS        (1UL << 25)
 325:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_TUPLE_SUBCLASS       (1UL << 26)
 326:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_BYTES_SUBCLASS       (1UL << 27)
 327:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_UNICODE_SUBCLASS     (1UL << 28)
 328:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_DICT_SUBCLASS        (1UL << 29)
 329:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_BASE_EXC_SUBCLASS    (1UL << 30)
 330:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_TYPE_SUBCLASS        (1UL << 31)
 331:/usr/local/include/python3.8/object.h **** 
 332:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_DEFAULT  ( \
 333:/usr/local/include/python3.8/object.h ****                  Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \
 334:/usr/local/include/python3.8/object.h ****                  Py_TPFLAGS_HAVE_VERSION_TAG | \
 335:/usr/local/include/python3.8/object.h ****                 0)
 336:/usr/local/include/python3.8/object.h **** 
 337:/usr/local/include/python3.8/object.h **** /* NOTE: The following flags reuse lower bits (removed as part of the
 338:/usr/local/include/python3.8/object.h ****  * Python 3.0 transition). */
 339:/usr/local/include/python3.8/object.h **** 
 340:/usr/local/include/python3.8/object.h **** /* The following flag is kept for compatibility.  Starting with 3.8,
 341:/usr/local/include/python3.8/object.h ****  * binary compatibility of C extensions accross feature releases of
 342:/usr/local/include/python3.8/object.h ****  * Python is not supported anymore, except when using the stable ABI.
 343:/usr/local/include/python3.8/object.h ****  */
 344:/usr/local/include/python3.8/object.h **** 
 345:/usr/local/include/python3.8/object.h **** /* Type structure has tp_finalize member (3.4) */
 346:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HAVE_FINALIZE (1UL << 0)
 347:/usr/local/include/python3.8/object.h **** 
 348:/usr/local/include/python3.8/object.h **** #ifdef Py_LIMITED_API
 349:/usr/local/include/python3.8/object.h **** #  define PyType_HasFeature(t,f)  ((PyType_GetFlags(t) & (f)) != 0)
 350:/usr/local/include/python3.8/object.h **** #endif
 351:/usr/local/include/python3.8/object.h **** #define PyType_FastSubclass(t,f)  PyType_HasFeature(t,f)
 352:/usr/local/include/python3.8/object.h **** 
 353:/usr/local/include/python3.8/object.h **** 
 354:/usr/local/include/python3.8/object.h **** /*
 355:/usr/local/include/python3.8/object.h **** The macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement
 356:/usr/local/include/python3.8/object.h **** reference counts.  Py_DECREF calls the object's deallocator function when
 357:/usr/local/include/python3.8/object.h **** the refcount falls to 0; for
 358:/usr/local/include/python3.8/object.h **** objects that don't contain references to other objects or heap memory
 359:/usr/local/include/python3.8/object.h **** this can be the standard function free().  Both macros can be used
 360:/usr/local/include/python3.8/object.h **** wherever a void expression is allowed.  The argument must not be a
 361:/usr/local/include/python3.8/object.h **** NULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.
 362:/usr/local/include/python3.8/object.h **** The macro _Py_NewReference(op) initialize reference counts to 1, and
 363:/usr/local/include/python3.8/object.h **** in special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional
 364:/usr/local/include/python3.8/object.h **** bookkeeping appropriate to the special build.
 365:/usr/local/include/python3.8/object.h **** 
 366:/usr/local/include/python3.8/object.h **** We assume that the reference count field can never overflow; this can
 367:/usr/local/include/python3.8/object.h **** be proven when the size of the field is the same as the pointer size, so
 368:/usr/local/include/python3.8/object.h **** we ignore the possibility.  Provided a C int is at least 32 bits (which
 369:/usr/local/include/python3.8/object.h **** is implicitly assumed in many parts of this code), that's enough for
 370:/usr/local/include/python3.8/object.h **** about 2**31 references to an object.
 371:/usr/local/include/python3.8/object.h **** 
 372:/usr/local/include/python3.8/object.h **** XXX The following became out of date in Python 2.2, but I'm not sure
 373:/usr/local/include/python3.8/object.h **** XXX what the full truth is now.  Certainly, heap-allocated type objects
 374:/usr/local/include/python3.8/object.h **** XXX can and should be deallocated.
 375:/usr/local/include/python3.8/object.h **** Type objects should never be deallocated; the type pointer in an object
 376:/usr/local/include/python3.8/object.h **** is not considered to be a reference to the type object, to save
 377:/usr/local/include/python3.8/object.h **** complications in the deallocation function.  (This is actually a
 378:/usr/local/include/python3.8/object.h **** decision that's up to the implementer of each new type so if you want,
 379:/usr/local/include/python3.8/object.h **** you can count such references to the type object.)
 380:/usr/local/include/python3.8/object.h **** */
 381:/usr/local/include/python3.8/object.h **** 
 382:/usr/local/include/python3.8/object.h **** /* First define a pile of simple helper macros, one set per special
 383:/usr/local/include/python3.8/object.h ****  * build symbol.  These either expand to the obvious things, or to
 384:/usr/local/include/python3.8/object.h ****  * nothing at all when the special mode isn't in effect.  The main
 385:/usr/local/include/python3.8/object.h ****  * macros can later be defined just once then, yet expand to different
 386:/usr/local/include/python3.8/object.h ****  * things depending on which special build options are and aren't in effect.
 387:/usr/local/include/python3.8/object.h ****  * Trust me <wink>:  while painful, this is 20x easier to understand than,
 388:/usr/local/include/python3.8/object.h ****  * e.g, defining _Py_NewReference five different times in a maze of nested
 389:/usr/local/include/python3.8/object.h ****  * #ifdefs (we used to do that -- it was impenetrable).
 390:/usr/local/include/python3.8/object.h ****  */
 391:/usr/local/include/python3.8/object.h **** #ifdef Py_REF_DEBUG
 392:/usr/local/include/python3.8/object.h **** PyAPI_DATA(Py_ssize_t) _Py_RefTotal;
 393:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_NegativeRefcount(const char *filename, int lineno,
 394:/usr/local/include/python3.8/object.h ****                                       PyObject *op);
 395:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(Py_ssize_t) _Py_GetRefTotal(void);
 396:/usr/local/include/python3.8/object.h **** #define _Py_INC_REFTOTAL        _Py_RefTotal++
 397:/usr/local/include/python3.8/object.h **** #define _Py_DEC_REFTOTAL        _Py_RefTotal--
 398:/usr/local/include/python3.8/object.h **** 
 399:/usr/local/include/python3.8/object.h **** /* Py_REF_DEBUG also controls the display of refcounts and memory block
 400:/usr/local/include/python3.8/object.h ****  * allocations at the interactive prompt and at interpreter shutdown
 401:/usr/local/include/python3.8/object.h ****  */
 402:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _PyDebug_PrintTotalRefs(void);
 403:/usr/local/include/python3.8/object.h **** #else
 404:/usr/local/include/python3.8/object.h **** #define _Py_INC_REFTOTAL
 405:/usr/local/include/python3.8/object.h **** #define _Py_DEC_REFTOTAL
 406:/usr/local/include/python3.8/object.h **** #endif /* Py_REF_DEBUG */
 407:/usr/local/include/python3.8/object.h **** 
 408:/usr/local/include/python3.8/object.h **** #ifdef COUNT_ALLOCS
 409:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_inc_count(struct _typeobject *);
 410:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_dec_count(struct _typeobject *);
 411:/usr/local/include/python3.8/object.h **** #define _Py_INC_TPALLOCS(OP)    _Py_inc_count(Py_TYPE(OP))
 412:/usr/local/include/python3.8/object.h **** #define _Py_INC_TPFREES(OP)     _Py_dec_count(Py_TYPE(OP))
 413:/usr/local/include/python3.8/object.h **** #define _Py_DEC_TPFREES(OP)     Py_TYPE(OP)->tp_frees--
 414:/usr/local/include/python3.8/object.h **** #define _Py_COUNT_ALLOCS_COMMA  ,
 415:/usr/local/include/python3.8/object.h **** #else
 416:/usr/local/include/python3.8/object.h **** #define _Py_INC_TPALLOCS(OP)
 417:/usr/local/include/python3.8/object.h **** #define _Py_INC_TPFREES(OP)
 418:/usr/local/include/python3.8/object.h **** #define _Py_DEC_TPFREES(OP)
 419:/usr/local/include/python3.8/object.h **** #define _Py_COUNT_ALLOCS_COMMA
 420:/usr/local/include/python3.8/object.h **** #endif /* COUNT_ALLOCS */
 421:/usr/local/include/python3.8/object.h **** 
 422:/usr/local/include/python3.8/object.h **** /* Update the Python traceback of an object. This function must be called
 423:/usr/local/include/python3.8/object.h ****    when a memory block is reused from a free list. */
 424:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) _PyTraceMalloc_NewReference(PyObject *op);
 425:/usr/local/include/python3.8/object.h **** 
 426:/usr/local/include/python3.8/object.h **** #ifdef Py_TRACE_REFS
 427:/usr/local/include/python3.8/object.h **** /* Py_TRACE_REFS is such major surgery that we call external routines. */
 428:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_NewReference(PyObject *);
 429:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_ForgetReference(PyObject *);
 430:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_PrintReferences(FILE *);
 431:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_PrintReferenceAddresses(FILE *);
 432:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_AddToAllObjects(PyObject *, int force);
 433:/usr/local/include/python3.8/object.h **** #else
 434:/usr/local/include/python3.8/object.h **** /* Without Py_TRACE_REFS, there's little enough to do that we expand code
 435:/usr/local/include/python3.8/object.h ****    inline. */
 436:/usr/local/include/python3.8/object.h **** static inline void _Py_NewReference(PyObject *op)
 437:/usr/local/include/python3.8/object.h **** {
 438:/usr/local/include/python3.8/object.h ****     if (_Py_tracemalloc_config.tracing) {
 439:/usr/local/include/python3.8/object.h ****         _PyTraceMalloc_NewReference(op);
 440:/usr/local/include/python3.8/object.h ****     }
 441:/usr/local/include/python3.8/object.h ****     _Py_INC_TPALLOCS(op);
 442:/usr/local/include/python3.8/object.h ****     _Py_INC_REFTOTAL;
 443:/usr/local/include/python3.8/object.h ****     Py_REFCNT(op) = 1;
 444:/usr/local/include/python3.8/object.h **** }
 445:/usr/local/include/python3.8/object.h **** 
 446:/usr/local/include/python3.8/object.h **** static inline void _Py_ForgetReference(PyObject *op)
 447:/usr/local/include/python3.8/object.h **** {
 448:/usr/local/include/python3.8/object.h ****     (void)op; /* may be unused, shut up -Wunused-parameter */
 449:/usr/local/include/python3.8/object.h ****     _Py_INC_TPFREES(op);
 450:/usr/local/include/python3.8/object.h **** }
 451:/usr/local/include/python3.8/object.h **** #endif /* !Py_TRACE_REFS */
 452:/usr/local/include/python3.8/object.h **** 
 453:/usr/local/include/python3.8/object.h **** 
 454:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_Dealloc(PyObject *);
 455:/usr/local/include/python3.8/object.h **** 
 456:/usr/local/include/python3.8/object.h **** static inline void _Py_INCREF(PyObject *op)
 2302              		.loc 2 456 20 view .LVU556
 2303              	.LBB26:
 457:/usr/local/include/python3.8/object.h **** {
 458:/usr/local/include/python3.8/object.h ****     _Py_INC_REFTOTAL;
 2304              		.loc 2 458 21 view .LVU557
 459:/usr/local/include/python3.8/object.h ****     op->ob_refcnt++;
 2305              		.loc 2 459 5 view .LVU558
 2306              	@ /usr/local/include/python3.8/object.h:459:     op->ob_refcnt++;
 2307              		.loc 2 459 18 is_stmt 0 view .LVU559
 2308 0a50 38309FE5 		ldr	r3, .L135	@ tmp126,
 2309              	.LBE26:
 2310              	.LBE25:
 2311              	@ armwave.c:492:     Py_RETURN_TRUE;
 2312              		.loc 1 492 5 view .LVU560
 2313 0a54 0300A0E1 		mov	r0, r3	@ <retval>, tmp126
 2314              	.LBB28:
 2315              	.LBB27:
 2316              	@ /usr/local/include/python3.8/object.h:459:     op->ob_refcnt++;
 2317              		.loc 2 459 18 view .LVU561
 2318 0a58 002093E5 		ldr	r2, [r3]	@ MEM[(Py_ssize_t *)&_Py_TrueStruct],
 2319 0a5c 012082E2 		add	r2, r2, #1	@ tmp128, MEM[(Py_ssize_t *)&_Py_TrueStruct],
 2320 0a60 002083E5 		str	r2, [r3]	@ tmp128,
 2321              	.LBE27:
 2322              	.LBE28:
 2323              	@ armwave.c:493: }
 493:armwave.c     **** }
 2324              		.loc 1 493 1 view .LVU562
 2325 0a64 34D08DE2 		add	sp, sp, #52	@,,
 2326              		.cfi_remember_state
 2327              		.cfi_def_cfa_offset 4
 2328              		@ sp needed	@
 2329 0a68 04F09DE4 		ldr	pc, [sp], #4	@
 2330              	.LVL158:
 2331              	.L134:
 2332              		.cfi_restore_state
 480:armwave.c     ****         Py_RETURN_FALSE;
 2333              		.loc 1 480 9 is_stmt 1 view .LVU563
 2334 0a6c 20009FE5 		ldr	r0, .L135+4	@,
 2335              	.LVL159:
 480:armwave.c     ****         Py_RETURN_FALSE;
 2336              		.loc 1 480 9 is_stmt 0 view .LVU564
 2337 0a70 FEFFFFEB 		bl	puts		@
 2338              	.LVL160:
 481:armwave.c     ****     }
 2339              		.loc 1 481 9 is_stmt 1 view .LVU565
 2340              	.LBB29:
 2341              	.LBI29:
 456:/usr/local/include/python3.8/object.h **** {
 2342              		.loc 2 456 20 view .LVU566
 2343              	.LBB30:
 458:/usr/local/include/python3.8/object.h ****     op->ob_refcnt++;
 2344              		.loc 2 458 21 view .LVU567
 2345              		.loc 2 459 5 view .LVU568
 2346              	@ /usr/local/include/python3.8/object.h:459:     op->ob_refcnt++;
 2347              		.loc 2 459 18 is_stmt 0 view .LVU569
 2348 0a74 1C309FE5 		ldr	r3, .L135+8	@ tmp120,
 2349              	.LBE30:
 2350              	.LBE29:
 2351              	@ armwave.c:481:         Py_RETURN_FALSE;
 481:armwave.c     ****     }
 2352              		.loc 1 481 9 view .LVU570
 2353 0a78 0300A0E1 		mov	r0, r3	@ <retval>, tmp120
 2354              	.LBB32:
 2355              	.LBB31:
 2356              	@ /usr/local/include/python3.8/object.h:459:     op->ob_refcnt++;
 2357              		.loc 2 459 18 view .LVU571
 2358 0a7c 002093E5 		ldr	r2, [r3]	@ MEM[(Py_ssize_t *)&_Py_FalseStruct],
 2359 0a80 012082E2 		add	r2, r2, #1	@ tmp122, MEM[(Py_ssize_t *)&_Py_FalseStruct],
 2360 0a84 002083E5 		str	r2, [r3]	@ tmp122,
 2361              	.LBE31:
 2362              	.LBE32:
 2363              	@ armwave.c:493: }
 2364              		.loc 1 493 1 view .LVU572
 2365 0a88 34D08DE2 		add	sp, sp, #52	@,,
 2366              		.cfi_def_cfa_offset 4
 2367              		@ sp needed	@
 2368 0a8c 04F09DE4 		ldr	pc, [sp], #4	@
 2369              	.L136:
 2370              		.align	2
 2371              	.L135:
 2372 0a90 00000000 		.word	_Py_TrueStruct
 2373 0a94 34030000 		.word	.LC24
 2374 0a98 00000000 		.word	_Py_FalseStruct
 2375              		.cfi_endproc
 2376              	.LFE74:
 2378              		.align	2
 2379              		.global	armwave_test_create_am_sine
 2380              		.syntax unified
 2381              		.arm
 2382              		.fpu vfp
 2384              	armwave_test_create_am_sine:
 2385              	.LVL161:
 2386              	.LFB75:
 494:armwave.c     **** 
 495:armwave.c     **** /*
 496:armwave.c     ****  * Make a test AM waveform for render tests.
 497:armwave.c     ****  *
 498:armwave.c     ****  * @param   mod                     modulation depth
 499:armwave.c     ****  * @param   noise_fraction          typically 1e-6
 500:armwave.c     ****  * @param   number of wave sets     1-N, must have memory for these
 501:armwave.c     ****  */
 502:armwave.c     **** void armwave_test_create_am_sine(float mod, float noise_fraction, int sets)
 503:armwave.c     **** {
 2387              		.loc 1 503 1 is_stmt 1 view -0
 2388              		.cfi_startproc
 2389              		@ args = 0, pretend = 0, frame = 8
 2390              		@ frame_needed = 0, uses_anonymous_args = 0
 504:armwave.c     ****     float v, noise, xnoise, mod_val;
 2391              		.loc 1 504 5 view .LVU574
 505:armwave.c     ****     float _1_waves_mod = mod * (1.0f / g_armwave_state.waves);
 2392              		.loc 1 505 5 view .LVU575
 2393              	@ armwave.c:503: {
 503:armwave.c     ****     float v, noise, xnoise, mod_val;
 2394              		.loc 1 503 1 is_stmt 0 view .LVU576
 2395 0a9c F0472DE9 		push	{r4, r5, r6, r7, r8, r9, r10, lr}	@
 2396              		.cfi_def_cfa_offset 32
 2397              		.cfi_offset 4, -32
 2398              		.cfi_offset 5, -28
 2399              		.cfi_offset 6, -24
 2400              		.cfi_offset 7, -20
 2401              		.cfi_offset 8, -16
 2402              		.cfi_offset 9, -12
 2403              		.cfi_offset 10, -8
 2404              		.cfi_offset 14, -4
 2405              	@ armwave.c:505:     float _1_waves_mod = mod * (1.0f / g_armwave_state.waves);
 2406              		.loc 1 505 38 view .LVU577
 2407 0aa0 7A7A9FED 		vldr.32	s14, .L168	@ tmp180,
 2408              	@ armwave.c:505:     float _1_waves_mod = mod * (1.0f / g_armwave_state.waves);
 2409              		.loc 1 505 55 view .LVU578
 2410 0aa4 00529FE5 		ldr	r5, .L168+28	@ tmp250,
 2411              	@ armwave.c:503: {
 503:armwave.c     ****     float v, noise, xnoise, mod_val;
 2412              		.loc 1 503 1 view .LVU579
 2413 0aa8 0C8B2DED 		vpush.64	{d8, d9, d10, d11, d12, d13}	@
 2414              		.cfi_def_cfa_offset 80
 2415              		.cfi_offset 80, -80
 2416              		.cfi_offset 81, -76
 2417              		.cfi_offset 82, -72
 2418              		.cfi_offset 83, -68
 2419              		.cfi_offset 84, -64
 2420              		.cfi_offset 85, -60
 2421              		.cfi_offset 86, -56
 2422              		.cfi_offset 87, -52
 2423              		.cfi_offset 88, -48
 2424              		.cfi_offset 89, -44
 2425              		.cfi_offset 90, -40
 2426              		.cfi_offset 91, -36
 2427 0aac 0090A0E1 		mov	r9, r0	@ sets, sets
 2428              	@ armwave.c:505:     float _1_waves_mod = mod * (1.0f / g_armwave_state.waves);
 2429              		.loc 1 505 38 view .LVU580
 2430 0ab0 0E7AD5ED 		vldr.32	s15, [r5, #56]	@ int	@ tmp264, g_armwave_state.waves
 2431              	@ armwave.c:509:     g_armwave_state.test_wave_buffer_stride = (g_armwave_state.waves * g_armwave_s
 506:armwave.c     ****     int s, set_offset = 0;
 507:armwave.c     ****     int w, x;
 508:armwave.c     **** 
 509:armwave.c     ****     g_armwave_state.test_wave_buffer_stride = (g_armwave_state.waves * g_armwave_state.wave_stride)
 2432              		.loc 1 509 70 view .LVU581
 2433 0ab4 343095E5 		ldr	r3, [r5, #52]	@ g_armwave_state.wave_stride, g_armwave_state.wave_stride
 2434 0ab8 382095E5 		ldr	r2, [r5, #56]	@ tmp265, g_armwave_state.waves
 2435              	.LBB35:
 2436              	.LBB36:
 2437              	@ armwave.c:452:     if(g_armwave_state.test_wave_buffer != NULL) {
 452:armwave.c     ****         free(g_armwave_state.test_wave_buffer);
 2438              		.loc 1 452 23 view .LVU582
 2439 0abc 180095E5 		ldr	r0, [r5, #24]	@ _82, g_armwave_state.test_wave_buffer
 2440              	.LVL162:
 452:armwave.c     ****         free(g_armwave_state.test_wave_buffer);
 2441              		.loc 1 452 23 view .LVU583
 2442              	.LBE36:
 2443              	.LBE35:
 2444              	@ armwave.c:505:     float _1_waves_mod = mod * (1.0f / g_armwave_state.waves);
 505:armwave.c     ****     int s, set_offset = 0;
 2445              		.loc 1 505 38 view .LVU584
 2446 0ac0 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp178, tmp264
 2447              	@ armwave.c:509:     g_armwave_state.test_wave_buffer_stride = (g_armwave_state.waves * g_armwave_s
 2448              		.loc 1 509 70 view .LVU585
 2449 0ac4 920303E0 		mul	r3, r2, r3	@ tmp183, tmp265, g_armwave_state.wave_stride
 2450              	@ armwave.c:503: {
 503:armwave.c     ****     float v, noise, xnoise, mod_val;
 2451              		.loc 1 503 1 view .LVU586
 2452 0ac8 60BAF0EE 		vmov.f32	s23, s1	@ noise_fraction, noise_fraction
 2453              	.LBB40:
 2454              	.LBB37:
 2455              	@ armwave.c:452:     if(g_armwave_state.test_wave_buffer != NULL) {
 452:armwave.c     ****         free(g_armwave_state.test_wave_buffer);
 2456              		.loc 1 452 7 view .LVU587
 2457 0acc 000050E3 		cmp	r0, #0	@ _82,
 2458              	.LBE37:
 2459              	.LBE40:
 2460              	@ armwave.c:503: {
 503:armwave.c     ****     float v, noise, xnoise, mod_val;
 2461              		.loc 1 503 1 view .LVU588
 2462 0ad0 08D04DE2 		sub	sp, sp, #8	@,,
 2463              		.cfi_def_cfa_offset 88
 2464              	@ armwave.c:510:     g_armwave_state.test_wave_buffer_nsets = sets;
 510:armwave.c     ****     g_armwave_state.test_wave_buffer_nsets = sets;
 2465              		.loc 1 510 44 view .LVU589
 2466 0ad4 209085E5 		str	r9, [r5, #32]	@ sets, g_armwave_state.test_wave_buffer_nsets
 2467              	@ armwave.c:509:     g_armwave_state.test_wave_buffer_stride = (g_armwave_state.waves * g_armwave_s
 509:armwave.c     ****     g_armwave_state.test_wave_buffer_nsets = sets;
 2468              		.loc 1 509 45 view .LVU590
 2469 0ad8 1C3085E5 		str	r3, [r5, #28]	@ tmp183, g_armwave_state.test_wave_buffer_stride
 2470              	@ armwave.c:505:     float _1_waves_mod = mod * (1.0f / g_armwave_state.waves);
 505:armwave.c     ****     int s, set_offset = 0;
 2471              		.loc 1 505 38 view .LVU591
 2472 0adc 27DA87EE 		vdiv.f32	s26, s14, s15	@ tmp179, tmp180, tmp178
 2473              	@ armwave.c:505:     float _1_waves_mod = mod * (1.0f / g_armwave_state.waves);
 505:armwave.c     ****     int s, set_offset = 0;
 2474              		.loc 1 505 11 view .LVU592
 2475 0ae0 00DA2DEE 		vmul.f32	s26, s26, s0	@ _1_waves_mod, tmp179, mod
 2476              	.LVL163:
 506:armwave.c     ****     int w, x;
 2477              		.loc 1 506 5 is_stmt 1 view .LVU593
 507:armwave.c     **** 
 2478              		.loc 1 507 5 view .LVU594
 509:armwave.c     ****     g_armwave_state.test_wave_buffer_nsets = sets;
 2479              		.loc 1 509 5 view .LVU595
 2480              		.loc 1 510 5 view .LVU596
 511:armwave.c     ****     armwave_test_buffer_alloc(sets);
 2481              		.loc 1 511 5 view .LVU597
 2482              	.LBB41:
 2483              	.LBI35:
 450:armwave.c     **** {
 2484              		.loc 1 450 6 view .LVU598
 2485              	.LBB38:
 452:armwave.c     ****         free(g_armwave_state.test_wave_buffer);
 2486              		.loc 1 452 5 view .LVU599
 2487              	@ armwave.c:452:     if(g_armwave_state.test_wave_buffer != NULL) {
 452:armwave.c     ****         free(g_armwave_state.test_wave_buffer);
 2488              		.loc 1 452 7 is_stmt 0 view .LVU600
 2489 0ae4 0000000A 		beq	.L138		@,
 453:armwave.c     ****     }
 2490              		.loc 1 453 9 is_stmt 1 view .LVU601
 2491 0ae8 FEFFFFEB 		bl	free		@
 2492              	.LVL164:
 2493              	.L138:
 458:armwave.c     **** 
 2494              		.loc 1 458 5 view .LVU602
 2495              	@ armwave.c:458:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 458:armwave.c     **** 
 2496              		.loc 1 458 75 is_stmt 0 view .LVU603
 2497 0aec 4C3095E5 		ldr	r3, [r5, #76]	@ g_armwave_state.wave_length, g_armwave_state.wave_length
 2498 0af0 3C4095E5 		ldr	r4, [r5, #60]	@ g_armwave_state.waves_max, g_armwave_state.waves_max
 2499              	@ armwave.c:458:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 458:armwave.c     **** 
 2500              		.loc 1 458 40 view .LVU604
 2501 0af4 0910A0E1 		mov	r1, r9	@, sets
 2502              	@ armwave.c:458:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 458:armwave.c     **** 
 2503              		.loc 1 458 75 view .LVU605
 2504 0af8 940304E0 		mul	r4, r4, r3	@ _85, g_armwave_state.waves_max, g_armwave_state.wave_length
 2505              	@ armwave.c:458:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 458:armwave.c     **** 
 2506              		.loc 1 458 40 view .LVU606
 2507 0afc 0400A0E1 		mov	r0, r4	@, _85
 2508 0b00 FEFFFFEB 		bl	calloc		@
 2509              	.LVL165:
 2510              	@ armwave.c:460:     if(g_armwave_state.test_wave_buffer == NULL) {
 460:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes, %d sets)\
 2511              		.loc 1 460 7 view .LVU607
 2512 0b04 000050E3 		cmp	r0, #0	@ tmp191,
 2513              	@ armwave.c:458:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 458:armwave.c     **** 
 2514              		.loc 1 458 38 view .LVU608
 2515 0b08 180085E5 		str	r0, [r5, #24]	@ tmp191, g_armwave_state.test_wave_buffer
 460:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes, %d sets)\
 2516              		.loc 1 460 5 is_stmt 1 view .LVU609
 2517              	@ armwave.c:460:     if(g_armwave_state.test_wave_buffer == NULL) {
 460:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes, %d sets)\
 2518              		.loc 1 460 7 is_stmt 0 view .LVU610
 2519 0b0c 5A00000A 		beq	.L167		@,
 2520              	.L139:
 2521              	.LVL166:
 460:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes, %d sets)\
 2522              		.loc 1 460 7 view .LVU611
 2523              	.LBE38:
 2524              	.LBE41:
 2525              	@ armwave.c:513:     for(s = 0; s < sets; s++) {
 512:armwave.c     **** 
 513:armwave.c     ****     for(s = 0; s < sets; s++) {
 2526              		.loc 1 513 5 discriminator 1 view .LVU612
 2527 0b10 000059E3 		cmp	r9, #0	@ sets,
 2528 0b14 550000DA 		ble	.L137		@,
 2529              	@ armwave.c:532:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 514:armwave.c     ****         printf("Calculating test set %d\n", s);
 515:armwave.c     ****     
 516:armwave.c     ****         for(w = 0; w < g_armwave_state.waves; w++) {
 517:armwave.c     ****             //mod_val = 0.5f + (((float)w / g_armwave_state.waves) * mod);
 518:armwave.c     ****             mod_val = 0.5f + (_1_waves_mod * w);
 519:armwave.c     **** 
 520:armwave.c     ****             for(x = 0; x < g_armwave_state.wave_length; x++) {
 521:armwave.c     ****                 noise  = ((rand() & 0xffff) * noise_fraction);
 522:armwave.c     ****                 noise *= noise;
 523:armwave.c     ****                 noise *= noise;
 524:armwave.c     ****                 noise *= noise;
 525:armwave.c     **** 
 526:armwave.c     ****                 if((rand() & 0xffff) > 0x7fff)
 527:armwave.c     ****                     noise = -noise;
 528:armwave.c     **** 
 529:armwave.c     ****                 noise += 1.0f;
 530:armwave.c     ****                 xnoise = (rand() & 0xffff) / 6553500.0f;
 531:armwave.c     **** 
 532:armwave.c     ****                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoise) * mod_val) * 
 2530              		.loc 1 532 45 view .LVU613
 2531 0b18 5C8A9FED 		vldr.32	s16, .L168	@ tmp258,
 2532              	@ armwave.c:535:                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_str
 533:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 534:armwave.c     ****                 //printf("%d = %d\n", x + (w * g_armwave_state.wave_stride), MIN(MAX(128 + (v * 127
 535:armwave.c     ****                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_stride) + set_offset
 2533              		.loc 1 535 104 view .LVU614
 2534 0b1c 5CCA9FED 		vldr.32	s24, .L168+4	@ tmp259,
 2535              	@ armwave.c:513:     for(s = 0; s < sets; s++) {
 513:armwave.c     ****         printf("Calculating test set %d\n", s);
 2536              		.loc 1 513 5 view .LVU615
 2537 0b20 0070A0E3 		mov	r7, #0	@ set_offset,
 2538              	@ armwave.c:514:         printf("Calculating test set %d\n", s);
 514:armwave.c     ****         printf("Calculating test set %d\n", s);
 2539              		.loc 1 514 9 view .LVU616
 2540 0b24 84A19FE5 		ldr	r10, .L168+32	@ tmp257,
 2541              	@ armwave.c:513:     for(s = 0; s < sets; s++) {
 513:armwave.c     ****         printf("Calculating test set %d\n", s);
 2542              		.loc 1 513 5 view .LVU617
 2543 0b28 0780A0E1 		mov	r8, r7	@ s, set_offset
 2544              	.LVL167:
 2545              	.L140:
 514:armwave.c     ****         printf("Calculating test set %d\n", s);
 2546              		.loc 1 514 9 is_stmt 1 view .LVU618
 2547 0b2c 0810A0E1 		mov	r1, r8	@, s
 2548 0b30 0A00A0E1 		mov	r0, r10	@, tmp257
 2549 0b34 FEFFFFEB 		bl	printf		@
 2550              	.LVL168:
 516:armwave.c     ****             //mod_val = 0.5f + (((float)w / g_armwave_state.waves) * mod);
 2551              		.loc 1 516 9 view .LVU619
 2552              	@ armwave.c:516:         for(w = 0; w < g_armwave_state.waves; w++) {
 516:armwave.c     ****             //mod_val = 0.5f + (((float)w / g_armwave_state.waves) * mod);
 2553              		.loc 1 516 39 is_stmt 0 view .LVU620
 2554 0b38 382095E5 		ldr	r2, [r5, #56]	@ prephitmp_120, g_armwave_state.waves
 2555              	@ armwave.c:516:         for(w = 0; w < g_armwave_state.waves; w++) {
 516:armwave.c     ****             //mod_val = 0.5f + (((float)w / g_armwave_state.waves) * mod);
 2556              		.loc 1 516 9 view .LVU621
 2557 0b3c 000052E3 		cmp	r2, #0	@ prephitmp_120,
 2558 0b40 450000DA 		ble	.L141		@,
 2559              	@ armwave.c:518:             mod_val = 0.5f + (_1_waves_mod * w);
 518:armwave.c     **** 
 2560              		.loc 1 518 21 view .LVU622
 2561 0b44 53CADFED 		vldr.32	s25, .L168+8	@ tmp200,
 2562              	@ armwave.c:532:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 532:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 2563              		.loc 1 532 33 view .LVU623
 2564 0b48 53BA9FED 		vldr.32	s22, .L168+12	@ tmp253,
 2565              	@ armwave.c:530:                 xnoise = (rand() & 0xffff) / 6553500.0f;
 530:armwave.c     **** 
 2566              		.loc 1 530 24 view .LVU624
 2567 0b4c 53AADFED 		vldr.32	s21, .L168+16	@ tmp254,
 2568 0b50 4C3095E5 		ldr	r3, [r5, #76]	@ prephitmp_124, g_armwave_state.wave_length
 2569              	@ armwave.c:516:         for(w = 0; w < g_armwave_state.waves; w++) {
 516:armwave.c     ****             //mod_val = 0.5f + (((float)w / g_armwave_state.waves) * mod);
 2570              		.loc 1 516 15 view .LVU625
 2571 0b54 0060A0E3 		mov	r6, #0	@ w,
 2572              	.LVL169:
 2573              	.L148:
 518:armwave.c     **** 
 2574              		.loc 1 518 13 is_stmt 1 view .LVU626
 2575              	@ armwave.c:518:             mod_val = 0.5f + (_1_waves_mod * w);
 518:armwave.c     **** 
 2576              		.loc 1 518 21 is_stmt 0 view .LVU627
 2577 0b58 906A07EE 		vmov	s15, r6	@ int	@ w, w
 2578 0b5c 6C9AB0EE 		vmov.f32	s18, s25	@ mod_val, tmp200
 2579              	@ armwave.c:520:             for(x = 0; x < g_armwave_state.wave_length; x++) {
 520:armwave.c     ****                 noise  = ((rand() & 0xffff) * noise_fraction);
 2580              		.loc 1 520 13 view .LVU628
 2581 0b60 000053E3 		cmp	r3, #0	@ prephitmp_124,
 2582              	@ armwave.c:518:             mod_val = 0.5f + (_1_waves_mod * w);
 518:armwave.c     **** 
 2583              		.loc 1 518 21 view .LVU629
 2584 0b64 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp198, w
 2585 0b68 8D9A07EE 		vmla.f32	s18, s15, s26	@ mod_val, tmp198, _1_waves_mod
 2586              	.LVL170:
 520:armwave.c     ****                 noise  = ((rand() & 0xffff) * noise_fraction);
 2587              		.loc 1 520 13 is_stmt 1 view .LVU630
 520:armwave.c     ****                 noise  = ((rand() & 0xffff) * noise_fraction);
 2588              		.loc 1 520 13 is_stmt 0 view .LVU631
 2589 0b6c 370000DA 		ble	.L142		@,
 2590 0b70 C99AB7EE 		vcvt.f64.f32	d9, s18	@ tmp249, mod_val
 2591              	@ armwave.c:535:                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_str
 2592              		.loc 1 535 113 view .LVU632
 2593 0b74 4AAA9FED 		vldr.32	s20, .L168+20	@ tmp229,
 2594 0b78 4A8ADFED 		vldr.32	s17, .L168+24	@ tmp230,
 2595              	@ armwave.c:520:             for(x = 0; x < g_armwave_state.wave_length; x++) {
 520:armwave.c     ****                 noise  = ((rand() & 0xffff) * noise_fraction);
 2596              		.loc 1 520 19 view .LVU633
 2597 0b7c 0040A0E3 		mov	r4, #0	@ x,
 2598              	.LVL171:
 2599              	.L147:
 521:armwave.c     ****                 noise *= noise;
 2600              		.loc 1 521 17 is_stmt 1 view .LVU634
 2601              	@ armwave.c:521:                 noise  = ((rand() & 0xffff) * noise_fraction);
 521:armwave.c     ****                 noise *= noise;
 2602              		.loc 1 521 28 is_stmt 0 view .LVU635
 2603 0b80 FEFFFFEB 		bl	rand		@
 2604              	.LVL172:
 2605              	@ armwave.c:521:                 noise  = ((rand() & 0xffff) * noise_fraction);
 521:armwave.c     ****                 noise *= noise;
 2606              		.loc 1 521 35 view .LVU636
 2607 0b84 7000FFE6 		uxth	r0, r0	@ tmp201,
 2608              	@ armwave.c:521:                 noise  = ((rand() & 0xffff) * noise_fraction);
 521:armwave.c     ****                 noise *= noise;
 2609              		.loc 1 521 45 view .LVU637
 2610 0b88 900A07EE 		vmov	s15, r0	@ int	@ tmp201, tmp201
 2611 0b8c E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp203, tmp201
 2612              	@ armwave.c:521:                 noise  = ((rand() & 0xffff) * noise_fraction);
 521:armwave.c     ****                 noise *= noise;
 2613              		.loc 1 521 24 view .LVU638
 2614 0b90 AB7A67EE 		vmul.f32	s15, s15, s23	@ noise, tmp203, noise_fraction
 2615              	.LVL173:
 522:armwave.c     ****                 noise *= noise;
 2616              		.loc 1 522 17 is_stmt 1 view .LVU639
 2617              	@ armwave.c:522:                 noise *= noise;
 522:armwave.c     ****                 noise *= noise;
 2618              		.loc 1 522 23 is_stmt 0 view .LVU640
 2619 0b94 A77A67EE 		vmul.f32	s15, s15, s15	@ noise, noise, noise
 2620              	.LVL174:
 523:armwave.c     ****                 noise *= noise;
 2621              		.loc 1 523 17 is_stmt 1 view .LVU641
 2622              	@ armwave.c:523:                 noise *= noise;
 523:armwave.c     ****                 noise *= noise;
 2623              		.loc 1 523 23 is_stmt 0 view .LVU642
 2624 0b98 A77A67EE 		vmul.f32	s15, s15, s15	@ noise, noise, noise
 2625              	.LVL175:
 524:armwave.c     **** 
 2626              		.loc 1 524 17 is_stmt 1 view .LVU643
 2627              	@ armwave.c:524:                 noise *= noise;
 524:armwave.c     **** 
 2628              		.loc 1 524 23 is_stmt 0 view .LVU644
 2629 0b9c A7DA67EE 		vmul.f32	s27, s15, s15	@ noise, noise, noise
 2630              	.LVL176:
 526:armwave.c     ****                     noise = -noise;
 2631              		.loc 1 526 17 is_stmt 1 view .LVU645
 2632              	@ armwave.c:526:                 if((rand() & 0xffff) > 0x7fff)
 526:armwave.c     ****                     noise = -noise;
 2633              		.loc 1 526 21 is_stmt 0 view .LVU646
 2634 0ba0 FEFFFFEB 		bl	rand		@
 2635              	.LVL177:
 527:armwave.c     **** 
 2636              		.loc 1 527 21 is_stmt 1 view .LVU647
 2637              	@ armwave.c:526:                 if((rand() & 0xffff) > 0x7fff)
 526:armwave.c     ****                     noise = -noise;
 2638              		.loc 1 526 19 is_stmt 0 view .LVU648
 2639 0ba4 020910E3 		tst	r0, #32768	@,
 2640              	@ armwave.c:527:                     noise = -noise;
 527:armwave.c     **** 
 2641              		.loc 1 527 27 view .LVU649
 2642 0ba8 6DDAF11E 		vnegne.f32	s27, s27	@ noise, noise
 2643              	.LVL178:
 529:armwave.c     ****                 xnoise = (rand() & 0xffff) / 6553500.0f;
 2644              		.loc 1 529 17 is_stmt 1 view .LVU650
 530:armwave.c     **** 
 2645              		.loc 1 530 17 view .LVU651
 2646              	@ armwave.c:530:                 xnoise = (rand() & 0xffff) / 6553500.0f;
 530:armwave.c     **** 
 2647              		.loc 1 530 27 is_stmt 0 view .LVU652
 2648 0bac FEFFFFEB 		bl	rand		@
 2649              	.LVL179:
 532:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 2650              		.loc 1 532 17 is_stmt 1 view .LVU653
 2651              	@ armwave.c:532:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 532:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 2652              		.loc 1 532 45 is_stmt 0 view .LVU654
 2653 0bb0 137A95ED 		vldr.32	s14, [r5, #76]	@ int	@ tmp270, g_armwave_state.wave_length
 2654              	@ armwave.c:532:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 532:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 2655              		.loc 1 532 33 view .LVU655
 2656 0bb4 904A07EE 		vmov	s15, r4	@ int	@ x, x
 2657              	@ armwave.c:532:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 532:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 2658              		.loc 1 532 45 view .LVU656
 2659 0bb8 C77AB8EE 		vcvt.f32.s32	s14, s14	@ tmp206, tmp270
 2660              	@ armwave.c:532:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 532:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 2661              		.loc 1 532 33 view .LVU657
 2662 0bbc E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp210, x
 2663              	@ armwave.c:532:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 532:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 2664              		.loc 1 532 45 view .LVU658
 2665 0bc0 076AC8EE 		vdiv.f32	s13, s16, s14	@ tmp208, tmp258, tmp206
 2666              	@ armwave.c:532:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 532:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 2667              		.loc 1 532 33 view .LVU659
 2668 0bc4 8B7A67EE 		vmul.f32	s15, s15, s22	@ tmp211, tmp210, tmp253
 2669              	@ armwave.c:530:                 xnoise = (rand() & 0xffff) / 6553500.0f;
 530:armwave.c     **** 
 2670              		.loc 1 530 34 view .LVU660
 2671 0bc8 7000FFE6 		uxth	r0, r0	@ tmp214,
 2672              	.LVL180:
 2673              	@ armwave.c:530:                 xnoise = (rand() & 0xffff) / 6553500.0f;
 530:armwave.c     **** 
 2674              		.loc 1 530 44 view .LVU661
 2675 0bcc 100A07EE 		vmov	s14, r0	@ int	@ tmp214, tmp214
 2676 0bd0 C77AB8EE 		vcvt.f32.s32	s14, s14	@ tmp216, tmp214
 2677              	@ armwave.c:530:                 xnoise = (rand() & 0xffff) / 6553500.0f;
 530:armwave.c     **** 
 2678              		.loc 1 530 24 view .LVU662
 2679 0bd4 2A0A87EE 		vdiv.f32	s0, s14, s21	@ xnoise, tmp216, tmp254
 2680              	@ armwave.c:532:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 532:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 2681              		.loc 1 532 77 view .LVU663
 2682 0bd8 A70A06EE 		vmla.f32	s0, s13, s15	@ tmp219, tmp208, tmp211
 2683              	@ armwave.c:532:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 532:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 2684              		.loc 1 532 22 view .LVU664
 2685 0bdc C00AB7EE 		vcvt.f64.f32	d0, s0	@, tmp219
 2686 0be0 FEFFFFEB 		bl	sin		@
 2687              	.LVL181:
 2688              		.loc 1 535 17 is_stmt 1 view .LVU665
 2689              	@ armwave.c:529:                 noise += 1.0f;
 529:armwave.c     ****                 xnoise = (rand() & 0xffff) / 6553500.0f;
 2690              		.loc 1 529 23 is_stmt 0 view .LVU666
 2691 0be4 887A7DEE 		vadd.f32	s15, s27, s16	@ noise, noise, tmp258
 2692              	@ armwave.c:535:                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_str
 2693              		.loc 1 535 104 view .LVU667
 2694 0be8 0010A0E3 		mov	r1, #0	@ iftmp.27_50,
 2695              	@ armwave.c:532:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 532:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 2696              		.loc 1 532 98 view .LVU668
 2697 0bec E77AB7EE 		vcvt.f64.f32	d7, s15	@ tmp225, noise
 2698              	@ armwave.c:532:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 532:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 2699              		.loc 1 532 87 view .LVU669
 2700 0bf0 000B29EE 		vmul.f64	d0, d9, d0	@ tmp222, tmp249,
 2701              	@ armwave.c:532:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 532:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 2702              		.loc 1 532 98 view .LVU670
 2703 0bf4 077B20EE 		vmul.f64	d7, d0, d7	@ tmp226, tmp222, tmp225
 2704              	@ armwave.c:532:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 532:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 2705              		.loc 1 532 19 view .LVU671
 2706 0bf8 C77BB7EE 		vcvt.f32.f64	s14, d7	@ v, tmp226
 2707              	@ armwave.c:535:                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_str
 2708              		.loc 1 535 113 view .LVU672
 2709 0bfc 687AF0EE 		vmov.f32	s15, s17	@ _33, tmp230
 2710 0c00 0A7A47EE 		vmla.f32	s15, s14, s20	@ _33, v, tmp229
 2711 0c04 C07AF5EE 		vcmpe.f32	s15, #0	@ _33
 2712 0c08 10FAF1EE 		vmrs	APSR_nzcv, FPSCR
 2713 0c0c 050000DA 		ble	.L144		@,
 2714              	@ armwave.c:535:                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_str
 2715              		.loc 1 535 104 discriminator 1 view .LVU673
 2716 0c10 CC7AF4EE 		vcmpe.f32	s15, s24	@ _33, tmp259
 2717 0c14 FF10A0E3 		mov	r1, #255	@ iftmp.27_50,
 2718 0c18 10FAF1EE 		vmrs	APSR_nzcv, FPSCR
 2719 0c1c E77AFC4E 		vcvtmi.u32.f32	s15, s15	@ tmp234, _33
 2720 0c20 017ACD4D 		vstrmi.32	s15, [sp, #4]	@ int	@ tmp234, %sfp
 2721 0c24 0410DD45 		ldrbmi	r1, [sp, #4]	@ zero_extendqisi2	@ iftmp.27_50, %sfp
 2722              	.L144:
 2723              	@ armwave.c:535:                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_str
 2724              		.loc 1 535 57 discriminator 12 view .LVU674
 2725 0c28 342095E5 		ldr	r2, [r5, #52]	@ g_armwave_state.wave_stride, g_armwave_state.wave_stride
 2726              	@ armwave.c:535:                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_str
 2727              		.loc 1 535 102 discriminator 12 view .LVU675
 2728 0c2c 183095E5 		ldr	r3, [r5, #24]	@ g_armwave_state.test_wave_buffer, g_armwave_state.test_wave_buffer
 2729 0c30 927622E0 		mla	r2, r2, r6, r7	@ tmp241, g_armwave_state.wave_stride, w, set_offset
 2730 0c34 043083E0 		add	r3, r3, r4	@ tmp240, g_armwave_state.test_wave_buffer, x
 2731              	@ armwave.c:520:             for(x = 0; x < g_armwave_state.wave_length; x++) {
 520:armwave.c     ****                 noise  = ((rand() & 0xffff) * noise_fraction);
 2732              		.loc 1 520 58 discriminator 12 view .LVU676
 2733 0c38 014084E2 		add	r4, r4, #1	@ x, x,
 2734              	.LVL182:
 2735              	@ armwave.c:535:                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_str
 2736              		.loc 1 535 102 discriminator 12 view .LVU677
 2737 0c3c 0310C2E7 		strb	r1, [r2, r3]	@ iftmp.27_50, *_40
 2738              	@ armwave.c:520:             for(x = 0; x < g_armwave_state.wave_length; x++) {
 520:armwave.c     ****                 noise  = ((rand() & 0xffff) * noise_fraction);
 2739              		.loc 1 520 43 discriminator 12 view .LVU678
 2740 0c40 4C3095E5 		ldr	r3, [r5, #76]	@ prephitmp_124, g_armwave_state.wave_length
 2741              	@ armwave.c:520:             for(x = 0; x < g_armwave_state.wave_length; x++) {
 520:armwave.c     ****                 noise  = ((rand() & 0xffff) * noise_fraction);
 2742              		.loc 1 520 13 discriminator 12 view .LVU679
 2743 0c44 040053E1 		cmp	r3, r4	@ prephitmp_124, x
 2744 0c48 CCFFFFCA 		bgt	.L147		@,
 2745 0c4c 382095E5 		ldr	r2, [r5, #56]	@ prephitmp_120, g_armwave_state.waves
 2746              	.LVL183:
 2747              	.L142:
 2748              	@ armwave.c:516:         for(w = 0; w < g_armwave_state.waves; w++) {
 516:armwave.c     ****             //mod_val = 0.5f + (((float)w / g_armwave_state.waves) * mod);
 2749              		.loc 1 516 48 discriminator 2 view .LVU680
 2750 0c50 016086E2 		add	r6, r6, #1	@ w, w,
 2751              	.LVL184:
 2752              	@ armwave.c:516:         for(w = 0; w < g_armwave_state.waves; w++) {
 516:armwave.c     ****             //mod_val = 0.5f + (((float)w / g_armwave_state.waves) * mod);
 2753              		.loc 1 516 9 discriminator 2 view .LVU681
 2754 0c54 020056E1 		cmp	r6, r2	@ w, prephitmp_120
 2755 0c58 BEFFFFBA 		blt	.L148		@,
 2756              	.LVL185:
 2757              	.L141:
 536:armwave.c     ****             }
 537:armwave.c     ****         }
 538:armwave.c     **** 
 539:armwave.c     ****         set_offset += (g_armwave_state.waves * g_armwave_state.wave_stride);
 2758              		.loc 1 539 9 is_stmt 1 discriminator 2 view .LVU682
 2759              	@ armwave.c:539:         set_offset += (g_armwave_state.waves * g_armwave_state.wave_stride);
 2760              		.loc 1 539 46 is_stmt 0 discriminator 2 view .LVU683
 2761 0c5c 343095E5 		ldr	r3, [r5, #52]	@ g_armwave_state.wave_stride, g_armwave_state.wave_stride
 2762              	@ armwave.c:513:     for(s = 0; s < sets; s++) {
 513:armwave.c     ****         printf("Calculating test set %d\n", s);
 2763              		.loc 1 513 27 discriminator 2 view .LVU684
 2764 0c60 018088E2 		add	r8, r8, #1	@ s, s,
 2765              	.LVL186:
 2766              	@ armwave.c:513:     for(s = 0; s < sets; s++) {
 513:armwave.c     ****         printf("Calculating test set %d\n", s);
 2767              		.loc 1 513 5 discriminator 2 view .LVU685
 2768 0c64 080059E1 		cmp	r9, r8	@ sets, s
 2769              	@ armwave.c:539:         set_offset += (g_armwave_state.waves * g_armwave_state.wave_stride);
 2770              		.loc 1 539 20 discriminator 2 view .LVU686
 2771 0c68 937227E0 		mla	r7, r3, r2, r7	@ set_offset, g_armwave_state.wave_stride, prephitmp_120, set_offset
 2772              	.LVL187:
 2773              	@ armwave.c:513:     for(s = 0; s < sets; s++) {
 513:armwave.c     ****         printf("Calculating test set %d\n", s);
 2774              		.loc 1 513 5 discriminator 2 view .LVU687
 2775 0c6c AEFFFF1A 		bne	.L140		@,
 2776              	.LVL188:
 2777              	.L137:
 2778              	@ armwave.c:541: }
 540:armwave.c     ****     }
 541:armwave.c     **** }
 2779              		.loc 1 541 1 view .LVU688
 2780 0c70 08D08DE2 		add	sp, sp, #8	@,,
 2781              		.cfi_remember_state
 2782              		.cfi_def_cfa_offset 80
 2783              		@ sp needed	@
 2784 0c74 0C8BBDEC 		vldm	sp!, {d8-d13}	@,
 2785              		.cfi_restore 90
 2786              		.cfi_restore 91
 2787              		.cfi_restore 88
 2788              		.cfi_restore 89
 2789              		.cfi_restore 86
 2790              		.cfi_restore 87
 2791              		.cfi_restore 84
 2792              		.cfi_restore 85
 2793              		.cfi_restore 82
 2794              		.cfi_restore 83
 2795              		.cfi_restore 80
 2796              		.cfi_restore 81
 2797              		.cfi_def_cfa_offset 32
 2798              	.LVL189:
 2799              		.loc 1 541 1 view .LVU689
 2800 0c78 F087BDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}	@
 2801              	.LVL190:
 2802              	.L167:
 2803              		.cfi_restore_state
 2804              	.LBB42:
 2805              	.LBB39:
 461:armwave.c     ****             g_armwave_state.wave_length * g_armwave_state.waves_max * nsets, nsets);
 2806              		.loc 1 461 9 is_stmt 1 view .LVU690
 2807 0c7c 940901E0 		mul	r1, r4, r9	@, _85, sets
 2808 0c80 0920A0E1 		mov	r2, r9	@, sets
 2809 0c84 28009FE5 		ldr	r0, .L168+36	@,
 2810 0c88 FEFFFFEB 		bl	printf		@
 2811              	.LVL191:
 463:armwave.c     ****     }
 2812              		.loc 1 463 9 view .LVU691
 2813 0c8c 9FFFFFEA 		b	.L139		@
 2814              	.L169:
 2815              		.align	2
 2816              	.L168:
 2817 0c90 0000803F 		.word	1065353216
 2818 0c94 00007F43 		.word	1132396544
 2819 0c98 0000003F 		.word	1056964608
 2820 0c9c C3F5C840 		.word	1086911939
 2821 0ca0 38FFC74A 		.word	1254620984
 2822 0ca4 0000FE42 		.word	1123942400
 2823 0ca8 00000043 		.word	1124073472
 2824 0cac 00000000 		.word	g_armwave_state
 2825 0cb0 88030000 		.word	.LC25
 2826 0cb4 E0020000 		.word	.LC23
 2827              	.LBE39:
 2828              	.LBE42:
 2829              		.cfi_endproc
 2830              	.LFE75:
 2832              		.align	2
 2833              		.global	armwave_cleanup
 2834              		.syntax unified
 2835              		.arm
 2836              		.fpu vfp
 2838              	armwave_cleanup:
 2839              	.LFB76:
 542:armwave.c     **** 
 543:armwave.c     **** /*
 544:armwave.c     ****  * Make a test square waveform.
 545:armwave.c     ****  *
 546:armwave.c     ****  * @param   noise_fraction      typically 1e-6
 547:armwave.c     ****  */
 548:armwave.c     **** #if 0
 549:armwave.c     **** void armwave_test_create_square(float noise_fraction)
 550:armwave.c     **** {
 551:armwave.c     ****     uint8_t v;
 552:armwave.c     ****     float noise, xnoise;
 553:armwave.c     ****     float level = 0.8f, new_level = 0.8f;
 554:armwave.c     ****     int w, x;
 555:armwave.c     **** 
 556:armwave.c     ****     for(w = 0; w < g_armwave_state.waves; w++) {
 557:armwave.c     ****         for(x = 0; x < g_armwave_state.wave_length; x++) {
 558:armwave.c     ****             noise  = ((rand() & 0xffff) * noise_fraction);
 559:armwave.c     ****             noise *= noise;
 560:armwave.c     ****             noise *= noise;
 561:armwave.c     ****             noise *= noise;
 562:armwave.c     **** 
 563:armwave.c     ****             if((rand() & 0xff) > 0x7f)
 564:armwave.c     ****                 noise = -noise;
 565:armwave.c     **** 
 566:armwave.c     ****             //noise += 1.0f;
 567:armwave.c     **** 
 568:armwave.c     ****             if(x > (g_armwave_state.wave_length * 0.75f)) {
 569:armwave.c     ****                 new_level = 0.2f;
 570:armwave.c     ****             } else if(x > (g_armwave_state.wave_length * 0.5f)) {
 571:armwave.c     ****                 new_level = 0.8f;
 572:armwave.c     ****             } else if(x > (g_armwave_state.wave_length * 0.25f)) {
 573:armwave.c     ****                 new_level = 0.2f;
 574:armwave.c     ****             } else {
 575:armwave.c     ****                 new_level = 0.8f;
 576:armwave.c     ****             }
 577:armwave.c     **** 
 578:armwave.c     ****             level = ((level * 3) + new_level) * 0.25f;
 579:armwave.c     **** 
 580:armwave.c     ****             v = (uint8_t)(CLAMP(level + noise, 0.0f, 1.0f) * 255);
 581:armwave.c     ****             g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_stride)] = v;
 582:armwave.c     ****         }
 583:armwave.c     ****     }
 584:armwave.c     **** }
 585:armwave.c     **** #endif
 586:armwave.c     **** 
 587:armwave.c     **** /*
 588:armwave.c     ****  * Free all buffers and set to NULL, ready to be reinitialised or stopped.
 589:armwave.c     ****  */
 590:armwave.c     **** void armwave_cleanup()
 591:armwave.c     **** {
 2840              		.loc 1 591 1 view -0
 2841              		.cfi_startproc
 2842              		@ args = 0, pretend = 0, frame = 0
 2843              		@ frame_needed = 0, uses_anonymous_args = 0
 592:armwave.c     ****     free(g_armwave_state.out_pixbuf);
 2844              		.loc 1 592 5 view .LVU693
 2845              	@ armwave.c:591: {
 591:armwave.c     ****     free(g_armwave_state.out_pixbuf);
 2846              		.loc 1 591 1 is_stmt 0 view .LVU694
 2847 0cb8 10402DE9 		push	{r4, lr}	@
 2848              		.cfi_def_cfa_offset 8
 2849              		.cfi_offset 4, -8
 2850              		.cfi_offset 14, -4
 2851              	@ armwave.c:592:     free(g_armwave_state.out_pixbuf);
 2852              		.loc 1 592 25 view .LVU695
 2853 0cbc 34409FE5 		ldr	r4, .L172	@ tmp114,
 2854              	@ armwave.c:592:     free(g_armwave_state.out_pixbuf);
 2855              		.loc 1 592 5 view .LVU696
 2856 0cc0 680094E5 		ldr	r0, [r4, #104]	@, g_armwave_state.out_pixbuf
 2857 0cc4 FEFFFFEB 		bl	free		@
 2858              	.LVL192:
 593:armwave.c     ****     free(g_armwave_state.ch1_buffer);
 2859              		.loc 1 593 5 is_stmt 1 view .LVU697
 2860 0cc8 040094E5 		ldr	r0, [r4, #4]	@, g_armwave_state.ch1_buffer
 2861 0ccc FEFFFFEB 		bl	free		@
 2862              	.LVL193:
 594:armwave.c     ****     free(g_armwave_state.xcoord_to_xpixel);
 2863              		.loc 1 594 5 view .LVU698
 2864 0cd0 840094E5 		ldr	r0, [r4, #132]	@, g_armwave_state.xcoord_to_xpixel
 2865 0cd4 FEFFFFEB 		bl	free		@
 2866              	.LVL194:
 595:armwave.c     ****     free(g_armwave_state.test_wave_buffer);
 2867              		.loc 1 595 5 view .LVU699
 2868 0cd8 180094E5 		ldr	r0, [r4, #24]	@, g_armwave_state.test_wave_buffer
 2869 0cdc FEFFFFEB 		bl	free		@
 2870              	.LVL195:
 596:armwave.c     **** 
 597:armwave.c     ****     g_armwave_state.out_pixbuf = NULL;
 2871              		.loc 1 597 5 view .LVU700
 2872              	@ armwave.c:597:     g_armwave_state.out_pixbuf = NULL;
 2873              		.loc 1 597 32 is_stmt 0 view .LVU701
 2874 0ce0 0030A0E3 		mov	r3, #0	@ tmp123,
 2875 0ce4 683084E5 		str	r3, [r4, #104]	@ tmp123, g_armwave_state.out_pixbuf
 598:armwave.c     ****     g_armwave_state.ch1_buffer = NULL;
 2876              		.loc 1 598 5 is_stmt 1 view .LVU702
 2877              	@ armwave.c:598:     g_armwave_state.ch1_buffer = NULL;
 2878              		.loc 1 598 32 is_stmt 0 view .LVU703
 2879 0ce8 043084E5 		str	r3, [r4, #4]	@ tmp123, g_armwave_state.ch1_buffer
 599:armwave.c     ****     g_armwave_state.xcoord_to_xpixel = NULL;
 2880              		.loc 1 599 5 is_stmt 1 view .LVU704
 2881              	@ armwave.c:599:     g_armwave_state.xcoord_to_xpixel = NULL;
 2882              		.loc 1 599 38 is_stmt 0 view .LVU705
 2883 0cec 843084E5 		str	r3, [r4, #132]	@ tmp123, g_armwave_state.xcoord_to_xpixel
 600:armwave.c     ****     g_armwave_state.test_wave_buffer = NULL;
 2884              		.loc 1 600 5 is_stmt 1 view .LVU706
 2885              	@ armwave.c:600:     g_armwave_state.test_wave_buffer = NULL;
 2886              		.loc 1 600 38 is_stmt 0 view .LVU707
 2887 0cf0 183084E5 		str	r3, [r4, #24]	@ tmp123, g_armwave_state.test_wave_buffer
 2888              	@ armwave.c:601: }
 601:armwave.c     **** }
 2889              		.loc 1 601 1 view .LVU708
 2890 0cf4 1080BDE8 		pop	{r4, pc}	@
 2891              	.L173:
 2892              		.align	2
 2893              	.L172:
 2894 0cf8 00000000 		.word	g_armwave_state
 2895              		.cfi_endproc
 2896              	.LFE76:
 2898              		.comm	gamma_table,256,4
 2899              		.comm	g_armwave_state,136,4
 2900              		.section	.rodata
 2901              		.align	2
 2902              		.set	.LANCHOR0,. + 0
 2905              	__PRETTY_FUNCTION__.17125:
 2906 0000 61726D77 		.ascii	"armwave_setup_render\000"
 2906      6176655F 
 2906      73657475 
 2906      705F7265 
 2906      6E646572 
 2907 0015 000000   		.space	3
 2910              	__PRETTY_FUNCTION__.17129:
 2911 0018 61726D77 		.ascii	"armwave_set_wave_pointer\000"
 2911      6176655F 
 2911      7365745F 
 2911      77617665 
 2911      5F706F69 
 2912 0031 000000   		.space	3
 2915              	__PRETTY_FUNCTION__.17136:
 2916 0034 61726D77 		.ascii	"armwave_set_wave_pointer_u32\000"
 2916      6176655F 
 2916      7365745F 
 2916      77617665 
 2916      5F706F69 
 2917              		.section	.rodata.str1.4,"aMS",%progbits,1
 2918              		.align	2
 2919              	.LC0:
 2920 0000 76302E30 		.ascii	"v0.0.1\000"
 2920      2E3100
 2921 0007 00       		.space	1
 2922              	.LC1:
 2923 0008 61726D77 		.ascii	"armwave version: %s\012\000"
 2923      61766520 
 2923      76657273 
 2923      696F6E3A 
 2923      2025730A 
 2924 001d 000000   		.space	3
 2925              	.LC2:
 2926 0020 77623D30 		.ascii	"wb=0x%08x b=0x%08x ch1=0x%08x off=%d slice_y=%d hei"
 2926      78253038 
 2926      7820623D 
 2926      30782530 
 2926      38782063 
 2927 0053 6768743D 		.ascii	"ght=%d scale=%d bitdepth_height=%d\012\000"
 2927      25642073 
 2927      63616C65 
 2927      3D256420 
 2927      62697464 
 2928 0077 00       		.space	1
 2929              	.LC3:
 2930 0078 6F757470 		.ascii	"output buffer: 0x%08x\012\000"
 2930      75742062 
 2930      75666665 
 2930      723A2030 
 2930      78253038 
 2931 008f 00       		.space	1
 2932              	.LC4:
 2933 0090 6D656D73 		.ascii	"memset %d bytes, npix %d, chbuff sz %d, base32_ptr "
 2933      65742025 
 2933      64206279 
 2933      7465732C 
 2933      206E7069 
 2934 00c3 30782530 		.ascii	"0x%08x, stack ~0x%08x\012\000"
 2934      38782C20 
 2934      73746163 
 2934      6B207E30 
 2934      78253038 
 2935 00da 0000     		.space	2
 2936              	.LC5:
 2937 00dc 69746572 		.ascii	"iter...\000"
 2937      2E2E2E00 
 2938              	.LC6:
 2939 00e4 25642C00 		.ascii	"%d,\000"
 2940              	.LC7:
 2941 00e8 2E2E2E64 		.ascii	"...done paint %d pixels...\012\000"
 2941      6F6E6520 
 2941      7061696E 
 2941      74202564 
 2941      20706978 
 2942              	.LC8:
 2943 0104 61726D77 		.ascii	"armwave_generate: slice %d (y=%d, h=%d, xpos=%d)\012"
 2943      6176655F 
 2943      67656E65 
 2943      72617465 
 2943      3A20736C 
 2944 0135 00       		.ascii	"\000"
 2945 0136 0000     		.space	2
 2946              	.LC9:
 2947 0138 733D2564 		.ascii	"s=%d e=%d w=%d ws=%d tw=%d th=%d rf=0x%08x\012\000"
 2947      20653D25 
 2947      6420773D 
 2947      25642077 
 2947      733D2564 
 2948              	.LC10:
 2949 0164 61726D77 		.ascii	"armwave.c\000"
 2949      6176652E 
 2949      6300
 2950 016e 0000     		.space	2
 2951              	.LC11:
 2952 0170 73746172 		.ascii	"start_point < end_point\000"
 2952      745F706F 
 2952      696E7420 
 2952      3C20656E 
 2952      645F706F 
 2953              	.LC12:
 2954 0188 63685F62 		.ascii	"ch_buff_size=%d, cmp_x_bitdepth_scale=%d (0x%08x), "
 2954      7566665F 
 2954      73697A65 
 2954      3D25642C 
 2954      20636D70 
 2955 01bb 74617267 		.ascii	"targ_width=%d, wave_length=%d, scaler=%d\012\000"
 2955      5F776964 
 2955      74683D25 
 2955      642C2077 
 2955      6176655F 
 2956 01e5 000000   		.space	3
 2957              	.LC13:
 2958 01e8 6D616C6C 		.ascii	"malloc failure allocating %d bytes (g_armwave_state"
 2958      6F632066 
 2958      61696C75 
 2958      72652061 
 2958      6C6C6F63 
 2959 021b 2E636831 		.ascii	".ch1_buffer)\012\000"
 2959      5F627566 
 2959      66657229 
 2959      0A00
 2960 0229 000000   		.space	3
 2961              	.LC14:
 2962 022c 50747273 		.ascii	"Ptrs: 0x%08x 0x%08x 0x%08x 0x%08x \012\000"
 2962      3A203078 
 2962      25303878 
 2962      20307825 
 2962      30387820 
 2963              	.LC15:
 2964 0250 77617665 		.ascii	"wave_buffer != NULL\000"
 2964      5F627566 
 2964      66657220 
 2964      213D204E 
 2964      554C4C00 
 2965              	.LC16:
 2966 0264 61726D77 		.ascii	"armwave_set_wave_pointer_as_testbuf: error, nsets e"
 2966      6176655F 
 2966      7365745F 
 2966      77617665 
 2966      5F706F69 
 2967 0297 78636565 		.ascii	"xceeded\000"
 2967      64656400 
 2968 029f 00       		.space	1
 2969              	.LC17:
 2970 02a0 77617665 		.ascii	"wave_buffer_ptr != 0\000"
 2970      5F627566 
 2970      6665725F 
 2970      70747220 
 2970      213D2030 
 2971 02b5 000000   		.space	3
 2972              	.LC18:
 2973 02b8 776200   		.ascii	"wb\000"
 2974 02bb 00       		.space	1
 2975              	.LC19:
 2976 02bc 50330A00 		.ascii	"P3\012\000"
 2977              	.LC20:
 2978 02c0 25642025 		.ascii	"%d %d\012\000"
 2978      640A00
 2979 02c7 00       		.space	1
 2980              	.LC21:
 2981 02c8 3235350A 		.ascii	"255\012\000"
 2981      00
 2982 02cd 000000   		.space	3
 2983              	.LC22:
 2984 02d0 25336420 		.ascii	"%3d %3d %3d\012\000"
 2984      25336420 
 2984      2533640A 
 2984      00
 2985 02dd 000000   		.space	3
 2986              	.LC23:
 2987 02e0 61726D77 		.ascii	"armwave_test_buffer_alloc: failed to allocate test "
 2987      6176655F 
 2987      74657374 
 2987      5F627566 
 2987      6665725F 
 2988 0313 77617665 		.ascii	"wave buffer (%d bytes, %d sets)\012\000"
 2988      20627566 
 2988      66657220 
 2988      28256420 
 2988      62797465 
 2989              	.LC24:
 2990 0334 61726D77 		.ascii	"armwave_fill_pixbuf_into_pybuffer: PyObject_GetBuff"
 2990      6176655F 
 2990      66696C6C 
 2990      5F706978 
 2990      6275665F 
 2991 0367 65722829 		.ascii	"er() failed, returning PyFalse\000"
 2991      20666169 
 2991      6C65642C 
 2991      20726574 
 2991      75726E69 
 2992 0386 0000     		.space	2
 2993              	.LC25:
 2994 0388 43616C63 		.ascii	"Calculating test set %d\012\000"
 2994      756C6174 
 2994      696E6720 
 2994      74657374 
 2994      20736574 
 2995              		.text
 2996              	.Letext0:
 2997              		.file 3 "/usr/lib/gcc/arm-linux-gnueabihf/8/include/stddef.h"
 2998              		.file 4 "/usr/include/arm-linux-gnueabihf/bits/types.h"
 2999              		.file 5 "/usr/include/arm-linux-gnueabihf/bits/types/struct_FILE.h"
 3000              		.file 6 "/usr/include/arm-linux-gnueabihf/bits/types/FILE.h"
 3001              		.file 7 "/usr/include/stdio.h"
 3002              		.file 8 "/usr/include/arm-linux-gnueabihf/bits/sys_errlist.h"
 3003              		.file 9 "/usr/include/errno.h"
 3004              		.file 10 "/usr/include/arm-linux-gnueabihf/bits/stdint-intn.h"
 3005              		.file 11 "/usr/include/unistd.h"
 3006              		.file 12 "/usr/include/arm-linux-gnueabihf/bits/getopt_core.h"
 3007              		.file 13 "/usr/include/arm-linux-gnueabihf/bits/stdint-uintn.h"
 3008              		.file 14 "/usr/local/include/python3.8/pyport.h"
 3009              		.file 15 "/usr/include/math.h"
 3010              		.file 16 "/usr/include/arm-linux-gnueabihf/sys/time.h"
 3011              		.file 17 "/usr/include/time.h"
 3012              		.file 18 "/usr/local/include/python3.8/pymem.h"
 3013              		.file 19 "/usr/local/include/python3.8/cpython/object.h"
 3014              		.file 20 "/usr/local/include/python3.8/methodobject.h"
 3015              		.file 21 "/usr/local/include/python3.8/descrobject.h"
 3016              		.file 22 "/usr/local/include/python3.8/pyhash.h"
 3017              		.file 23 "/usr/local/include/python3.8/pydebug.h"
 3018              		.file 24 "/usr/local/include/python3.8/bytearrayobject.h"
 3019              		.file 25 "/usr/local/include/python3.8/bytesobject.h"
 3020              		.file 26 "/usr/local/include/python3.8/unicodeobject.h"
 3021              		.file 27 "/usr/local/include/python3.8/cpython/unicodeobject.h"
 3022              		.file 28 "/usr/local/include/python3.8/longintrepr.h"
 3023              		.file 29 "/usr/local/include/python3.8/longobject.h"
 3024              		.file 30 "/usr/local/include/python3.8/boolobject.h"
 3025              		.file 31 "/usr/local/include/python3.8/floatobject.h"
 3026              		.file 32 "/usr/local/include/python3.8/complexobject.h"
 3027              		.file 33 "/usr/local/include/python3.8/rangeobject.h"
 3028              		.file 34 "/usr/local/include/python3.8/memoryobject.h"
 3029              		.file 35 "/usr/local/include/python3.8/tupleobject.h"
 3030              		.file 36 "/usr/local/include/python3.8/listobject.h"
 3031              		.file 37 "/usr/local/include/python3.8/dictobject.h"
 3032              		.file 38 "/usr/local/include/python3.8/odictobject.h"
 3033              		.file 39 "/usr/local/include/python3.8/enumobject.h"
 3034              		.file 40 "/usr/local/include/python3.8/setobject.h"
 3035              		.file 41 "/usr/local/include/python3.8/moduleobject.h"
 3036              		.file 42 "/usr/local/include/python3.8/funcobject.h"
 3037              		.file 43 "/usr/local/include/python3.8/classobject.h"
 3038              		.file 44 "/usr/local/include/python3.8/fileobject.h"
 3039              		.file 45 "/usr/local/include/python3.8/cpython/fileobject.h"
 3040              		.file 46 "/usr/local/include/python3.8/pycapsule.h"
 3041              		.file 47 "/usr/local/include/python3.8/traceback.h"
 3042              		.file 48 "/usr/local/include/python3.8/sliceobject.h"
 3043              		.file 49 "/usr/local/include/python3.8/cellobject.h"
 3044              		.file 50 "/usr/local/include/python3.8/iterobject.h"
 3045              		.file 51 "/usr/local/include/python3.8/pystate.h"
 3046              		.file 52 "/usr/local/include/python3.8/cpython/pystate.h"
 3047              		.file 53 "/usr/local/include/python3.8/genobject.h"
 3048              		.file 54 "/usr/local/include/python3.8/weakrefobject.h"
 3049              		.file 55 "/usr/local/include/python3.8/structseq.h"
 3050              		.file 56 "/usr/local/include/python3.8/namespaceobject.h"
 3051              		.file 57 "/usr/local/include/python3.8/picklebufobject.h"
 3052              		.file 58 "/usr/local/include/python3.8/codecs.h"
 3053              		.file 59 "/usr/local/include/python3.8/pyerrors.h"
 3054              		.file 60 "/usr/local/include/python3.8/context.h"
 3055              		.file 61 "/usr/local/include/python3.8/modsupport.h"
 3056              		.file 62 "/usr/local/include/python3.8/code.h"
 3057              		.file 63 "/usr/local/include/python3.8/pythonrun.h"
 3058              		.file 64 "/usr/local/include/python3.8/ceval.h"
 3059              		.file 65 "/usr/local/include/python3.8/import.h"
 3060              		.file 66 "/usr/local/include/python3.8/bltinmodule.h"
 3061              		.file 67 "/usr/local/include/python3.8/pyctype.h"
 3062              		.file 68 "/usr/include/malloc.h"
 3063              		.file 69 "armwave.h"
 3064              		.file 70 "/usr/include/stdlib.h"
 3065              		.file 71 "/usr/local/include/python3.8/cpython/abstract.h"
 3066              		.file 72 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h"
 3067              		.file 73 "<built-in>"
 3068              		.file 74 "/usr/include/assert.h"
