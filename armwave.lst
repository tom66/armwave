   1              		.arch armv6
   2              		.eabi_attribute 28, 1	@ Tag_ABI_VFP_args
   3              		.eabi_attribute 20, 1	@ Tag_ABI_FP_denormal
   4              		.eabi_attribute 21, 1	@ Tag_ABI_FP_exceptions
   5              		.eabi_attribute 23, 3	@ Tag_ABI_FP_number_model
   6              		.eabi_attribute 24, 1	@ Tag_ABI_align8_needed
   7              		.eabi_attribute 25, 1	@ Tag_ABI_align8_preserved
   8              		.eabi_attribute 26, 2	@ Tag_ABI_enum_size
   9              		.eabi_attribute 30, 2	@ Tag_ABI_optimization_goals
  10              		.eabi_attribute 34, 1	@ Tag_CPU_unaligned_access
  11              		.eabi_attribute 18, 4	@ Tag_ABI_PCS_wchar_t
  12              		.file	"armwave.c"
  13              	@ GNU C17 (Raspbian 8.3.0-6+rpi1) version 8.3.0 (arm-linux-gnueabihf)
  14              	@	compiled by GNU C version 8.3.0, GMP version 6.1.2, MPFR version 4.0.2, MPC version 1.1.0, isl ve
  15              	
  16              	@ GGC heuristics: --param ggc-min-expand=81 --param ggc-min-heapsize=95638
  17              	@ options passed:  -I /usr/local/include/python3.8 -imultilib .
  18              	@ -imultiarch arm-linux-gnueabihf armwave.c -mfloat-abi=hard -mfpu=vfp
  19              	@ -mtls-dialect=gnu -marm -march=armv6+fp -auxbase-strip armwave.s -g -O3
  20              	@ -fverbose-asm -fwrapv
  21              	@ options enabled:  -faggressive-loop-optimizations -falign-jumps
  22              	@ -falign-labels -falign-loops -fauto-inc-dec -fbranch-count-reg
  23              	@ -fcaller-saves -fchkp-check-incomplete-type -fchkp-check-read
  24              	@ -fchkp-check-write -fchkp-instrument-calls -fchkp-narrow-bounds
  25              	@ -fchkp-optimize -fchkp-store-bounds -fchkp-use-static-bounds
  26              	@ -fchkp-use-static-const-bounds -fchkp-use-wrappers -fcode-hoisting
  27              	@ -fcombine-stack-adjustments -fcommon -fcompare-elim -fcprop-registers
  28              	@ -fcrossjumping -fcse-follow-jumps -fdefer-pop
  29              	@ -fdelete-null-pointer-checks -fdevirtualize -fdevirtualize-speculatively
  30              	@ -fdwarf2-cfi-asm -fearly-inlining -feliminate-unused-debug-types
  31              	@ -fexpensive-optimizations -fforward-propagate -ffp-int-builtin-inexact
  32              	@ -ffunction-cse -fgcse -fgcse-after-reload -fgcse-lm -fgnu-runtime
  33              	@ -fgnu-unique -fguess-branch-probability -fhoist-adjacent-loads -fident
  34              	@ -fif-conversion -fif-conversion2 -findirect-inlining -finline
  35              	@ -finline-atomics -finline-functions -finline-functions-called-once
  36              	@ -finline-small-functions -fipa-bit-cp -fipa-cp -fipa-cp-clone -fipa-icf
  37              	@ -fipa-icf-functions -fipa-icf-variables -fipa-profile -fipa-pure-const
  38              	@ -fipa-ra -fipa-reference -fipa-sra -fipa-vrp -fira-hoist-pressure
  39              	@ -fira-share-save-slots -fira-share-spill-slots
  40              	@ -fisolate-erroneous-paths-dereference -fivopts -fkeep-static-consts
  41              	@ -fleading-underscore -flifetime-dse -floop-interchange
  42              	@ -floop-unroll-and-jam -flra-remat -flto-odr-type-merging -fmath-errno
  43              	@ -fmerge-constants -fmerge-debug-strings -fmove-loop-invariants
  44              	@ -fomit-frame-pointer -foptimize-sibling-calls -foptimize-strlen
  45              	@ -fpartial-inlining -fpeel-loops -fpeephole -fpeephole2 -fplt
  46              	@ -fpredictive-commoning -fprefetch-loop-arrays -freg-struct-return
  47              	@ -freorder-blocks -freorder-functions -frerun-cse-after-loop
  48              	@ -fsched-critical-path-heuristic -fsched-dep-count-heuristic
  49              	@ -fsched-group-heuristic -fsched-interblock -fsched-last-insn-heuristic
  50              	@ -fsched-pressure -fsched-rank-heuristic -fsched-spec
  51              	@ -fsched-spec-insn-heuristic -fsched-stalled-insns-dep -fschedule-insns
  52              	@ -fschedule-insns2 -fsection-anchors -fsemantic-interposition
  53              	@ -fshow-column -fshrink-wrap -fshrink-wrap-separate -fsigned-zeros
  54              	@ -fsplit-ivs-in-unroller -fsplit-loops -fsplit-paths -fsplit-wide-types
  55              	@ -fssa-backprop -fssa-phiopt -fstdarg-opt -fstore-merging
  56              	@ -fstrict-aliasing -fstrict-volatile-bitfields -fsync-libcalls
  57              	@ -fthread-jumps -ftoplevel-reorder -ftrapping-math -ftree-bit-ccp
  58              	@ -ftree-builtin-call-dce -ftree-ccp -ftree-ch -ftree-coalesce-vars
  59              	@ -ftree-copy-prop -ftree-cselim -ftree-dce -ftree-dominator-opts
  60              	@ -ftree-dse -ftree-forwprop -ftree-fre -ftree-loop-distribute-patterns
  61              	@ -ftree-loop-distribution -ftree-loop-if-convert -ftree-loop-im
  62              	@ -ftree-loop-ivcanon -ftree-loop-optimize -ftree-loop-vectorize
  63              	@ -ftree-parallelize-loops= -ftree-partial-pre -ftree-phiprop -ftree-pre
  64              	@ -ftree-pta -ftree-reassoc -ftree-scev-cprop -ftree-sink
  65              	@ -ftree-slp-vectorize -ftree-slsr -ftree-sra -ftree-switch-conversion
  66              	@ -ftree-tail-merge -ftree-ter -ftree-vrp -funit-at-a-time -funswitch-loops
  67              	@ -fvar-tracking -fvar-tracking-assignments -fverbose-asm -fwrapv
  68              	@ -fzero-initialized-in-bss -marm -mbe32 -mglibc -mlittle-endian
  69              	@ -mpic-data-is-text-relative -msched-prolog -munaligned-access
  70              	@ -mvectorize-with-neon-quad
  71              	
  72              		.text
  73              	.Ltext0:
  74              		.cfi_sections	.debug_frame
  75              		.align	2
  76              		.global	test_create_gamma
  77              		.arch armv6
  78              		.syntax unified
  79              		.arm
  80              		.fpu vfp
  82              	test_create_gamma:
  83              	.LFB57:
  84              		.file 1 "armwave.c"
   1:armwave.c     **** /*
   2:armwave.c     ****  * This file is part of YAOS and is licenced under the MIT Licence.
   3:armwave.c     ****  *
   4:armwave.c     ****  * armwave: an ARM-optimised waveform rendering engine for the Raspberry Pi 3.  
   5:armwave.c     ****  * This library attempts to use NEON tricks and architectural features of the Pi's
   6:armwave.c     ****  * processor to render waveforms damn quickly.
   7:armwave.c     ****  */
   8:armwave.c     **** 
   9:armwave.c     **** #define _GNU_SOURCE
  10:armwave.c     **** 
  11:armwave.c     **** #include <Python.h>
  12:armwave.c     **** 
  13:armwave.c     **** #include <assert.h>
  14:armwave.c     **** #include <ctype.h>
  15:armwave.c     **** #include <stdio.h>
  16:armwave.c     **** #include <stdint.h>
  17:armwave.c     **** #include <stdlib.h>
  18:armwave.c     **** #include <stdbool.h>
  19:armwave.c     **** #include <malloc.h>
  20:armwave.c     **** #include <string.h>
  21:armwave.c     **** #include <math.h>
  22:armwave.c     **** 
  23:armwave.c     **** #include "armwave.h"
  24:armwave.c     **** 
  25:armwave.c     **** #define ARMWAVE_VER  "v0.0.1"
  26:armwave.c     **** 
  27:armwave.c     **** struct armwave_state_t g_armwave_state;
  28:armwave.c     **** 
  29:armwave.c     **** uint8_t gamma_table[256];
  30:armwave.c     **** 
  31:armwave.c     **** /*
  32:armwave.c     ****  * Create a gamma table.
  33:armwave.c     ****  */
  34:armwave.c     **** void test_create_gamma()
  35:armwave.c     **** {
  85              		.loc 1 35 1 view -0
  86              		.cfi_startproc
  87              		@ args = 0, pretend = 0, frame = 0
  88              		@ frame_needed = 0, uses_anonymous_args = 0
  36:armwave.c     ****     int i;
  89              		.loc 1 36 5 view .LVU1
  37:armwave.c     ****     float gamma = 0.90f;
  90              		.loc 1 37 5 view .LVU2
  91              	.LVL0:
  38:armwave.c     **** 
  39:armwave.c     ****     for(i = 0; i < 256; i++) {
  92              		.loc 1 39 5 view .LVU3
  93              	@ armwave.c:35: {
  35:armwave.c     ****     int i;
  94              		.loc 1 35 1 is_stmt 0 view .LVU4
  95 0000 70402DE9 		push	{r4, r5, r6, lr}	@
  96              		.cfi_def_cfa_offset 16
  97              		.cfi_offset 4, -16
  98              		.cfi_offset 5, -12
  99              		.cfi_offset 6, -8
 100              		.cfi_offset 14, -4
 101 0004 068B2DED 		vpush.64	{d8, d9, d10}	@
 102              		.cfi_def_cfa_offset 40
 103              		.cfi_offset 80, -40
 104              		.cfi_offset 81, -36
 105              		.cfi_offset 82, -32
 106              		.cfi_offset 83, -28
 107              		.cfi_offset 84, -24
 108              		.cfi_offset 85, -20
 109 0008 64409FE5 		ldr	r4, .L6+20	@ ivtmp.32,
 110              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 111              		.loc 1 40 32 view .LVU5
 112 000c 17AA9FED 		vldr.32	s20, .L6+16	@ tmp128,
 113              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 114              		.loc 1 40 26 view .LVU6
 115 0010 129B9FED 		vldr.64	d9, .L6	@ tmp135,
 116              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 117              		.loc 1 40 49 view .LVU7
 118 0014 138B9FED 		vldr.64	d8, .L6+8	@ tmp131,
 119 0018 015084E2 		add	r5, r4, #1	@ _25, ivtmp.32,
 120 001c 016C84E2 		add	r6, r4, #256	@ _26, ivtmp.32,
 121 0020 015065E2 		rsb	r5, r5, #1	@ tmp134, _25,
 122              	.LVL1:
 123              	.L2:
 124              		.loc 1 40 9 is_stmt 1 discriminator 3 view .LVU8
 125              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 126              		.loc 1 40 32 is_stmt 0 discriminator 3 view .LVU9
 127 0024 043085E0 		add	r3, r5, r4	@ tmp125, tmp134, ivtmp.32
 128              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 129              		.loc 1 40 26 discriminator 3 view .LVU10
 130 0028 491BB0EE 		vmov.f64	d1, d9	@, tmp135
 131              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 132              		.loc 1 40 32 discriminator 3 view .LVU11
 133 002c 903A07EE 		vmov	s15, r3	@ int	@ tmp125, tmp125
 134 0030 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp126, tmp125
 135 0034 8A0A87EE 		vdiv.f32	s0, s15, s20	@ tmp127, tmp126, tmp128
 136              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 137              		.loc 1 40 26 discriminator 3 view .LVU12
 138 0038 C00AB7EE 		vcvt.f64.f32	d0, s0	@, tmp127
 139 003c FEFFFFEB 		bl	pow		@
 140              	.LVL2:
 141              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 142              		.loc 1 40 49 discriminator 3 view .LVU13
 143 0040 080B20EE 		vmul.f64	d0, d0, d8	@ tmp130,, tmp131
 144              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 145              		.loc 1 40 24 discriminator 3 view .LVU14
 146 0044 C07BFCEE 		vcvt.u32.f64	s15, d0	@ tmp132, tmp130
 147 0048 903A17EE 		vmov	r3, s15	@ int	@ tmp132, tmp132
 148 004c 0130E4E5 		strb	r3, [r4, #1]!	@ tmp132, MEM[base: _24, offset: 0B]
 149              	.LVL3:
 150              	@ armwave.c:39:     for(i = 0; i < 256; i++) {
  39:armwave.c     ****         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 151              		.loc 1 39 5 discriminator 3 view .LVU15
 152 0050 060054E1 		cmp	r4, r6	@ ivtmp.32, _26
 153 0054 F2FFFF1A 		bne	.L2		@,
 154              	@ armwave.c:42: }
  41:armwave.c     ****     }
  42:armwave.c     **** }
 155              		.loc 1 42 1 view .LVU16
 156 0058 068BBDEC 		vldm	sp!, {d8-d10}	@,
 157              		.cfi_restore 84
 158              		.cfi_restore 85
 159              		.cfi_restore 82
 160              		.cfi_restore 83
 161              		.cfi_restore 80
 162              		.cfi_restore 81
 163              		.cfi_def_cfa_offset 16
 164 005c 7080BDE8 		pop	{r4, r5, r6, pc}	@
 165              	.LVL4:
 166              	.L7:
 167              		.loc 1 42 1 view .LVU17
 168              		.align	3
 169              	.L6:
 170 0060 000000C0 		.word	-1073741824
 171 0064 CCCCEC3F 		.word	1072483532
 172 0068 00000000 		.word	0
 173 006c 00E06F40 		.word	1081073664
 174 0070 00007F43 		.word	1132396544
 175 0074 FFFFFFFF 		.word	gamma_table-1
 176              		.cfi_endproc
 177              	.LFE57:
 179              		.align	2
 180              		.global	armwave_init
 181              		.syntax unified
 182              		.arm
 183              		.fpu vfp
 185              	armwave_init:
 186              	.LFB58:
  43:armwave.c     **** 
  44:armwave.c     **** /*
  45:armwave.c     ****  * Initialise things.  STUB, mostly.
  46:armwave.c     ****  */
  47:armwave.c     **** void armwave_init()
  48:armwave.c     **** {
 187              		.loc 1 48 1 is_stmt 1 view -0
 188              		.cfi_startproc
 189              		@ args = 0, pretend = 0, frame = 0
 190              		@ frame_needed = 0, uses_anonymous_args = 0
 191              		@ link register save eliminated.
  49:armwave.c     ****     g_armwave_state.flags = 0;
 192              		.loc 1 49 5 view .LVU19
 193              	@ armwave.c:49:     g_armwave_state.flags = 0;
 194              		.loc 1 49 27 is_stmt 0 view .LVU20
 195 0078 10309FE5 		ldr	r3, .L9	@ tmp110,
 196 007c 0020A0E3 		mov	r2, #0	@ tmp111,
 197              	@ armwave.c:51:     printf("armwave version: %s\n", ARMWAVE_VER);
  50:armwave.c     **** 
  51:armwave.c     ****     printf("armwave version: %s\n", ARMWAVE_VER);
 198              		.loc 1 51 5 view .LVU21
 199 0080 0C109FE5 		ldr	r1, .L9+4	@,
 200 0084 0C009FE5 		ldr	r0, .L9+8	@,
 201              	@ armwave.c:49:     g_armwave_state.flags = 0;
  49:armwave.c     ****     g_armwave_state.flags = 0;
 202              		.loc 1 49 27 view .LVU22
 203 0088 002083E5 		str	r2, [r3]	@ tmp111, g_armwave_state.flags
 204              		.loc 1 51 5 is_stmt 1 view .LVU23
 205 008c FEFFFFEA 		b	printf		@
 206              	.LVL5:
 207              	.L10:
 208              		.align	2
 209              	.L9:
 210 0090 00000000 		.word	g_armwave_state
 211 0094 00000000 		.word	.LC0
 212 0098 08000000 		.word	.LC1
 213              		.cfi_endproc
 214              	.LFE58:
 216              		.align	2
 217              		.global	render_nonaa_to_buffer_1ch_slice
 218              		.syntax unified
 219              		.arm
 220              		.fpu vfp
 222              	render_nonaa_to_buffer_1ch_slice:
 223              	.LVL6:
 224              	.LFB59:
  52:armwave.c     **** }
  53:armwave.c     **** 
  54:armwave.c     **** /*
  55:armwave.c     ****  * 1ch renderer, renders up to slice-height buffer with X-coord of each waveaccess
  56:armwave.c     ****  * pre-computed.
  57:armwave.c     ****  *
  58:armwave.c     ****  * @param    slice_y        Slice to render at
  59:armwave.c     ****  * @param    height         Number of wave points to render (adjust for performance, 
  60:armwave.c     ****  *                          accounting for cache behaviour, etc.)
  61:armwave.c     ****  */
  62:armwave.c     **** void render_nonaa_to_buffer_1ch_slice(uint32_t slice_y, uint32_t height)
  63:armwave.c     **** {
 225              		.loc 1 63 1 view -0
 226              		.cfi_startproc
 227              		@ args = 0, pretend = 0, frame = 16
 228              		@ frame_needed = 0, uses_anonymous_args = 0
  64:armwave.c     ****     int yy, ys, w, scale_value;
 229              		.loc 1 64 5 view .LVU25
  65:armwave.c     ****     uint32_t value, word;
 230              		.loc 1 65 5 view .LVU26
  66:armwave.c     ****     uint8_t *wave_base;
 231              		.loc 1 66 5 view .LVU27
  67:armwave.c     ****     uint8_t *write_buffer_base;
 232              		.loc 1 67 5 view .LVU28
  68:armwave.c     ****     uint8_t *write_buffer;
 233              		.loc 1 68 5 view .LVU29
  69:armwave.c     **** 
  70:armwave.c     ****     //write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.bitdepth_height);
  71:armwave.c     ****     write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.cmp_x_bitdepth_scal
 234              		.loc 1 71 5 view .LVU30
 235              	@ armwave.c:63: {
  63:armwave.c     ****     int yy, ys, w, scale_value;
 236              		.loc 1 63 1 is_stmt 0 view .LVU31
 237 009c F04F2DE9 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}	@
 238              		.cfi_def_cfa_offset 36
 239              		.cfi_offset 4, -36
 240              		.cfi_offset 5, -32
 241              		.cfi_offset 6, -28
 242              		.cfi_offset 7, -24
 243              		.cfi_offset 8, -20
 244              		.cfi_offset 9, -16
 245              		.cfi_offset 10, -12
 246              		.cfi_offset 11, -8
 247              		.cfi_offset 14, -4
 248 00a0 14D04DE2 		sub	sp, sp, #20	@,,
 249              		.cfi_def_cfa_offset 56
 250              	@ armwave.c:71:     write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.cmp
 251              		.loc 1 71 40 view .LVU32
 252 00a4 8C419FE5 		ldr	r4, .L27	@ tmp285,
 253              	@ armwave.c:63: {
  63:armwave.c     ****     int yy, ys, w, scale_value;
 254              		.loc 1 63 1 view .LVU33
 255 00a8 01C0A0E1 		mov	ip, r1	@ height, height
 256 00ac 04108DE5 		str	r1, [sp, #4]	@ height, %sfp
 257              	@ armwave.c:71:     write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.cmp
 258              		.loc 1 71 63 view .LVU34
 259 00b0 243094E5 		ldr	r3, [r4, #36]	@ g_armwave_state.cmp_x_bitdepth_scale, g_armwave_state.cmp_x_bitdepth_scale
 260              	@ armwave.c:74:     for(w = 0; w < g_armwave_state.waves; w++) {
  72:armwave.c     **** 
  73:armwave.c     ****     // roll through each waveform
  74:armwave.c     ****     for(w = 0; w < g_armwave_state.waves; w++) {
 261              		.loc 1 74 5 view .LVU35
 262 00b4 381094E5 		ldr	r1, [r4, #56]	@ g_armwave_state.waves, g_armwave_state.waves
 263              	.LVL7:
 264              	@ armwave.c:71:     write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.cmp
  71:armwave.c     **** 
 265              		.loc 1 71 40 view .LVU36
 266 00b8 042094E5 		ldr	r2, [r4, #4]	@ _1, g_armwave_state.ch1_buffer
 267              	@ armwave.c:74:     for(w = 0; w < g_armwave_state.waves; w++) {
 268              		.loc 1 74 5 view .LVU37
 269 00bc 000051E3 		cmp	r1, #0	@ g_armwave_state.waves,
 270              	@ armwave.c:71:     write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.cmp
  71:armwave.c     **** 
 271              		.loc 1 71 63 view .LVU38
 272 00c0 93000BE0 		mul	fp, r3, r0	@ _3, g_armwave_state.cmp_x_bitdepth_scale, slice_y
 273              	.LVL8:
 274              		.loc 1 74 5 is_stmt 1 view .LVU39
 275              		.loc 1 74 5 is_stmt 0 view .LVU40
 276 00c4 590000DA 		ble	.L11		@,
 277 00c8 00005CE3 		cmp	ip, #0	@ height,
 278 00cc 5700000A 		beq	.L11		@,
 279 00d0 043040E2 		sub	r3, r0, #4	@ tmp286, slice_y,
 280 00d4 0C308DE5 		str	r3, [sp, #12]	@ tmp286, %sfp
 281              	@ armwave.c:74:     for(w = 0; w < g_armwave_state.waves; w++) {
 282              		.loc 1 74 11 view .LVU41
 283 00d8 0030A0E3 		mov	r3, #0	@ w,
 284 00dc 08308DE5 		str	r3, [sp, #8]	@ w, %sfp
 285              	.LVL9:
 286              	.L18:
  75:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 287              		.loc 1 75 9 is_stmt 1 view .LVU42
  76:armwave.c     **** 
  77:armwave.c     ****         // roll through y and render the slice into the out buffer
  78:armwave.c     ****         // buffer is rendered rotated by 90 degrees
  79:armwave.c     ****         for(yy = 0; yy < height; yy += 4) {
 288              		.loc 1 79 9 view .LVU43
 289              	@ armwave.c:75:         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wa
  75:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 290              		.loc 1 75 64 is_stmt 0 view .LVU44
 291 00e0 343094E5 		ldr	r3, [r4, #52]	@ g_armwave_state.wave_stride, g_armwave_state.wave_stride
 292 00e4 08C09DE5 		ldr	ip, [sp, #8]	@ w, %sfp
 293 00e8 0CE09DE5 		ldr	lr, [sp, #12]	@ tmp286, %sfp
 294 00ec 140094E5 		ldr	r0, [r4, #20]	@ g_armwave_state.wave_buffer, g_armwave_state.wave_buffer
 295 00f0 93EC23E0 		mla	r3, r3, ip, lr	@ tmp208, g_armwave_state.wave_stride, w, tmp286
 296              	@ armwave.c:79:         for(yy = 0; yy < height; yy += 4) {
 297              		.loc 1 79 16 view .LVU45
 298 00f4 0010A0E3 		mov	r1, #0	@ yy,
 299 00f8 03A080E0 		add	r10, r0, r3	@ ivtmp.39, g_armwave_state.wave_buffer, tmp208
 300              	.LVL10:
 301              	.L17:
  80:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 302              		.loc 1 80 13 is_stmt 1 view .LVU46
  81:armwave.c     **** 
  82:armwave.c     ****             for(ys = 0; ys < 4; ys++) {
  83:armwave.c     ****                 scale_value = word & 0xff;
  84:armwave.c     ****                 
  85:armwave.c     ****                 // prevents saturating behaviour; we lose two ADC counts.
  86:armwave.c     ****                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  87:armwave.c     ****                     continue;
  88:armwave.c     **** 
  89:armwave.c     ****                 // Keep math in integer where possible using the compound X multiplier and a shift 
  90:armwave.c     ****                 // of X to 1/256 but this should not be an ultimate issue.
  91:armwave.c     ****                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cmp_x_bitdepth_sca
 303              		.loc 1 91 17 view .LVU47
  92:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 304              		.loc 1 92 17 view .LVU48
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 305              		.loc 1 91 17 view .LVU49
 306              		.loc 1 92 17 view .LVU50
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 307              		.loc 1 91 17 view .LVU51
 308              		.loc 1 92 17 view .LVU52
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 309              		.loc 1 91 17 view .LVU53
 310              		.loc 1 92 17 view .LVU54
 311              	@ armwave.c:80:             word = *(uint32_t*)(wave_base + yy);
  80:armwave.c     **** 
 312              		.loc 1 80 18 is_stmt 0 view .LVU55
 313 00fc 0430BAE5 		ldr	r3, [r10, #4]!	@ word, MEM[base: _163, offset: 0B]
 314              	.LVL11:
  82:armwave.c     ****                 scale_value = word & 0xff;
 315              		.loc 1 82 13 is_stmt 1 view .LVU56
  83:armwave.c     ****                 
 316              		.loc 1 83 17 view .LVU57
  86:armwave.c     ****                     continue;
 317              		.loc 1 86 17 view .LVU58
 318              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 319              		.loc 1 91 64 is_stmt 0 view .LVU59
 320 0100 019081E2 		add	r9, r1, #1	@ tmp236, yy,
 321              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 322              		.loc 1 86 20 view .LVU60
 323 0104 FF6013E2 		ands	r6, r3, #255	@ scale_value, word,
 324 0108 0150A003 		moveq	r5, #1	@ tmp211,
 325 010c 0050A013 		movne	r5, #0	@ tmp211,
 326              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 327              		.loc 1 86 19 view .LVU61
 328 0110 FF0056E3 		cmp	r6, #255	@ scale_value,
 329 0114 01508503 		orreq	r5, r5, #1	@,, tmp216, tmp211
 330 0118 000055E3 		cmp	r5, #0	@ tmp216,
 331              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 332              		.loc 1 91 64 view .LVU62
 333 011c 028081E2 		add	r8, r1, #2	@ tmp255, yy,
 334 0120 037081E2 		add	r7, r1, #3	@ tmp272, yy,
 335              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
 336              		.loc 1 92 47 view .LVU63
 337 0124 0BE086E0 		add	lr, r6, fp	@ tmp221, scale_value, _3
 338              	@ armwave.c:93:                 word >>= 8;
  93:armwave.c     ****                 word >>= 8;
 339              		.loc 1 93 22 view .LVU64
 340 0128 23C4A0E1 		lsr	ip, r3, #8	@ word, word,
 341 012c 2308A0E1 		lsr	r0, r3, #16	@ word, word,
 342              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 343              		.loc 1 86 19 view .LVU65
 344 0130 3400001A 		bne	.L20		@,
 345              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 346              		.loc 1 91 64 view .LVU66
 347 0134 246094E5 		ldr	r6, [r4, #36]	@ g_armwave_state.cmp_x_bitdepth_scale, g_armwave_state.cmp_x_bitdepth_scale
 348              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 349              		.loc 1 86 20 view .LVU67
 350 0138 FFC01CE2 		ands	ip, ip, #255	@ scale_value, word,
 351              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 352              		.loc 1 92 47 view .LVU68
 353 013c 0B508CE0 		add	r5, ip, fp	@ tmp240, scale_value, _3
 354              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 355              		.loc 1 91 64 view .LVU69
 356 0140 960106E0 		mul	r6, r6, r1	@ tmp218, g_armwave_state.cmp_x_bitdepth_scale, yy
 357 0144 00608DE5 		str	r6, [sp]	@ tmp218, %sfp
 358              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 359              		.loc 1 86 20 view .LVU70
 360 0148 0160A003 		moveq	r6, #1	@ tmp229,
 361 014c 0060A013 		movne	r6, #0	@ tmp229,
 362              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 363              		.loc 1 86 19 view .LVU71
 364 0150 FF005CE3 		cmp	ip, #255	@ scale_value,
 365 0154 06C0A011 		movne	ip, r6	@, tmp234, tmp229
 366 0158 01C08603 		orreq	ip, r6, #1	@,, tmp234, tmp229
 367              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 368              		.loc 1 92 47 view .LVU72
 369 015c 00609DE5 		ldr	r6, [sp]	@ tmp218, %sfp
 370              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 371              		.loc 1 86 19 view .LVU73
 372 0160 00005CE3 		cmp	ip, #0	@ tmp234,
 373              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 374              		.loc 1 92 47 view .LVU74
 375 0164 26E48EE0 		add	lr, lr, r6, lsr #8	@ tmp222, tmp221, tmp218,
 376 0168 0EC0D2E7 		ldrb	ip, [r2, lr]	@ zero_extendqisi2	@ *_69, *_69
 377 016c 01C08CE2 		add	ip, ip, #1	@ tmp225, *_69,
 378 0170 0EC0C2E7 		strb	ip, [r2, lr]	@ tmp225, *_69
 379              	.LVL12:
 380              		.loc 1 93 17 is_stmt 1 view .LVU75
  83:armwave.c     ****                 
 381              		.loc 1 83 17 view .LVU76
  86:armwave.c     ****                     continue;
 382              		.loc 1 86 17 view .LVU77
 383              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 384              		.loc 1 86 19 is_stmt 0 view .LVU78
 385 0174 2300001A 		bne	.L20		@,
 386              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 387              		.loc 1 91 64 view .LVU79
 388 0178 24E094E5 		ldr	lr, [r4, #36]	@ g_armwave_state.cmp_x_bitdepth_scale, g_armwave_state.cmp_x_bitdepth_scale
 389              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 390              		.loc 1 86 20 view .LVU80
 391 017c FF0010E2 		ands	r0, r0, #255	@ scale_value, word,
 392              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 393              		.loc 1 92 47 view .LVU81
 394 0180 0BC080E0 		add	ip, r0, fp	@ tmp259, scale_value, _3
 395              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 396              		.loc 1 91 64 view .LVU82
 397 0184 9E0909E0 		mul	r9, lr, r9	@ tmp237, g_armwave_state.cmp_x_bitdepth_scale, tmp236
 398              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 399              		.loc 1 86 20 view .LVU83
 400 0188 01E0A003 		moveq	lr, #1	@ tmp248,
 401 018c 00E0A013 		movne	lr, #0	@ tmp248,
 402              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 403              		.loc 1 92 47 view .LVU84
 404 0190 295485E0 		add	r5, r5, r9, lsr #8	@ tmp241, tmp240, tmp237,
 405              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 406              		.loc 1 86 19 view .LVU85
 407 0194 FF0050E3 		cmp	r0, #255	@ scale_value,
 408 0198 0E00A011 		movne	r0, lr	@, tmp253, tmp248
 409 019c 01008E03 		orreq	r0, lr, #1	@,, tmp253, tmp248
 410 01a0 000050E3 		cmp	r0, #0	@ tmp253,
 411              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 412              		.loc 1 92 47 view .LVU86
 413 01a4 0500D2E7 		ldrb	r0, [r2, r5]	@ zero_extendqisi2	@ *_97, *_97
 414 01a8 010080E2 		add	r0, r0, #1	@ tmp244, *_97,
 415 01ac 0500C2E7 		strb	r0, [r2, r5]	@ tmp244, *_97
 416              		.loc 1 93 17 is_stmt 1 view .LVU87
 417              	.LVL13:
  83:armwave.c     ****                 
 418              		.loc 1 83 17 view .LVU88
  86:armwave.c     ****                     continue;
 419              		.loc 1 86 17 view .LVU89
 420              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 421              		.loc 1 86 19 is_stmt 0 view .LVU90
 422 01b0 1400001A 		bne	.L20		@,
 423              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 424              		.loc 1 91 64 view .LVU91
 425 01b4 24E094E5 		ldr	lr, [r4, #36]	@ g_armwave_state.cmp_x_bitdepth_scale, g_armwave_state.cmp_x_bitdepth_scale
 426              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 427              		.loc 1 86 20 view .LVU92
 428 01b8 233CB0E1 		lsrs	r3, r3, #24	@ word, word,
 429              	.LVL14:
 430              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 431              		.loc 1 92 47 view .LVU93
 432 01bc 03008BE0 		add	r0, fp, r3	@ tmp277, _3, word
 433              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 434              		.loc 1 91 64 view .LVU94
 435 01c0 9E0808E0 		mul	r8, lr, r8	@ tmp256, g_armwave_state.cmp_x_bitdepth_scale, tmp255
 436              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 437              		.loc 1 86 20 view .LVU95
 438 01c4 01E0A003 		moveq	lr, #1	@ tmp266,
 439 01c8 00E0A013 		movne	lr, #0	@ tmp266,
 440              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 441              		.loc 1 92 47 view .LVU96
 442 01cc 28848CE0 		add	r8, ip, r8, lsr #8	@ tmp260, tmp259, tmp256,
 443              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 444              		.loc 1 86 19 view .LVU97
 445 01d0 FF0053E3 		cmp	r3, #255	@ word,
 446 01d4 0E30A011 		movne	r3, lr	@, tmp271, tmp266
 447 01d8 01308E03 		orreq	r3, lr, #1	@,, tmp271, tmp266
 448 01dc 000053E3 		cmp	r3, #0	@ tmp271,
 449              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 450              		.loc 1 92 47 view .LVU98
 451 01e0 0830D2E7 		ldrb	r3, [r2, r8]	@ zero_extendqisi2	@ *_125, *_125
 452 01e4 013083E2 		add	r3, r3, #1	@ tmp263, *_125,
 453 01e8 0830C2E7 		strb	r3, [r2, r8]	@ tmp263, *_125
 454              		.loc 1 93 17 is_stmt 1 view .LVU99
 455              	.LVL15:
  83:armwave.c     ****                 
 456              		.loc 1 83 17 view .LVU100
  86:armwave.c     ****                     continue;
 457              		.loc 1 86 17 view .LVU101
 458              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 459              		.loc 1 86 19 is_stmt 0 view .LVU102
 460 01ec 0500001A 		bne	.L20		@,
 461              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 462              		.loc 1 91 64 view .LVU103
 463 01f0 243094E5 		ldr	r3, [r4, #36]	@ g_armwave_state.cmp_x_bitdepth_scale, g_armwave_state.cmp_x_bitdepth_scale
 464 01f4 930703E0 		mul	r3, r3, r7	@ tmp274, g_armwave_state.cmp_x_bitdepth_scale, tmp272
 465              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 466              		.loc 1 92 47 view .LVU104
 467 01f8 233480E0 		add	r3, r0, r3, lsr #8	@ tmp278, tmp277, tmp274,
 468 01fc 0300D2E7 		ldrb	r0, [r2, r3]	@ zero_extendqisi2	@ *_153, *_153
 469 0200 010080E2 		add	r0, r0, #1	@ tmp281, *_153,
 470 0204 0300C2E7 		strb	r0, [r2, r3]	@ tmp281, *_153
 471              		.loc 1 93 17 is_stmt 1 view .LVU105
 472              	.LVL16:
 473              	.L20:
 474              	@ armwave.c:79:         for(yy = 0; yy < height; yy += 4) {
  79:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 475              		.loc 1 79 9 is_stmt 0 view .LVU106
 476 0208 04309DE5 		ldr	r3, [sp, #4]	@ height, %sfp
 477              	@ armwave.c:79:         for(yy = 0; yy < height; yy += 4) {
  79:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 478              		.loc 1 79 37 view .LVU107
 479 020c 041081E2 		add	r1, r1, #4	@ yy, yy,
 480              	.LVL17:
 481              	@ armwave.c:79:         for(yy = 0; yy < height; yy += 4) {
  79:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 482              		.loc 1 79 9 view .LVU108
 483 0210 010053E1 		cmp	r3, r1	@ height, yy
 484 0214 B8FFFF8A 		bhi	.L17		@,
 485              	@ armwave.c:74:     for(w = 0; w < g_armwave_state.waves; w++) {
  74:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 486              		.loc 1 74 44 view .LVU109
 487 0218 08109DE5 		ldr	r1, [sp, #8]	@ w, %sfp
 488              	.LVL18:
 489              	@ armwave.c:74:     for(w = 0; w < g_armwave_state.waves; w++) {
  74:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 490              		.loc 1 74 5 view .LVU110
 491 021c 383094E5 		ldr	r3, [r4, #56]	@ g_armwave_state.waves, g_armwave_state.waves
 492              	@ armwave.c:74:     for(w = 0; w < g_armwave_state.waves; w++) {
  74:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 493              		.loc 1 74 44 view .LVU111
 494 0220 011081E2 		add	r1, r1, #1	@ w, w,
 495              	@ armwave.c:74:     for(w = 0; w < g_armwave_state.waves; w++) {
  74:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 496              		.loc 1 74 5 view .LVU112
 497 0224 030051E1 		cmp	r1, r3	@ w, g_armwave_state.waves
 498              	@ armwave.c:74:     for(w = 0; w < g_armwave_state.waves; w++) {
  74:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 499              		.loc 1 74 44 view .LVU113
 500 0228 08108DE5 		str	r1, [sp, #8]	@ w, %sfp
 501              	.LVL19:
 502              	@ armwave.c:74:     for(w = 0; w < g_armwave_state.waves; w++) {
  74:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 503              		.loc 1 74 5 view .LVU114
 504 022c ABFFFFBA 		blt	.L18		@,
 505              	.LVL20:
 506              	.L11:
 507              	@ armwave.c:97: }
  94:armwave.c     ****             }
  95:armwave.c     ****         }
  96:armwave.c     ****     }
  97:armwave.c     **** }
 508              		.loc 1 97 1 view .LVU115
 509 0230 14D08DE2 		add	sp, sp, #20	@,,
 510              		.cfi_def_cfa_offset 36
 511              		@ sp needed	@
 512 0234 F08FBDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}	@
 513              	.LVL21:
 514              	.L28:
 515              		.loc 1 97 1 view .LVU116
 516              		.align	2
 517              	.L27:
 518 0238 00000000 		.word	g_armwave_state
 519              		.cfi_endproc
 520              	.LFE59:
 522              		.align	2
 523              		.global	armwave_fill_pixbuf_scaled
 524              		.syntax unified
 525              		.arm
 526              		.fpu vfp
 528              	armwave_fill_pixbuf_scaled:
 529              	.LVL22:
 530              	.LFB60:
  98:armwave.c     **** 
  99:armwave.c     **** #if 0
 100:armwave.c     **** /*
 101:armwave.c     ****  * Fill a pixbuf with a 256-height waveform.
 102:armwave.c     ****  */
 103:armwave.c     **** void armwave_fill_pixbuf_256(uint32_t *out_buffer)
 104:armwave.c     **** {
 105:armwave.c     ****     uint32_t xx, yy, word, wave_word;
 106:armwave.c     ****     int rr, gg, bb, n, nsub, npix, i;
 107:armwave.c     ****     uint8_t r, g, b, value;
 108:armwave.c     ****     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 109:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 110:armwave.c     ****     uint32_t offset;
 111:armwave.c     **** 
 112:armwave.c     ****     assert(out_buffer != NULL);
 113:armwave.c     **** 
 114:armwave.c     ****     // Buffer is sent non-rotated: we use GDK/GL to assemble and rotate it
 115:armwave.c     **** 
 116:armwave.c     ****     npix = g_armwave_state.target_width * 256;
 117:armwave.c     **** 
 118:armwave.c     ****     for(n = 0; n < npix; n += 4) {
 119:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 120:armwave.c     ****         // each byte.  We can afford to do this because most pixels will be blank for
 121:armwave.c     ****         // most normal waveforms.
 122:armwave.c     ****         wave_word = *base_32ptr++;
 123:armwave.c     **** 
 124:armwave.c     ****         if(COND_UNLIKELY(wave_word != 0)) {
 125:armwave.c     ****             for(i = 0; i < 4; i++) {
 126:armwave.c     ****                 value = wave_word & 0xff;
 127:armwave.c     ****                 wave_word >>= 8;
 128:armwave.c     **** 
 129:armwave.c     ****                 if(value != 0) {
 130:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 131:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 132:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 133:armwave.c     **** 
 134:armwave.c     ****                     r = MIN(rr, 255);
 135:armwave.c     ****                     g = MIN(gg, 255);
 136:armwave.c     ****                     b = MIN(bb, 255);
 137:armwave.c     **** 
 138:armwave.c     ****                     // Ensure 100% alpha channel, if it is used
 139:armwave.c     ****                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 140:armwave.c     **** 
 141:armwave.c     ****                     // Is there a better way?
 142:armwave.c     ****                     nsub = n + i;
 143:armwave.c     ****                     xx = nsub & 0xff;
 144:armwave.c     ****                     yy = nsub >> 8;
 145:armwave.c     ****                     offset = yy + (xx * g_armwave_state.target_width);
 146:armwave.c     ****                     *(out_buffer_base + offset) = word;
 147:armwave.c     ****                 }
 148:armwave.c     ****             }
 149:armwave.c     ****         } 
 150:armwave.c     ****     }
 151:armwave.c     **** }
 152:armwave.c     **** #endif
 153:armwave.c     **** 
 154:armwave.c     **** /*
 155:armwave.c     ****  * Fill a pixbuf with a multiple of a 256-height waveform.
 156:armwave.c     ****  * Rows are repeated as necessary.
 157:armwave.c     ****  */
 158:armwave.c     **** void armwave_fill_pixbuf_scaled(uint32_t *out_buffer)
 159:armwave.c     **** {
 531              		.loc 1 159 1 is_stmt 1 view -0
 532              		.cfi_startproc
 533              		@ args = 0, pretend = 0, frame = 8
 534              		@ frame_needed = 0, uses_anonymous_args = 0
 160:armwave.c     ****     uint32_t xx, yy, ye, y, word, wave_word;
 535              		.loc 1 160 5 view .LVU118
 161:armwave.c     ****     // uint32_t ysub;
 162:armwave.c     ****     int rr, gg, bb, n, nsub, npix, w;
 536              		.loc 1 162 5 view .LVU119
 163:armwave.c     ****     uint8_t r, g, b, value; 
 537              		.loc 1 163 5 view .LVU120
 164:armwave.c     ****     // uint8_t row;
 165:armwave.c     ****     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 538              		.loc 1 165 5 view .LVU121
 539              	@ armwave.c:159: {
 159:armwave.c     ****     uint32_t xx, yy, ye, y, word, wave_word;
 540              		.loc 1 159 1 is_stmt 0 view .LVU122
 541 023c F04F2DE9 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}	@
 542              		.cfi_def_cfa_offset 36
 543              		.cfi_offset 4, -36
 544              		.cfi_offset 5, -32
 545              		.cfi_offset 6, -28
 546              		.cfi_offset 7, -24
 547              		.cfi_offset 8, -20
 548              		.cfi_offset 9, -16
 549              		.cfi_offset 10, -12
 550              		.cfi_offset 11, -8
 551              		.cfi_offset 14, -4
 552              	@ armwave.c:169:     assert(out_buffer != NULL);
 166:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 167:armwave.c     ****     uint32_t offset;
 168:armwave.c     **** 
 169:armwave.c     ****     assert(out_buffer != NULL);
 553              		.loc 1 169 5 view .LVU123
 554 0240 000050E3 		cmp	r0, #0	@ out_buffer
 555              	@ armwave.c:165:     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 165:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 556              		.loc 1 165 15 view .LVU124
 557 0244 44619FE5 		ldr	r6, .L51	@ tmp203,
 558              	@ armwave.c:159: {
 159:armwave.c     ****     uint32_t xx, yy, ye, y, word, wave_word;
 559              		.loc 1 159 1 view .LVU125
 560 0248 0CD04DE2 		sub	sp, sp, #12	@,,
 561              		.cfi_def_cfa_offset 48
 562              	@ armwave.c:165:     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 165:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 563              		.loc 1 165 15 view .LVU126
 564 024c 04E096E5 		ldr	lr, [r6, #4]	@ base_32ptr, g_armwave_state.ch1_buffer
 565              	.LVL23:
 166:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 566              		.loc 1 166 5 is_stmt 1 view .LVU127
 167:armwave.c     **** 
 567              		.loc 1 167 5 view .LVU128
 568              		.loc 1 169 5 view .LVU129
 569 0250 4900000A 		beq	.L48		@,
 170:armwave.c     **** 
 171:armwave.c     ****     npix = g_armwave_state.target_width * 256; 
 570              		.loc 1 171 5 view .LVU130
 571              	@ armwave.c:171:     npix = g_armwave_state.target_width * 256; 
 572              		.loc 1 171 10 is_stmt 0 view .LVU131
 573 0254 588096E5 		ldr	r8, [r6, #88]	@ g_armwave_state.target_width, g_armwave_state.target_width
 574 0258 0884A0E1 		lsl	r8, r8, #8	@ npix, g_armwave_state.target_width,
 575              	.LVL24:
 172:armwave.c     ****     //vscale = g_armwave_state.target_height >> 8;
 173:armwave.c     **** 
 174:armwave.c     ****     for(n = 0; n < npix; n += 4) {
 576              		.loc 1 174 5 is_stmt 1 view .LVU132
 577              		.loc 1 174 5 is_stmt 0 view .LVU133
 578 025c 000058E3 		cmp	r8, #0	@ npix,
 579 0260 0C0000DA 		ble	.L29		@,
 580              	@ armwave.c:187:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 175:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 176:armwave.c     ****         // each byte.  We can afford to do this because most pixels will be blank for
 177:armwave.c     ****         // most normal waveforms.
 178:armwave.c     ****         wave_word = *base_32ptr++;
 179:armwave.c     **** 
 180:armwave.c     ****         if(COND_UNLIKELY(wave_word != 0)) {
 181:armwave.c     ****             for(w = 0; w < 4; w++) {
 182:armwave.c     ****                 value = wave_word & 0xff;
 183:armwave.c     ****                 wave_word >>= 8;
 184:armwave.c     **** 
 185:armwave.c     ****                 if(value != 0) {
 186:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 187:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 581              		.loc 1 187 52 view .LVU134
 582 0264 FE36D6E1 		ldrsh	r3, [r6, #110]	@ _10, g_armwave_state.ch1_color.g
 583              	@ armwave.c:186:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 186:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 584              		.loc 1 186 52 view .LVU135
 585 0268 FCB6D6E1 		ldrsh	fp, [r6, #108]	@ _6, g_armwave_state.ch1_color.r
 586              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 188:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 189:armwave.c     **** 
 190:armwave.c     ****                     r = MIN(rr, 255);
 191:armwave.c     ****                     g = MIN(gg, 255);
 192:armwave.c     ****                     b = MIN(bb, 255);
 193:armwave.c     **** 
 194:armwave.c     ****                     // Ensure 100% alpha channel, if it is used
 195:armwave.c     ****                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 196:armwave.c     **** 
 197:armwave.c     ****                     // Do line scaling as necessary.
 198:armwave.c     ****                     /*
 199:armwave.c     ****                     nsub = n + w;
 200:armwave.c     ****                     yy = (nsub & 0xff) * g_armwave_state.vscale;
 201:armwave.c     ****                     xx = (nsub >> 8);
 202:armwave.c     **** 
 203:armwave.c     ****                     for(row = 0; row < g_armwave_state.vscale; row++) {
 204:armwave.c     ****                         offset = (xx + ((yy + row) * g_armwave_state.target_width)); 
 205:armwave.c     ****                         *(out_buffer_base + offset) = word;
 206:armwave.c     ****                     }
 207:armwave.c     ****                     */
 208:armwave.c     **** 
 209:armwave.c     ****                     nsub = n + w;
 210:armwave.c     ****                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 587              		.loc 1 210 57 view .LVU136
 588 026c 0A6AD6ED 		vldr.32	s13, [r6, #40]	@ _27, g_armwave_state.vscale_frac
 589              	@ armwave.c:187:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 187:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 590              		.loc 1 187 52 view .LVU137
 591 0270 00308DE5 		str	r3, [sp]	@ _10, %sfp
 592              	@ armwave.c:188:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 188:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 593              		.loc 1 188 52 view .LVU138
 594 0274 F037D6E1 		ldrsh	r3, [r6, #112]	@ _13, g_armwave_state.ch1_color.b
 595              	@ armwave.c:174:     for(n = 0; n < npix; n += 4) {
 174:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 596              		.loc 1 174 11 view .LVU139
 597 0278 0010A0E3 		mov	r1, #0	@ n,
 598              	@ armwave.c:188:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 188:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 599              		.loc 1 188 52 view .LVU140
 600 027c 04308DE5 		str	r3, [sp, #4]	@ _13, %sfp
 601              	.LVL25:
 602              	.L36:
 178:armwave.c     **** 
 603              		.loc 1 178 9 is_stmt 1 view .LVU141
 604              	@ armwave.c:178:         wave_word = *base_32ptr++;
 178:armwave.c     **** 
 605              		.loc 1 178 19 is_stmt 0 view .LVU142
 606 0280 04309EE4 		ldr	r3, [lr], #4	@ wave_word, MEM[base: base_32ptr_54, offset: 4294967292B]
 607              	.LVL26:
 180:armwave.c     ****             for(w = 0; w < 4; w++) {
 608              		.loc 1 180 9 is_stmt 1 view .LVU143
 609              	@ armwave.c:180:         if(COND_UNLIKELY(wave_word != 0)) {
 180:armwave.c     ****             for(w = 0; w < 4; w++) {
 610              		.loc 1 180 11 is_stmt 0 view .LVU144
 611 0284 000053E3 		cmp	r3, #0	@ wave_word,
 612 0288 0400001A 		bne	.L49		@,
 613              	.L32:
 614              	@ armwave.c:174:     for(n = 0; n < npix; n += 4) {
 174:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 615              		.loc 1 174 28 view .LVU145
 616 028c 041081E2 		add	r1, r1, #4	@ n, n,
 617              	.LVL27:
 618              	@ armwave.c:174:     for(n = 0; n < npix; n += 4) {
 174:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 619              		.loc 1 174 5 view .LVU146
 620 0290 010058E1 		cmp	r8, r1	@ npix, n
 621 0294 F9FFFFCA 		bgt	.L36		@,
 622              	.LVL28:
 623              	.L29:
 624              	@ armwave.c:222: }
 211:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 212:armwave.c     ****                     xx = (nsub >> 8);
 213:armwave.c     **** 
 214:armwave.c     ****                     for(y = yy; y < ye; y++) {
 215:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 216:armwave.c     ****                         *(out_buffer_base + offset) = word;
 217:armwave.c     ****                     }
 218:armwave.c     ****                 }
 219:armwave.c     ****             }
 220:armwave.c     ****         }
 221:armwave.c     ****     }
 222:armwave.c     **** }
 625              		.loc 1 222 1 view .LVU147
 626 0298 0CD08DE2 		add	sp, sp, #12	@,,
 627              		.cfi_remember_state
 628              		.cfi_def_cfa_offset 36
 629              		@ sp needed	@
 630 029c F08FBDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}	@
 631              	.LVL29:
 632              	.L49:
 633              		.cfi_restore_state
 634              	@ armwave.c:185:                 if(value != 0) {
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 635              		.loc 1 185 19 view .LVU148
 636 02a0 FF2013E2 		ands	r2, r3, #255	@ _7, wave_word,
 637              	@ armwave.c:181:             for(w = 0; w < 4; w++) {
 181:armwave.c     ****                 value = wave_word & 0xff;
 638              		.loc 1 181 19 view .LVU149
 639 02a4 0070A0E3 		mov	r7, #0	@ w,
 640              	.LVL30:
 182:armwave.c     ****                 wave_word >>= 8;
 641              		.loc 1 182 17 is_stmt 1 view .LVU150
 183:armwave.c     **** 
 642              		.loc 1 183 17 view .LVU151
 643              	@ armwave.c:183:                 wave_word >>= 8;
 183:armwave.c     **** 
 644              		.loc 1 183 27 is_stmt 0 view .LVU152
 645 02a8 2334A0E1 		lsr	r3, r3, #8	@ wave_word, wave_word,
 646              	.LVL31:
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 647              		.loc 1 185 17 is_stmt 1 view .LVU153
 648              	@ armwave.c:185:                 if(value != 0) {
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 649              		.loc 1 185 19 is_stmt 0 view .LVU154
 650 02ac 0500001A 		bne	.L50		@,
 651              	.L33:
 652              	@ armwave.c:181:             for(w = 0; w < 4; w++) {
 181:armwave.c     ****                 value = wave_word & 0xff;
 653              		.loc 1 181 32 view .LVU155
 654 02b0 017087E2 		add	r7, r7, #1	@ w, w,
 655              	.LVL32:
 656              	@ armwave.c:181:             for(w = 0; w < 4; w++) {
 181:armwave.c     ****                 value = wave_word & 0xff;
 657              		.loc 1 181 13 view .LVU156
 658 02b4 040057E3 		cmp	r7, #4	@ w,
 659 02b8 F3FFFF0A 		beq	.L32		@,
 182:armwave.c     ****                 wave_word >>= 8;
 660              		.loc 1 182 17 is_stmt 1 view .LVU157
 661              	.LVL33:
 183:armwave.c     **** 
 662              		.loc 1 183 17 view .LVU158
 663              	@ armwave.c:185:                 if(value != 0) {
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 664              		.loc 1 185 19 is_stmt 0 view .LVU159
 665 02bc FF2013E2 		ands	r2, r3, #255	@ _7, wave_word,
 666              	@ armwave.c:183:                 wave_word >>= 8;
 183:armwave.c     **** 
 667              		.loc 1 183 27 view .LVU160
 668 02c0 2334A0E1 		lsr	r3, r3, #8	@ wave_word, wave_word,
 669              	.LVL34:
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 670              		.loc 1 185 17 is_stmt 1 view .LVU161
 671              	@ armwave.c:185:                 if(value != 0) {
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 672              		.loc 1 185 19 is_stmt 0 view .LVU162
 673 02c4 F9FFFF0A 		beq	.L33		@,
 674              	.L50:
 186:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 675              		.loc 1 186 21 is_stmt 1 view .LVU163
 676              	.LVL35:
 187:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 677              		.loc 1 187 21 view .LVU164
 188:armwave.c     **** 
 678              		.loc 1 188 21 view .LVU165
 190:armwave.c     ****                     g = MIN(gg, 255);
 679              		.loc 1 190 21 view .LVU166
 191:armwave.c     ****                     b = MIN(bb, 255);
 680              		.loc 1 191 21 view .LVU167
 192:armwave.c     **** 
 681              		.loc 1 192 21 view .LVU168
 195:armwave.c     **** 
 682              		.loc 1 195 21 view .LVU169
 683              	@ armwave.c:188:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 188:armwave.c     **** 
 684              		.loc 1 188 55 is_stmt 0 view .LVU170
 685 02c8 04C09DE5 		ldr	ip, [sp, #4]	@ _13, %sfp
 686 02cc 075081E0 		add	r5, r1, r7	@ _120, n, w
 687 02d0 9C020AE0 		mul	r10, ip, r2	@ tmp181, _13, _7
 688              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 689              		.loc 1 210 32 view .LVU171
 690 02d4 75C0EFE6 		uxtb	ip, r5	@ _25, _120
 691              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 692              		.loc 1 211 41 view .LVU172
 693 02d8 01408CE2 		add	r4, ip, #1	@ tmp196, _25,
 694              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 695              		.loc 1 210 40 view .LVU173
 696 02dc 90CA07EE 		vmov	s15, ip	@ int	@ _25, _25
 697              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 698              		.loc 1 211 41 view .LVU174
 699 02e0 104A07EE 		vmov	s14, r4	@ int	@ tmp196, tmp196
 700              	@ armwave.c:187:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 187:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 701              		.loc 1 187 55 view .LVU175
 702 02e4 00C09DE5 		ldr	ip, [sp]	@ _10, %sfp
 703              	@ armwave.c:188:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 188:armwave.c     **** 
 704              		.loc 1 188 24 view .LVU176
 705 02e8 4AA4A0E1 		asr	r10, r10, #8	@ bb, tmp181,
 706              	.LVL36:
 707              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 708              		.loc 1 210 40 view .LVU177
 709 02ec E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp194, _25
 710              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 711              		.loc 1 211 46 view .LVU178
 712 02f0 C77AB8EE 		vcvt.f32.s32	s14, s14	@ tmp197, tmp196
 713              	@ armwave.c:187:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 187:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 714              		.loc 1 187 55 view .LVU179
 715 02f4 9C0204E0 		mul	r4, ip, r2	@ tmp185, _10, _7
 716              	@ armwave.c:186:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 186:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 717              		.loc 1 186 55 view .LVU180
 718 02f8 920B02E0 		mul	r2, r2, fp	@ tmp191, _7, _6
 719              	.LVL37:
 720              	@ armwave.c:192:                     b = MIN(bb, 255);
 192:armwave.c     **** 
 721              		.loc 1 192 25 view .LVU181
 722 02fc FF005AE3 		cmp	r10, #255	@ bb,
 723              	@ armwave.c:187:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 187:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 724              		.loc 1 187 24 view .LVU182
 725 0300 4444A0E1 		asr	r4, r4, #8	@ gg, tmp185,
 726              	.LVL38:
 727              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 728              		.loc 1 210 40 view .LVU183
 729 0304 A67A67EE 		vmul.f32	s15, s15, s13	@ tmp195, tmp194, _27
 730              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 731              		.loc 1 211 46 view .LVU184
 732 0308 267A27EE 		vmul.f32	s14, s14, s13	@ tmp198, tmp197, _27
 733              	@ armwave.c:186:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 186:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 734              		.loc 1 186 24 view .LVU185
 735 030c 42C4A0E1 		asr	ip, r2, #8	@ rr, tmp191,
 736              	.LVL39:
 737              	@ armwave.c:192:                     b = MIN(bb, 255);
 192:armwave.c     **** 
 738              		.loc 1 192 25 view .LVU186
 739 0310 FFA0A0A3 		movge	r10, #255	@ bb,
 740              	.LVL40:
 741              	@ armwave.c:191:                     g = MIN(gg, 255);
 191:armwave.c     ****                     b = MIN(bb, 255);
 742              		.loc 1 191 25 view .LVU187
 743 0314 FF0054E3 		cmp	r4, #255	@ gg,
 744 0318 FF40A0A3 		movge	r4, #255	@ gg,
 745              	.LVL41:
 746              	@ armwave.c:190:                     r = MIN(rr, 255);
 190:armwave.c     ****                     g = MIN(gg, 255);
 747              		.loc 1 190 25 view .LVU188
 748 031c FF005CE3 		cmp	ip, #255	@ rr,
 749              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 750              		.loc 1 195 56 view .LVU189
 751 0320 0444A0E1 		lsl	r4, r4, #8	@ tmp186, gg,
 752              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 753              		.loc 1 210 24 view .LVU190
 754 0324 E77AFCEE 		vcvt.u32.f32	s15, s15	@ yy, tmp195
 755              	@ armwave.c:190:                     r = MIN(rr, 255);
 190:armwave.c     ****                     g = MIN(gg, 255);
 756              		.loc 1 190 25 view .LVU191
 757 0328 FFC0A0A3 		movge	ip, #255	@ rr,
 758              	.LVL42:
 759              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 760              		.loc 1 195 44 view .LVU192
 761 032c 0AA8A0E1 		lsl	r10, r10, #16	@ tmp182, bb,
 762 0330 FFA80AE2 		and	r10, r10, #16711680	@ tmp183, tmp182,
 763              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 764              		.loc 1 195 56 view .LVU193
 765 0334 7440FFE6 		uxth	r4, r4	@ tmp187, tmp186
 766              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 767              		.loc 1 195 51 view .LVU194
 768 0338 04408AE1 		orr	r4, r10, r4	@ tmp189, tmp183, tmp187
 769              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 770              		.loc 1 195 62 view .LVU195
 771 033c 7CC0EFE6 		uxtb	ip, ip	@ rr, rr
 772 0340 0CC084E1 		orr	ip, r4, ip	@ tmp193, tmp189, rr
 773              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 774              		.loc 1 210 24 view .LVU196
 775 0344 902A17EE 		vmov	r2, s15	@ int	@ yy, yy
 776              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 777              		.loc 1 211 24 view .LVU197
 778 0348 C77AFCEE 		vcvt.u32.f32	s15, s14	@ ye, tmp198
 779              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 780              		.loc 1 195 26 view .LVU198
 781 034c FF448CE3 		orr	r4, ip, #-16777216	@ word, tmp193,
 782              	.LVL43:
 209:armwave.c     ****                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 783              		.loc 1 209 21 is_stmt 1 view .LVU199
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 784              		.loc 1 210 21 view .LVU200
 211:armwave.c     ****                     xx = (nsub >> 8);
 785              		.loc 1 211 21 view .LVU201
 786              	@ armwave.c:212:                     xx = (nsub >> 8);
 212:armwave.c     **** 
 787              		.loc 1 212 32 is_stmt 0 view .LVU202
 788 0350 4554A0E1 		asr	r5, r5, #8	@ xx, _120,
 789              	.LVL44:
 790              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 791              		.loc 1 211 24 view .LVU203
 792 0354 909A17EE 		vmov	r9, s15	@ int	@ ye, ye
 793              	.LVL45:
 212:armwave.c     **** 
 794              		.loc 1 212 21 is_stmt 1 view .LVU204
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 795              		.loc 1 214 21 view .LVU205
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 796              		.loc 1 214 21 is_stmt 0 view .LVU206
 797 0358 090052E1 		cmp	r2, r9	@ yy, ye
 798 035c D3FFFF2A 		bcs	.L33		@,
 799              	.LVL46:
 800              	.L34:
 215:armwave.c     ****                         *(out_buffer_base + offset) = word;
 801              		.loc 1 215 25 is_stmt 1 discriminator 3 view .LVU207
 216:armwave.c     ****                     }
 802              		.loc 1 216 25 discriminator 3 view .LVU208
 803              	@ armwave.c:215:                         offset = (xx + (y * g_armwave_state.target_width)); 
 215:armwave.c     ****                         *(out_buffer_base + offset) = word;
 804              		.loc 1 215 43 is_stmt 0 discriminator 3 view .LVU209
 805 0360 58C096E5 		ldr	ip, [r6, #88]	@ g_armwave_state.target_width, g_armwave_state.target_width
 806              	@ armwave.c:216:                         *(out_buffer_base + offset) = word;
 216:armwave.c     ****                     }
 807              		.loc 1 216 43 discriminator 3 view .LVU210
 808 0364 9C522CE0 		mla	ip, ip, r2, r5	@ tmp202, g_armwave_state.target_width, yy, xx
 809              	.LVL47:
 810              	@ armwave.c:214:                     for(y = yy; y < ye; y++) {
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 811              		.loc 1 214 42 discriminator 3 view .LVU211
 812 0368 012082E2 		add	r2, r2, #1	@ yy, yy,
 813              	.LVL48:
 814              	@ armwave.c:214:                     for(y = yy; y < ye; y++) {
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 815              		.loc 1 214 21 discriminator 3 view .LVU212
 816 036c 020059E1 		cmp	r9, r2	@ ye, yy
 817              	@ armwave.c:216:                         *(out_buffer_base + offset) = word;
 216:armwave.c     ****                     }
 818              		.loc 1 216 53 discriminator 3 view .LVU213
 819 0370 0C4180E7 		str	r4, [r0, ip, lsl #2]	@ word, *_37
 820              	@ armwave.c:214:                     for(y = yy; y < ye; y++) {
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 821              		.loc 1 214 21 discriminator 3 view .LVU214
 822 0374 F9FFFF1A 		bne	.L34		@,
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 823              		.loc 1 214 21 discriminator 3 view .LVU215
 824 0378 CCFFFFEA 		b	.L33		@
 825              	.LVL49:
 826              	.L48:
 169:armwave.c     **** 
 827              		.loc 1 169 5 is_stmt 1 discriminator 1 view .LVU216
 828 037c 10309FE5 		ldr	r3, .L51+4	@,
 829 0380 A920A0E3 		mov	r2, #169	@,
 830 0384 0C109FE5 		ldr	r1, .L51+8	@,
 831 0388 0C009FE5 		ldr	r0, .L51+12	@,
 832              	.LVL50:
 169:armwave.c     **** 
 833              		.loc 1 169 5 is_stmt 0 discriminator 1 view .LVU217
 834 038c FEFFFFEB 		bl	__assert_fail		@
 835              	.LVL51:
 836              	.L52:
 169:armwave.c     **** 
 837              		.loc 1 169 5 discriminator 1 view .LVU218
 838              		.align	2
 839              	.L51:
 840 0390 00000000 		.word	g_armwave_state
 841 0394 00000000 		.word	.LANCHOR0
 842 0398 20000000 		.word	.LC2
 843 039c 2C000000 		.word	.LC3
 844              		.cfi_endproc
 845              	.LFE60:
 847              		.align	2
 848              		.global	armwave_setup_render
 849              		.syntax unified
 850              		.arm
 851              		.fpu vfp
 853              	armwave_setup_render:
 854              	.LVL52:
 855              	.LFB61:
 223:armwave.c     **** 
 224:armwave.c     **** /*
 225:armwave.c     ****  * Setup the renderer with passed parameters.
 226:armwave.c     ****  */
 227:armwave.c     **** void armwave_setup_render(uint32_t start_point, uint32_t end_point, uint32_t waves_max, uint32_t wa
 228:armwave.c     **** {
 856              		.loc 1 228 1 is_stmt 1 view -0
 857              		.cfi_startproc
 858              		@ args = 12, pretend = 0, frame = 0
 859              		@ frame_needed = 0, uses_anonymous_args = 0
 229:armwave.c     ****     uint32_t length, xx;
 860              		.loc 1 229 5 view .LVU220
 230:armwave.c     ****     float points_per_pixel;
 861              		.loc 1 230 5 view .LVU221
 231:armwave.c     **** 
 232:armwave.c     ****     printf("s=%d e=%d w=%d ws=%d tw=%d th=%d rf=0x%08x\n", start_point, end_point, waves_max, wave_
 862              		.loc 1 232 5 view .LVU222
 863              	@ armwave.c:228: {
 228:armwave.c     ****     uint32_t length, xx;
 864              		.loc 1 228 1 is_stmt 0 view .LVU223
 865 03a0 F0432DE9 		push	{r4, r5, r6, r7, r8, r9, lr}	@
 866              		.cfi_def_cfa_offset 28
 867              		.cfi_offset 4, -28
 868              		.cfi_offset 5, -24
 869              		.cfi_offset 6, -20
 870              		.cfi_offset 7, -16
 871              		.cfi_offset 8, -12
 872              		.cfi_offset 9, -8
 873              		.cfi_offset 14, -4
 874 03a4 028B2DED 		vpush.64	{d8}	@
 875              		.cfi_def_cfa_offset 36
 876              		.cfi_offset 80, -36
 877              		.cfi_offset 81, -32
 878 03a8 0040A0E1 		mov	r4, r0	@ start_point, start_point
 879 03ac 0150A0E1 		mov	r5, r1	@ end_point, end_point
 880 03b0 0280A0E1 		mov	r8, r2	@ waves_max, waves_max
 881 03b4 14D04DE2 		sub	sp, sp, #20	@,,
 882              		.cfi_def_cfa_offset 56
 883              	@ armwave.c:228: {
 228:armwave.c     ****     uint32_t length, xx;
 884              		.loc 1 228 1 view .LVU224
 885 03b8 0390A0E1 		mov	r9, r3	@ wave_stride, wave_stride
 886 03bc D863CDE1 		ldrd	r6, [sp, #56]	@,,
 887 03c0 40C09DE5 		ldr	ip, [sp, #64]	@ render_flags, render_flags
 888              	@ armwave.c:232:     printf("s=%d e=%d w=%d ws=%d tw=%d th=%d rf=0x%08x\n", start_point, end_point,
 889              		.loc 1 232 5 view .LVU225
 890 03c4 00308DE5 		str	r3, [sp]	@ wave_stride,
 891 03c8 F460CDE1 		strd	r6, [sp, #4]	@,,
 892 03cc 0230A0E1 		mov	r3, r2	@, waves_max
 893              	.LVL53:
 894              		.loc 1 232 5 view .LVU226
 895 03d0 0CC08DE5 		str	ip, [sp, #12]	@ render_flags,
 896 03d4 0120A0E1 		mov	r2, r1	@, end_point
 897              	.LVL54:
 898              		.loc 1 232 5 view .LVU227
 899 03d8 0010A0E1 		mov	r1, r0	@, start_point
 900              	.LVL55:
 901              		.loc 1 232 5 view .LVU228
 902 03dc CC019FE5 		ldr	r0, .L67+12	@,
 903              	.LVL56:
 904              		.loc 1 232 5 view .LVU229
 905 03e0 FEFFFFEB 		bl	printf		@
 906              	.LVL57:
 233:armwave.c     **** 
 234:armwave.c     ****     // TODO these asserts should instead raise PyExc
 235:armwave.c     ****     assert(start_point < end_point);
 907              		.loc 1 235 5 is_stmt 1 view .LVU230
 908 03e4 050054E1 		cmp	r4, r5	@ start_point, end_point
 909 03e8 5E00002A 		bcs	.L64		@,
 236:armwave.c     **** 
 237:armwave.c     ****     /*
 238:armwave.c     ****     // target_height must be a power of two.  Only 256, 512, 1024 and 2048 height buffers are suppo
 239:armwave.c     ****     assert(target_height == 256 || target_height == 512 || target_height == 1024 || target_height =
 240:armwave.c     **** 
 241:armwave.c     ****     if(target_height == 256) {
 242:armwave.c     ****         g_armwave_state.row_shift = 8;
 243:armwave.c     ****         g_armwave_state.row_mask = 0x0ff;
 244:armwave.c     ****     } else if(target_height == 512) {
 245:armwave.c     ****         g_armwave_state.row_shift = 9;
 246:armwave.c     ****         g_armwave_state.row_mask = 0x1ff;
 247:armwave.c     ****     } else if(target_height == 1024) {
 248:armwave.c     ****         g_armwave_state.row_shift = 10;
 249:armwave.c     ****         g_armwave_state.row_mask = 0x3ff;
 250:armwave.c     ****     } else if(target_height == 2048) {
 251:armwave.c     ****         g_armwave_state.row_shift = 11;
 252:armwave.c     ****         g_armwave_state.row_mask = 0x7ff;
 253:armwave.c     ****     }
 254:armwave.c     ****     */
 255:armwave.c     **** 
 256:armwave.c     ****     // Calculate the size of each buffer.  Buffers are rotated by 90 degrees to improve cache coher
 257:armwave.c     ****     g_armwave_state.xstride = target_height;
 910              		.loc 1 257 5 view .LVU231
 911              	@ armwave.c:268:     g_armwave_state.wave_length = end_point - start_point;
 258:armwave.c     ****     g_armwave_state.vscale_frac = target_height / 255.0f;
 259:armwave.c     ****     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 260:armwave.c     ****     g_armwave_state.wave_stride = wave_stride;
 261:armwave.c     ****     g_armwave_state.waves_max = waves_max;
 262:armwave.c     ****     g_armwave_state.waves = waves_max;  // Need a function to be able to change this on the fly
 263:armwave.c     ****     g_armwave_state.size = target_height * target_width;
 264:armwave.c     ****     g_armwave_state.bitdepth_height = 256;  // Always 256 possible levels in 8-bit mode
 265:armwave.c     ****     g_armwave_state.ch_buff_size = g_armwave_state.bitdepth_height * target_width;
 266:armwave.c     ****     g_armwave_state.target_width = target_width;
 267:armwave.c     ****     g_armwave_state.target_height = target_height;
 268:armwave.c     ****     g_armwave_state.wave_length = end_point - start_point;
 912              		.loc 1 268 45 is_stmt 0 view .LVU232
 913 03ec 045045E0 		sub	r5, r5, r4	@ _12, end_point, start_point
 914              	.LVL58:
 915              	@ armwave.c:273:         (int)g_armwave_state.bitdepth_height * ((float)(g_armwave_state.target_wid
 269:armwave.c     **** 
 270:armwave.c     ****     // Calculate compound scaler
 271:armwave.c     ****     //g_armwave_state.cmp_x_bitdepth_scale = g_armwave_state.bitdepth_height * (1 << AM_XCOORD_MULT
 272:armwave.c     ****     g_armwave_state.cmp_x_bitdepth_scale = \
 273:armwave.c     ****         (int)g_armwave_state.bitdepth_height * ((float)(g_armwave_state.target_width) / g_armwave_s
 916              		.loc 1 273 46 view .LVU233
 917 03f0 6B6ADFED 		vldr.32	s13, .L67	@ tmp193,
 918              	@ armwave.c:273:         (int)g_armwave_state.bitdepth_height * ((float)(g_armwave_state.target_wid
 919              		.loc 1 273 87 view .LVU234
 920 03f4 905A07EE 		vmov	s15, r5	@ int	@ _12, _12
 921              	@ armwave.c:258:     g_armwave_state.vscale_frac = target_height / 255.0f;
 258:armwave.c     ****     g_armwave_state.vscale_frac = target_height / 255.0f;
 922              		.loc 1 258 49 view .LVU235
 923 03f8 6A6A9FED 		vldr.32	s12, .L67+4	@ tmp174,
 924              	@ armwave.c:257:     g_armwave_state.xstride = target_height;
 257:armwave.c     ****     g_armwave_state.vscale_frac = target_height / 255.0f;
 925              		.loc 1 257 29 view .LVU236
 926 03fc B0419FE5 		ldr	r4, .L67+16	@ tmp236,
 927              	.LVL59:
 928              	@ armwave.c:263:     g_armwave_state.size = target_height * target_width;
 263:armwave.c     ****     g_armwave_state.bitdepth_height = 256;  // Always 256 possible levels in 8-bit mode
 929              		.loc 1 263 42 view .LVU237
 930 0400 970601E0 		mul	r1, r7, r6	@ tmp182, target_height, target_width
 931              	@ armwave.c:273:         (int)g_armwave_state.bitdepth_height * ((float)(g_armwave_state.target_wid
 932              		.loc 1 273 87 view .LVU238
 933 0404 E75AB8EE 		vcvt.f32.s32	s10, s15	@ tmp190, _12
 934              	@ armwave.c:258:     g_armwave_state.vscale_frac = target_height / 255.0f;
 258:armwave.c     ****     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 935              		.loc 1 258 49 view .LVU239
 936 0408 907A07EE 		vmov	s15, r7	@ int	@ target_height, target_height
 937              	@ armwave.c:265:     g_armwave_state.ch_buff_size = g_armwave_state.bitdepth_height * target_width;
 265:armwave.c     ****     g_armwave_state.target_width = target_width;
 938              		.loc 1 265 68 view .LVU240
 939 040c 0634A0E1 		lsl	r3, r6, #8	@ _10, target_width,
 940              	@ armwave.c:264:     g_armwave_state.bitdepth_height = 256;  // Always 256 possible levels in 8-bit
 264:armwave.c     ****     g_armwave_state.ch_buff_size = g_armwave_state.bitdepth_height * target_width;
 941              		.loc 1 264 37 view .LVU241
 942 0410 012CA0E3 		mov	r2, #256	@ tmp184,
 943              	@ armwave.c:263:     g_armwave_state.size = target_height * target_width;
 263:armwave.c     ****     g_armwave_state.bitdepth_height = 256;  // Always 256 possible levels in 8-bit mode
 944              		.loc 1 263 26 view .LVU242
 945 0414 541084E5 		str	r1, [r4, #84]	@ tmp182, g_armwave_state.size
 946              	@ armwave.c:258:     g_armwave_state.vscale_frac = target_height / 255.0f;
 258:armwave.c     ****     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 947              		.loc 1 258 49 view .LVU243
 948 0418 675AF8EE 		vcvt.f32.u32	s11, s15	@ tmp173, target_height
 949              	@ armwave.c:273:         (int)g_armwave_state.bitdepth_height * ((float)(g_armwave_state.target_wid
 950              		.loc 1 273 87 view .LVU244
 951 041c 906A07EE 		vmov	s15, r6	@ int	@ target_width, target_width
 952              	@ armwave.c:275:     printf("ch_buff_size=%d, cmp_x_bitdepth_scale=%d (0x%08x)\n", \
 274:armwave.c     **** 
 275:armwave.c     ****     printf("ch_buff_size=%d, cmp_x_bitdepth_scale=%d (0x%08x)\n", \
 953              		.loc 1 275 5 view .LVU245
 954 0420 0310A0E1 		mov	r1, r3	@, _10
 955              	@ armwave.c:264:     g_armwave_state.bitdepth_height = 256;  // Always 256 possible levels in 8-bit
 264:armwave.c     ****     g_armwave_state.ch_buff_size = g_armwave_state.bitdepth_height * target_width;
 956              		.loc 1 264 37 view .LVU246
 957 0424 402084E5 		str	r2, [r4, #64]	@ tmp184, g_armwave_state.bitdepth_height
 958              	@ armwave.c:265:     g_armwave_state.ch_buff_size = g_armwave_state.bitdepth_height * target_width;
 265:armwave.c     ****     g_armwave_state.target_width = target_width;
 959              		.loc 1 265 34 view .LVU247
 960 0428 503084E5 		str	r3, [r4, #80]	@ _10, g_armwave_state.ch_buff_size
 961              	@ armwave.c:273:         (int)g_armwave_state.bitdepth_height * ((float)(g_armwave_state.target_wid
 273:armwave.c     **** 
 962              		.loc 1 273 87 view .LVU248
 963 042c E77AB8EE 		vcvt.f32.s32	s14, s15	@ tmp189, target_width
 964              	@ armwave.c:275:     printf("ch_buff_size=%d, cmp_x_bitdepth_scale=%d (0x%08x)\n", \
 965              		.loc 1 275 5 view .LVU249
 966 0430 80019FE5 		ldr	r0, .L67+20	@,
 967              	@ armwave.c:257:     g_armwave_state.xstride = target_height;
 257:armwave.c     ****     g_armwave_state.vscale_frac = target_height / 255.0f;
 968              		.loc 1 257 29 view .LVU250
 969 0434 2C7084E5 		str	r7, [r4, #44]	@ target_height, g_armwave_state.xstride
 258:armwave.c     ****     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 970              		.loc 1 258 5 is_stmt 1 view .LVU251
 971              	@ armwave.c:260:     g_armwave_state.wave_stride = wave_stride;
 260:armwave.c     ****     g_armwave_state.waves_max = waves_max;
 972              		.loc 1 260 33 is_stmt 0 view .LVU252
 973 0438 349084E5 		str	r9, [r4, #52]	@ wave_stride, g_armwave_state.wave_stride
 974              	@ armwave.c:261:     g_armwave_state.waves_max = waves_max;
 261:armwave.c     ****     g_armwave_state.waves = waves_max;  // Need a function to be able to change this on the fly
 975              		.loc 1 261 31 view .LVU253
 976 043c 3C8084E5 		str	r8, [r4, #60]	@ waves_max, g_armwave_state.waves_max
 977              	@ armwave.c:262:     g_armwave_state.waves = waves_max;  // Need a function to be able to change th
 262:armwave.c     ****     g_armwave_state.size = target_height * target_width;
 978              		.loc 1 262 27 view .LVU254
 979 0440 388084E5 		str	r8, [r4, #56]	@ waves_max, g_armwave_state.waves
 980              	@ armwave.c:267:     g_armwave_state.target_height = target_height;
 267:armwave.c     ****     g_armwave_state.wave_length = end_point - start_point;
 981              		.loc 1 267 35 view .LVU255
 982 0444 F865C4E1 		strd	r6, [r4, #88]	@, tmp236,
 983              	@ armwave.c:268:     g_armwave_state.wave_length = end_point - start_point;
 268:armwave.c     **** 
 984              		.loc 1 268 33 view .LVU256
 985 0448 4C5084E5 		str	r5, [r4, #76]	@ _12, g_armwave_state.wave_length
 986              	@ armwave.c:273:         (int)g_armwave_state.bitdepth_height * ((float)(g_armwave_state.target_wid
 273:armwave.c     **** 
 987              		.loc 1 273 87 view .LVU257
 988 044c 057AC7EE 		vdiv.f32	s15, s14, s10	@ tmp191, tmp189, tmp190
 989              	@ armwave.c:258:     g_armwave_state.vscale_frac = target_height / 255.0f;
 258:armwave.c     ****     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 990              		.loc 1 258 49 view .LVU258
 991 0450 867A85EE 		vdiv.f32	s14, s11, s12	@ _3, tmp173, tmp174
 992              	@ armwave.c:273:         (int)g_armwave_state.bitdepth_height * ((float)(g_armwave_state.target_wid
 273:armwave.c     **** 
 993              		.loc 1 273 46 view .LVU259
 994 0454 A67A67EE 		vmul.f32	s15, s15, s13	@ tmp192, tmp191, tmp193
 995              	@ armwave.c:273:         (int)g_armwave_state.bitdepth_height * ((float)(g_armwave_state.target_wid
 273:armwave.c     **** 
 996              		.loc 1 273 118 view .LVU260
 997 0458 A67A67EE 		vmul.f32	s15, s15, s13	@ tmp194, tmp192, tmp193
 998              	@ armwave.c:259:     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 259:armwave.c     ****     g_armwave_state.wave_stride = wave_stride;
 999              		.loc 1 259 30 view .LVU261
 1000 045c C76AFDEE 		vcvt.s32.f32	s13, s14	@ tmp177, _3
 1001              	@ armwave.c:272:     g_armwave_state.cmp_x_bitdepth_scale = \
 272:armwave.c     ****         (int)g_armwave_state.bitdepth_height * ((float)(g_armwave_state.target_width) / g_armwave_s
 1002              		.loc 1 272 42 view .LVU262
 1003 0460 E77AFCEE 		vcvt.u32.f32	s15, s15	@ _19, tmp194
 1004              	@ armwave.c:258:     g_armwave_state.vscale_frac = target_height / 255.0f;
 258:armwave.c     ****     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 1005              		.loc 1 258 33 view .LVU263
 1006 0464 0A7A84ED 		vstr.32	s14, [r4, #40]	@ _3, g_armwave_state.vscale_frac
 259:armwave.c     ****     g_armwave_state.wave_stride = wave_stride;
 1007              		.loc 1 259 5 is_stmt 1 view .LVU264
 1008              	@ armwave.c:259:     g_armwave_state.vscale = (int)g_armwave_state.vscale_frac;
 259:armwave.c     ****     g_armwave_state.wave_stride = wave_stride;
 1009              		.loc 1 259 30 is_stmt 0 view .LVU265
 1010 0468 0C6AC4ED 		vstr.32	s13, [r4, #48]	@ int	@ tmp177, g_armwave_state.vscale
 260:armwave.c     ****     g_armwave_state.waves_max = waves_max;
 1011              		.loc 1 260 5 is_stmt 1 view .LVU266
 261:armwave.c     ****     g_armwave_state.waves = waves_max;  // Need a function to be able to change this on the fly
 1012              		.loc 1 261 5 view .LVU267
 262:armwave.c     ****     g_armwave_state.size = target_height * target_width;
 1013              		.loc 1 262 5 view .LVU268
 263:armwave.c     ****     g_armwave_state.bitdepth_height = 256;  // Always 256 possible levels in 8-bit mode
 1014              		.loc 1 263 5 view .LVU269
 264:armwave.c     ****     g_armwave_state.ch_buff_size = g_armwave_state.bitdepth_height * target_width;
 1015              		.loc 1 264 5 view .LVU270
 265:armwave.c     ****     g_armwave_state.target_width = target_width;
 1016              		.loc 1 265 5 view .LVU271
 266:armwave.c     ****     g_armwave_state.target_height = target_height;
 1017              		.loc 1 266 5 view .LVU272
 267:armwave.c     ****     g_armwave_state.wave_length = end_point - start_point;
 1018              		.loc 1 267 5 view .LVU273
 268:armwave.c     **** 
 1019              		.loc 1 268 5 view .LVU274
 272:armwave.c     ****         (int)g_armwave_state.bitdepth_height * ((float)(g_armwave_state.target_width) / g_armwave_s
 1020              		.loc 1 272 5 view .LVU275
 1021              	@ armwave.c:272:     g_armwave_state.cmp_x_bitdepth_scale = \
 272:armwave.c     ****         (int)g_armwave_state.bitdepth_height * ((float)(g_armwave_state.target_width) / g_armwave_s
 1022              		.loc 1 272 42 is_stmt 0 view .LVU276
 1023 046c 90CA17EE 		vmov	ip, s15	@ int	@ _19, _19
 1024              	@ armwave.c:275:     printf("ch_buff_size=%d, cmp_x_bitdepth_scale=%d (0x%08x)\n", \
 1025              		.loc 1 275 5 view .LVU277
 1026 0470 903A17EE 		vmov	r3, s15	@ int	@, _19
 1027              	@ armwave.c:272:     g_armwave_state.cmp_x_bitdepth_scale = \
 272:armwave.c     ****         (int)g_armwave_state.bitdepth_height * ((float)(g_armwave_state.target_width) / g_armwave_s
 1028              		.loc 1 272 42 view .LVU278
 1029 0474 097AC4ED 		vstr.32	s15, [r4, #36]	@ int	@ _19, g_armwave_state.cmp_x_bitdepth_scale
 1030              		.loc 1 275 5 is_stmt 1 view .LVU279
 1031 0478 0C20A0E1 		mov	r2, ip	@, tmp3
 1032 047c FEFFFFEB 		bl	printf		@
 1033              	.LVL60:
 276:armwave.c     ****         g_armwave_state.ch_buff_size, g_armwave_state.cmp_x_bitdepth_scale, g_armwave_state.cmp_x_b
 277:armwave.c     **** 
 278:armwave.c     ****     // In 1ch mode, target 1024 x 16 render buffer, reading 16 bytes at a time from each wave, reta
 279:armwave.c     ****     // In 2ch mode, target two 1024 x 8 render buffers, reading 16 bytes at a time from each wave
 280:armwave.c     ****     // In 4ch mode, target four 1024 x 4 render buffers, reading 16 bytes at a time from each wave
 281:armwave.c     ****     g_armwave_state.slice_height = 64;  
 1034              		.loc 1 281 5 view .LVU280
 1035              	@ armwave.c:283:     if(g_armwave_state.ch1_buffer != NULL)
 282:armwave.c     **** 
 283:armwave.c     ****     if(g_armwave_state.ch1_buffer != NULL)
 1036              		.loc 1 283 23 is_stmt 0 view .LVU281
 1037 0480 040094E5 		ldr	r0, [r4, #4]	@ _20, g_armwave_state.ch1_buffer
 1038              	@ armwave.c:281:     g_armwave_state.slice_height = 64;  
 281:armwave.c     **** 
 1039              		.loc 1 281 34 view .LVU282
 1040 0484 4030A0E3 		mov	r3, #64	@ tmp199,
 1041              	@ armwave.c:283:     if(g_armwave_state.ch1_buffer != NULL)
 1042              		.loc 1 283 7 view .LVU283
 1043 0488 000050E3 		cmp	r0, #0	@ _20,
 1044              	@ armwave.c:281:     g_armwave_state.slice_height = 64;  
 281:armwave.c     **** 
 1045              		.loc 1 281 34 view .LVU284
 1046 048c 443084E5 		str	r3, [r4, #68]	@ tmp199, g_armwave_state.slice_height
 1047              		.loc 1 283 5 is_stmt 1 view .LVU285
 1048              	@ armwave.c:283:     if(g_armwave_state.ch1_buffer != NULL)
 1049              		.loc 1 283 7 is_stmt 0 view .LVU286
 1050 0490 0000000A 		beq	.L55		@,
 284:armwave.c     ****         free(g_armwave_state.ch1_buffer);
 1051              		.loc 1 284 9 is_stmt 1 view .LVU287
 1052 0494 FEFFFFEB 		bl	free		@
 1053              	.LVL61:
 1054              	.L55:
 285:armwave.c     **** 
 286:armwave.c     ****     g_armwave_state.ch1_buffer = calloc(g_armwave_state.ch_buff_size, 1);
 1055              		.loc 1 286 5 view .LVU288
 1056              	@ armwave.c:286:     g_armwave_state.ch1_buffer = calloc(g_armwave_state.ch_buff_size, 1);
 1057              		.loc 1 286 34 is_stmt 0 view .LVU289
 1058 0498 0110A0E3 		mov	r1, #1	@,
 1059 049c 500094E5 		ldr	r0, [r4, #80]	@, g_armwave_state.ch_buff_size
 1060 04a0 FEFFFFEB 		bl	calloc		@
 1061              	.LVL62:
 1062              	@ armwave.c:288:     assert(g_armwave_state.ch1_buffer != NULL);
 287:armwave.c     **** 
 288:armwave.c     ****     assert(g_armwave_state.ch1_buffer != NULL);
 1063              		.loc 1 288 5 view .LVU290
 1064 04a4 000050E3 		cmp	r0, #0	@ _23,
 1065              	@ armwave.c:286:     g_armwave_state.ch1_buffer = calloc(g_armwave_state.ch_buff_size, 1);
 286:armwave.c     **** 
 1066              		.loc 1 286 34 view .LVU291
 1067 04a8 0070A0E1 		mov	r7, r0	@ _23,
 1068              	@ armwave.c:286:     g_armwave_state.ch1_buffer = calloc(g_armwave_state.ch_buff_size, 1);
 286:armwave.c     **** 
 1069              		.loc 1 286 32 view .LVU292
 1070 04ac 040084E5 		str	r0, [r4, #4]	@ _23, g_armwave_state.ch1_buffer
 1071              		.loc 1 288 5 is_stmt 1 view .LVU293
 1072 04b0 3600000A 		beq	.L65		@,
 289:armwave.c     **** 
 290:armwave.c     ****     // Precompute the x-coord to pixel lookup to reduce ALU load
 291:armwave.c     ****     length = end_point - start_point;
 1073              		.loc 1 291 5 view .LVU294
 1074              	.LVL63:
 292:armwave.c     ****     points_per_pixel = length / ((float)(target_width));
 1075              		.loc 1 292 5 view .LVU295
 1076              	@ armwave.c:292:     points_per_pixel = length / ((float)(target_width));
 1077              		.loc 1 292 34 is_stmt 0 view .LVU296
 1078 04b4 906A07EE 		vmov	s15, r6	@ int	@ target_width, target_width
 1079              	@ armwave.c:292:     points_per_pixel = length / ((float)(target_width));
 1080              		.loc 1 292 22 view .LVU297
 1081 04b8 905A06EE 		vmov	s13, r5	@ int	@ _12, _12
 1082              	@ armwave.c:293:     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice
 293:armwave.c     ****     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice_height;
 1083              		.loc 1 293 60 view .LVU298
 1084 04bc 117A94ED 		vldr.32	s14, [r4, #68]	@ int	@ tmp246, g_armwave_state.slice_height
 1085              	@ armwave.c:294:     g_armwave_state.xcoord_to_xpixel = malloc(length * sizeof(uint16_t));
 294:armwave.c     ****     g_armwave_state.xcoord_to_xpixel = malloc(length * sizeof(uint16_t));
 1086              		.loc 1 294 40 view .LVU299
 1087 04c0 8500A0E1 		lsl	r0, r5, #1	@, _12,
 1088              	@ armwave.c:292:     points_per_pixel = length / ((float)(target_width));
 292:armwave.c     ****     points_per_pixel = length / ((float)(target_width));
 1089              		.loc 1 292 34 view .LVU300
 1090 04c4 677AF8EE 		vcvt.f32.u32	s15, s15	@ tmp210, target_width
 1091              	@ armwave.c:292:     points_per_pixel = length / ((float)(target_width));
 292:armwave.c     ****     points_per_pixel = length / ((float)(target_width));
 1092              		.loc 1 292 22 view .LVU301
 1093 04c8 666AF8EE 		vcvt.f32.u32	s13, s13	@ tmp209, _12
 1094              	@ armwave.c:293:     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice
 293:armwave.c     ****     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice_height;
 1095              		.loc 1 293 60 view .LVU302
 1096 04cc C77AB8EE 		vcvt.f32.s32	s14, s14	@ tmp213, tmp246
 1097              	@ armwave.c:292:     points_per_pixel = length / ((float)(target_width));
 292:armwave.c     ****     points_per_pixel = length / ((float)(target_width));
 1098              		.loc 1 292 22 view .LVU303
 1099 04d0 A78A86EE 		vdiv.f32	s16, s13, s15	@ points_per_pixel, tmp209, tmp210
 1100              	.LVL64:
 293:armwave.c     ****     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice_height;
 1101              		.loc 1 293 5 is_stmt 1 view .LVU304
 1102              	@ armwave.c:293:     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice
 293:armwave.c     ****     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice_height;
 1103              		.loc 1 293 60 is_stmt 0 view .LVU305
 1104 04d4 087A67EE 		vmul.f32	s15, s14, s16	@ tmp215, tmp213, points_per_pixel
 1105              	@ armwave.c:293:     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice
 293:armwave.c     ****     g_armwave_state.slice_record_height = points_per_pixel * g_armwave_state.slice_height;
 1106              		.loc 1 293 41 view .LVU306
 1107 04d8 E77AFDEE 		vcvt.s32.f32	s15, s15	@ tmp216, tmp215
 1108 04dc 127AC4ED 		vstr.32	s15, [r4, #72]	@ int	@ tmp216, g_armwave_state.slice_record_height
 1109              		.loc 1 294 5 is_stmt 1 view .LVU307
 1110              	@ armwave.c:294:     g_armwave_state.xcoord_to_xpixel = malloc(length * sizeof(uint16_t));
 1111              		.loc 1 294 40 is_stmt 0 view .LVU308
 1112 04e0 FEFFFFEB 		bl	malloc		@
 1113              	.LVL65:
 1114              	@ armwave.c:296:     assert(g_armwave_state.xcoord_to_xpixel != NULL);
 295:armwave.c     **** 
 296:armwave.c     ****     assert(g_armwave_state.xcoord_to_xpixel != NULL);
 1115              		.loc 1 296 5 view .LVU309
 1116 04e4 000050E3 		cmp	r0, #0	@ _31,
 1117              	@ armwave.c:294:     g_armwave_state.xcoord_to_xpixel = malloc(length * sizeof(uint16_t));
 294:armwave.c     ****     g_armwave_state.xcoord_to_xpixel = malloc(length * sizeof(uint16_t));
 1118              		.loc 1 294 40 view .LVU310
 1119 04e8 0060A0E1 		mov	r6, r0	@ _31,
 1120              	@ armwave.c:294:     g_armwave_state.xcoord_to_xpixel = malloc(length * sizeof(uint16_t));
 294:armwave.c     ****     g_armwave_state.xcoord_to_xpixel = malloc(length * sizeof(uint16_t));
 1121              		.loc 1 294 38 view .LVU311
 1122 04ec 840084E5 		str	r0, [r4, #132]	@ _31, g_armwave_state.xcoord_to_xpixel
 1123              		.loc 1 296 5 is_stmt 1 view .LVU312
 1124 04f0 2100000A 		beq	.L66		@,
 1125              	@ armwave.c:299:         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 297:armwave.c     **** 
 298:armwave.c     ****     for(xx = 0; xx < length; xx++) {
 299:armwave.c     ****         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1126              		.loc 1 299 54 is_stmt 0 view .LVU313
 1127 04f4 2C7ADFED 		vldr.32	s15, .L67+8	@ tmp224,
 1128 04f8 02C040E2 		sub	ip, r0, #2	@ ivtmp.65, _31,
 1129              	@ armwave.c:298:     for(xx = 0; xx < length; xx++) {
 298:armwave.c     ****         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1130              		.loc 1 298 12 view .LVU314
 1131 04fc 0030A0E3 		mov	r3, #0	@ xx,
 1132              	@ armwave.c:299:         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1133              		.loc 1 299 54 view .LVU315
 1134 0500 887A87EE 		vdiv.f32	s14, s15, s16	@ _32, tmp224, points_per_pixel
 1135              	.L58:
 1136              	.LVL66:
 1137              		.loc 1 299 9 is_stmt 1 discriminator 3 view .LVU316
 1138              	@ armwave.c:299:         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1139              		.loc 1 299 74 is_stmt 0 discriminator 3 view .LVU317
 1140 0504 903A07EE 		vmov	s15, r3	@ int	@ xx, xx
 1141              	@ armwave.c:298:     for(xx = 0; xx < length; xx++) {
 298:armwave.c     ****         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1142              		.loc 1 298 32 discriminator 3 view .LVU318
 1143 0508 013083E2 		add	r3, r3, #1	@ xx, xx,
 1144              	.LVL67:
 1145              	@ armwave.c:298:     for(xx = 0; xx < length; xx++) {
 298:armwave.c     ****         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1146              		.loc 1 298 5 discriminator 3 view .LVU319
 1147 050c 030055E1 		cmp	r5, r3	@ _12, xx
 1148              	@ armwave.c:299:         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1149              		.loc 1 299 74 discriminator 3 view .LVU320
 1150 0510 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp225, xx
 1151 0514 877A67EE 		vmul.f32	s15, s15, s14	@ tmp226, tmp225, _32
 1152              	@ armwave.c:299:         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1153              		.loc 1 299 46 discriminator 3 view .LVU321
 1154 0518 E77AFCEE 		vcvt.u32.f32	s15, s15	@ tmp227, tmp226
 1155 051c 902A17EE 		vmov	r2, s15	@ int	@ tmp227, tmp227
 1156 0520 B220ECE1 		strh	r2, [ip, #2]!	@ movhi	@ tmp227, MEM[base: _101, offset: 0B]
 1157              	@ armwave.c:298:     for(xx = 0; xx < length; xx++) {
 298:armwave.c     ****         g_armwave_state.xcoord_to_xpixel[xx] = (1.0f / points_per_pixel) * xx;
 1158              		.loc 1 298 5 discriminator 3 view .LVU322
 1159 0524 F6FFFF1A 		bne	.L58		@,
 300:armwave.c     **** 
 301:armwave.c     ****         // printf("xcoord_to_xpixel[%5d] = %5d (scale:%8.3f)\n", xx, g_armwave_state.xcoord_to_xpix
 302:armwave.c     ****     }
 303:armwave.c     **** 
 304:armwave.c     ****     g_armwave_state.out_pixbuf = malloc(sizeof(uint32_t) * g_armwave_state.size);
 1160              		.loc 1 304 5 is_stmt 1 view .LVU323
 1161              	@ armwave.c:304:     g_armwave_state.out_pixbuf = malloc(sizeof(uint32_t) * g_armwave_state.size);
 1162              		.loc 1 304 34 is_stmt 0 view .LVU324
 1163 0528 540094E5 		ldr	r0, [r4, #84]	@ g_armwave_state.size, g_armwave_state.size
 1164 052c 0001A0E1 		lsl	r0, r0, #2	@, g_armwave_state.size,
 1165 0530 FEFFFFEB 		bl	malloc		@
 1166              	.LVL68:
 1167              	@ armwave.c:306:     printf("Ptrs: 0x%08x 0x%08x 0x%08x 0x%08x \n", \
 305:armwave.c     **** 
 306:armwave.c     ****     printf("Ptrs: 0x%08x 0x%08x 0x%08x 0x%08x \n", \
 1168              		.loc 1 306 5 view .LVU325
 1169 0534 183094E5 		ldr	r3, [r4, #24]	@ g_armwave_state.test_wave_buffer, g_armwave_state.test_wave_buffer
 1170 0538 0620A0E1 		mov	r2, r6	@, _31
 1171 053c 00308DE5 		str	r3, [sp]	@ g_armwave_state.test_wave_buffer,
 1172 0540 0710A0E1 		mov	r1, r7	@, _23
 1173              	@ armwave.c:304:     g_armwave_state.out_pixbuf = malloc(sizeof(uint32_t) * g_armwave_state.size);
 304:armwave.c     **** 
 1174              		.loc 1 304 34 view .LVU326
 1175 0544 00C0A0E1 		mov	ip, r0	@ tmp231,
 1176              	@ armwave.c:306:     printf("Ptrs: 0x%08x 0x%08x 0x%08x 0x%08x \n", \
 1177              		.loc 1 306 5 view .LVU327
 1178 0548 0030A0E1 		mov	r3, r0	@, tmp231
 1179              	@ armwave.c:304:     g_armwave_state.out_pixbuf = malloc(sizeof(uint32_t) * g_armwave_state.size);
 304:armwave.c     **** 
 1180              		.loc 1 304 32 view .LVU328
 1181 054c 68C084E5 		str	ip, [r4, #104]	@ tmp231, g_armwave_state.out_pixbuf
 1182              		.loc 1 306 5 is_stmt 1 view .LVU329
 1183 0550 64009FE5 		ldr	r0, .L67+24	@,
 1184 0554 FEFFFFEB 		bl	printf		@
 1185              	.LVL69:
 307:armwave.c     ****         (uint32_t)g_armwave_state.ch1_buffer, \
 308:armwave.c     ****         (uint32_t)g_armwave_state.xcoord_to_xpixel, \
 309:armwave.c     ****         (uint32_t)g_armwave_state.out_pixbuf, \
 310:armwave.c     ****         (uint32_t)g_armwave_state.test_wave_buffer);
 311:armwave.c     **** 
 312:armwave.c     ****     malloc_stats();
 1186              		.loc 1 312 5 view .LVU330
 1187              	@ armwave.c:313: }
 313:armwave.c     **** }
 1188              		.loc 1 313 1 is_stmt 0 view .LVU331
 1189 0558 14D08DE2 		add	sp, sp, #20	@,,
 1190              		.cfi_remember_state
 1191              		.cfi_def_cfa_offset 36
 1192              		@ sp needed	@
 1193 055c 028BBDEC 		vldm	sp!, {d8}	@
 1194              		.cfi_restore 80
 1195              		.cfi_restore 81
 1196              		.cfi_def_cfa_offset 28
 1197              	.LVL70:
 1198              		.loc 1 313 1 view .LVU332
 1199 0560 F043BDE8 		pop	{r4, r5, r6, r7, r8, r9, lr}	@
 1200              		.cfi_restore 14
 1201              		.cfi_restore 9
 1202              		.cfi_restore 8
 1203              		.cfi_restore 7
 1204              		.cfi_restore 6
 1205              		.cfi_restore 5
 1206              		.cfi_restore 4
 1207              		.cfi_def_cfa_offset 0
 1208              	.LVL71:
 1209              	@ armwave.c:312:     malloc_stats();
 312:armwave.c     **** }
 1210              		.loc 1 312 5 view .LVU333
 1211 0564 FEFFFFEA 		b	malloc_stats		@
 1212              	.LVL72:
 1213              	.L64:
 1214              		.cfi_restore_state
 235:armwave.c     **** 
 1215              		.loc 1 235 5 is_stmt 1 discriminator 1 view .LVU334
 1216 0568 50309FE5 		ldr	r3, .L67+28	@,
 1217 056c EB20A0E3 		mov	r2, #235	@,
 1218 0570 4C109FE5 		ldr	r1, .L67+32	@,
 1219 0574 4C009FE5 		ldr	r0, .L67+36	@,
 1220 0578 FEFFFFEB 		bl	__assert_fail		@
 1221              	.LVL73:
 1222              	.L66:
 296:armwave.c     **** 
 1223              		.loc 1 296 5 discriminator 1 view .LVU335
 1224 057c 3C309FE5 		ldr	r3, .L67+28	@,
 1225 0580 4A2FA0E3 		mov	r2, #296	@,
 1226 0584 38109FE5 		ldr	r1, .L67+32	@,
 1227 0588 3C009FE5 		ldr	r0, .L67+40	@,
 1228 058c FEFFFFEB 		bl	__assert_fail		@
 1229              	.LVL74:
 1230              	.L65:
 288:armwave.c     **** 
 1231              		.loc 1 288 5 discriminator 1 view .LVU336
 1232 0590 28309FE5 		ldr	r3, .L67+28	@,
 1233 0594 122EA0E3 		mov	r2, #288	@,
 1234 0598 24109FE5 		ldr	r1, .L67+32	@,
 1235 059c 2C009FE5 		ldr	r0, .L67+44	@,
 1236 05a0 FEFFFFEB 		bl	__assert_fail		@
 1237              	.LVL75:
 1238              	.L68:
 1239              		.align	2
 1240              	.L67:
 1241 05a4 00008043 		.word	1132462080
 1242 05a8 00007F43 		.word	1132396544
 1243 05ac 0000803F 		.word	1065353216
 1244 05b0 40000000 		.word	.LC4
 1245 05b4 00000000 		.word	g_armwave_state
 1246 05b8 84000000 		.word	.LC6
 1247 05bc 08010000 		.word	.LC9
 1248 05c0 1C000000 		.word	.LANCHOR0+28
 1249 05c4 20000000 		.word	.LC2
 1250 05c8 6C000000 		.word	.LC5
 1251 05cc DC000000 		.word	.LC8
 1252 05d0 B8000000 		.word	.LC7
 1253              		.cfi_endproc
 1254              	.LFE61:
 1256              		.align	2
 1257              		.global	armwave_set_wave_pointer
 1258              		.syntax unified
 1259              		.arm
 1260              		.fpu vfp
 1262              	armwave_set_wave_pointer:
 1263              	.LVL76:
 1264              	.LFB62:
 314:armwave.c     **** 
 315:armwave.c     **** /*
 316:armwave.c     ****  * Set wave buffer pointer.  This needs to be changed to support disjointed buffers
 317:armwave.c     ****  * in the future.
 318:armwave.c     ****  */
 319:armwave.c     **** void armwave_set_wave_pointer(uint8_t *wave_buffer)
 320:armwave.c     **** {
 1265              		.loc 1 320 1 view -0
 1266              		.cfi_startproc
 1267              		@ args = 0, pretend = 0, frame = 0
 1268              		@ frame_needed = 0, uses_anonymous_args = 0
 321:armwave.c     ****     assert(wave_buffer != NULL);
 1269              		.loc 1 321 5 view .LVU338
 1270 05d4 000050E3 		cmp	r0, #0	@ wave_buffer
 1271              		.loc 1 321 5 is_stmt 0 view .LVU339
 1272 05d8 0200000A 		beq	.L74		@,
 322:armwave.c     ****     g_armwave_state.wave_buffer = wave_buffer;
 1273              		.loc 1 322 5 is_stmt 1 view .LVU340
 1274              	@ armwave.c:322:     g_armwave_state.wave_buffer = wave_buffer;
 1275              		.loc 1 322 33 is_stmt 0 view .LVU341
 1276 05dc 1C309FE5 		ldr	r3, .L75	@ tmp116,
 1277 05e0 140083E5 		str	r0, [r3, #20]	@ wave_buffer, g_armwave_state.wave_buffer
 1278 05e4 1EFF2FE1 		bx	lr	@
 1279              	.L74:
 321:armwave.c     ****     assert(wave_buffer != NULL);
 1280              		.loc 1 321 5 is_stmt 1 discriminator 1 view .LVU342
 1281              	@ armwave.c:320: {
 320:armwave.c     ****     assert(wave_buffer != NULL);
 1282              		.loc 1 320 1 is_stmt 0 discriminator 1 view .LVU343
 1283 05e8 10402DE9 		push	{r4, lr}	@
 1284              		.cfi_def_cfa_offset 8
 1285              		.cfi_offset 4, -8
 1286              		.cfi_offset 14, -4
 1287              	@ armwave.c:321:     assert(wave_buffer != NULL);
 321:armwave.c     ****     assert(wave_buffer != NULL);
 1288              		.loc 1 321 5 discriminator 1 view .LVU344
 1289 05ec 10309FE5 		ldr	r3, .L75+4	@,
 1290 05f0 10209FE5 		ldr	r2, .L75+8	@,
 1291 05f4 10109FE5 		ldr	r1, .L75+12	@,
 1292 05f8 10009FE5 		ldr	r0, .L75+16	@,
 1293              	.LVL77:
 321:armwave.c     ****     assert(wave_buffer != NULL);
 1294              		.loc 1 321 5 discriminator 1 view .LVU345
 1295 05fc FEFFFFEB 		bl	__assert_fail		@
 1296              	.LVL78:
 1297              	.L76:
 1298              		.align	2
 1299              	.L75:
 1300 0600 00000000 		.word	g_armwave_state
 1301 0604 34000000 		.word	.LANCHOR0+52
 1302 0608 41010000 		.word	321
 1303 060c 20000000 		.word	.LC2
 1304 0610 2C010000 		.word	.LC10
 1305              		.cfi_endproc
 1306              	.LFE62:
 1308              		.align	2
 1309              		.global	armwave_set_wave_pointer_as_testbuf
 1310              		.syntax unified
 1311              		.arm
 1312              		.fpu vfp
 1314              	armwave_set_wave_pointer_as_testbuf:
 1315              	.LVL79:
 1316              	.LFB63:
 323:armwave.c     **** }
 324:armwave.c     **** 
 325:armwave.c     **** /*
 326:armwave.c     ****  * Set the wave buffer pointer as the test waveform buffer filled by such functions
 327:armwave.c     ****  * as `armwave_test_create_square` and `armwave_test_create_am_sine`.
 328:armwave.c     ****  */
 329:armwave.c     **** void armwave_set_wave_pointer_as_testbuf(int set)
 330:armwave.c     **** {
 1317              		.loc 1 330 1 is_stmt 1 view -0
 1318              		.cfi_startproc
 1319              		@ args = 0, pretend = 0, frame = 0
 1320              		@ frame_needed = 0, uses_anonymous_args = 0
 1321              		@ link register save eliminated.
 331:armwave.c     ****     if(set > g_armwave_state.test_wave_buffer_nsets) {
 1322              		.loc 1 331 5 view .LVU347
 1323              	@ armwave.c:331:     if(set > g_armwave_state.test_wave_buffer_nsets) {
 1324              		.loc 1 331 29 is_stmt 0 view .LVU348
 1325 0614 24309FE5 		ldr	r3, .L80	@ tmp117,
 1326              	@ armwave.c:331:     if(set > g_armwave_state.test_wave_buffer_nsets) {
 1327              		.loc 1 331 7 view .LVU349
 1328 0618 202093E5 		ldr	r2, [r3, #32]	@ g_armwave_state.test_wave_buffer_nsets, g_armwave_state.test_wave_buffer_nsets
 1329 061c 000052E1 		cmp	r2, r0	@ g_armwave_state.test_wave_buffer_nsets, set
 1330 0620 0400003A 		bcc	.L79		@,
 332:armwave.c     ****         printf("armwave_set_wave_pointer_as_testbuf: error, nsets exceeded\n");
 333:armwave.c     ****         return;
 334:armwave.c     ****     }
 335:armwave.c     **** 
 336:armwave.c     ****     g_armwave_state.wave_buffer = g_armwave_state.test_wave_buffer + (g_armwave_state.test_wave_buf
 1331              		.loc 1 336 5 is_stmt 1 view .LVU350
 1332              	@ armwave.c:336:     g_armwave_state.wave_buffer = g_armwave_state.test_wave_buffer + (g_armwave_st
 1333              		.loc 1 336 111 is_stmt 0 view .LVU351
 1334 0624 1C1093E5 		ldr	r1, [r3, #28]	@ g_armwave_state.test_wave_buffer_stride, g_armwave_state.test_wave_buffer_stri
 1335              	@ armwave.c:336:     g_armwave_state.wave_buffer = g_armwave_state.test_wave_buffer + (g_armwave_st
 1336              		.loc 1 336 68 view .LVU352
 1337 0628 182093E5 		ldr	r2, [r3, #24]	@ g_armwave_state.test_wave_buffer, g_armwave_state.test_wave_buffer
 1338 062c 912020E0 		mla	r0, r1, r0, r2	@ tmp125, g_armwave_state.test_wave_buffer_stride, set, g_armwave_state.test_wa
 1339              	.LVL80:
 1340              	@ armwave.c:336:     g_armwave_state.wave_buffer = g_armwave_state.test_wave_buffer + (g_armwave_st
 1341              		.loc 1 336 33 view .LVU353
 1342 0630 140083E5 		str	r0, [r3, #20]	@ tmp125, g_armwave_state.wave_buffer
 1343              	@ armwave.c:337: }
 337:armwave.c     **** }
 1344              		.loc 1 337 1 view .LVU354
 1345 0634 1EFF2FE1 		bx	lr	@
 1346              	.LVL81:
 1347              	.L79:
 332:armwave.c     ****         printf("armwave_set_wave_pointer_as_testbuf: error, nsets exceeded\n");
 1348              		.loc 1 332 9 is_stmt 1 view .LVU355
 1349 0638 04009FE5 		ldr	r0, .L80+4	@,
 1350              	.LVL82:
 332:armwave.c     ****         printf("armwave_set_wave_pointer_as_testbuf: error, nsets exceeded\n");
 1351              		.loc 1 332 9 is_stmt 0 view .LVU356
 1352 063c FEFFFFEA 		b	puts		@
 1353              	.LVL83:
 1354              	.L81:
 1355              		.align	2
 1356              	.L80:
 1357 0640 00000000 		.word	g_armwave_state
 1358 0644 40010000 		.word	.LC11
 1359              		.cfi_endproc
 1360              	.LFE63:
 1362              		.align	2
 1363              		.global	armwave_set_wave_pointer_u32
 1364              		.syntax unified
 1365              		.arm
 1366              		.fpu vfp
 1368              	armwave_set_wave_pointer_u32:
 1369              	.LVL84:
 1370              	.LFB64:
 338:armwave.c     **** 
 339:armwave.c     **** /*
 340:armwave.c     ****  * Set wave buffer pointer from a 32-bit uint.  This needs to be changed to support 
 341:armwave.c     ****  * disjointed buffers in the future.
 342:armwave.c     ****  */
 343:armwave.c     **** void armwave_set_wave_pointer_u32(uint32_t wave_buffer_ptr)
 344:armwave.c     **** {
 1371              		.loc 1 344 1 is_stmt 1 view -0
 1372              		.cfi_startproc
 1373              		@ args = 0, pretend = 0, frame = 0
 1374              		@ frame_needed = 0, uses_anonymous_args = 0
 345:armwave.c     ****     assert(wave_buffer_ptr != 0);
 1375              		.loc 1 345 5 view .LVU358
 1376 0648 000050E3 		cmp	r0, #0	@ wave_buffer_ptr
 1377              		.loc 1 345 5 is_stmt 0 view .LVU359
 1378 064c 0200000A 		beq	.L87		@,
 346:armwave.c     ****     g_armwave_state.wave_buffer = (uint8_t*)wave_buffer_ptr;
 1379              		.loc 1 346 5 is_stmt 1 view .LVU360
 1380              	@ armwave.c:346:     g_armwave_state.wave_buffer = (uint8_t*)wave_buffer_ptr;
 1381              		.loc 1 346 33 is_stmt 0 view .LVU361
 1382 0650 1C309FE5 		ldr	r3, .L88	@ tmp117,
 1383 0654 140083E5 		str	r0, [r3, #20]	@ wave_buffer_ptr, g_armwave_state.wave_buffer
 1384 0658 1EFF2FE1 		bx	lr	@
 1385              	.L87:
 345:armwave.c     ****     assert(wave_buffer_ptr != 0);
 1386              		.loc 1 345 5 is_stmt 1 discriminator 1 view .LVU362
 1387              	@ armwave.c:344: {
 344:armwave.c     ****     assert(wave_buffer_ptr != 0);
 1388              		.loc 1 344 1 is_stmt 0 discriminator 1 view .LVU363
 1389 065c 10402DE9 		push	{r4, lr}	@
 1390              		.cfi_def_cfa_offset 8
 1391              		.cfi_offset 4, -8
 1392              		.cfi_offset 14, -4
 1393              	@ armwave.c:345:     assert(wave_buffer_ptr != 0);
 345:armwave.c     ****     assert(wave_buffer_ptr != 0);
 1394              		.loc 1 345 5 discriminator 1 view .LVU364
 1395 0660 10309FE5 		ldr	r3, .L88+4	@,
 1396 0664 10209FE5 		ldr	r2, .L88+8	@,
 1397 0668 10109FE5 		ldr	r1, .L88+12	@,
 1398 066c 10009FE5 		ldr	r0, .L88+16	@,
 1399              	.LVL85:
 345:armwave.c     ****     assert(wave_buffer_ptr != 0);
 1400              		.loc 1 345 5 discriminator 1 view .LVU365
 1401 0670 FEFFFFEB 		bl	__assert_fail		@
 1402              	.LVL86:
 1403              	.L89:
 1404              		.align	2
 1405              	.L88:
 1406 0674 00000000 		.word	g_armwave_state
 1407 0678 50000000 		.word	.LANCHOR0+80
 1408 067c 59010000 		.word	345
 1409 0680 20000000 		.word	.LC2
 1410 0684 7C010000 		.word	.LC12
 1411              		.cfi_endproc
 1412              	.LFE64:
 1414              		.align	2
 1415              		.global	armwave_clear_buffer
 1416              		.syntax unified
 1417              		.arm
 1418              		.fpu vfp
 1420              	armwave_clear_buffer:
 1421              	.LVL87:
 1422              	.LFB65:
 347:armwave.c     **** }
 348:armwave.c     **** 
 349:armwave.c     **** /*
 350:armwave.c     ****  * Clear the working buffer (fill it with all zeros.)
 351:armwave.c     ****  */
 352:armwave.c     **** void armwave_clear_buffer(uint32_t flags)
 353:armwave.c     **** {
 1423              		.loc 1 353 1 is_stmt 1 view -0
 1424              		.cfi_startproc
 1425              		@ args = 0, pretend = 0, frame = 0
 1426              		@ frame_needed = 0, uses_anonymous_args = 0
 1427              		@ link register save eliminated.
 354:armwave.c     ****     // Flags ignored, only one buffer cleared
 355:armwave.c     ****     memset(g_armwave_state.ch1_buffer, 0, g_armwave_state.ch_buff_size);
 1428              		.loc 1 355 5 view .LVU367
 1429              	@ armwave.c:355:     memset(g_armwave_state.ch1_buffer, 0, g_armwave_state.ch_buff_size);
 1430              		.loc 1 355 58 is_stmt 0 view .LVU368
 1431 0688 0C309FE5 		ldr	r3, .L91	@ tmp114,
 1432              	@ armwave.c:355:     memset(g_armwave_state.ch1_buffer, 0, g_armwave_state.ch_buff_size);
 1433              		.loc 1 355 5 view .LVU369
 1434 068c 0010A0E3 		mov	r1, #0	@,
 1435 0690 502093E5 		ldr	r2, [r3, #80]	@, g_armwave_state.ch_buff_size
 1436 0694 040093E5 		ldr	r0, [r3, #4]	@, g_armwave_state.ch1_buffer
 1437              	.LVL88:
 1438              		.loc 1 355 5 view .LVU370
 1439 0698 FEFFFFEA 		b	memset		@
 1440              	.LVL89:
 1441              	.L92:
 1442              		.align	2
 1443              	.L91:
 1444 069c 00000000 		.word	g_armwave_state
 1445              		.cfi_endproc
 1446              	.LFE65:
 1448              		.align	2
 1449              		.global	armwave_set_channel_colour
 1450              		.syntax unified
 1451              		.arm
 1452              		.fpu vfp
 1454              	armwave_set_channel_colour:
 1455              	.LVL90:
 1456              	.LFB66:
 356:armwave.c     **** }
 357:armwave.c     **** 
 358:armwave.c     **** /*
 359:armwave.c     ****  * Set the render colour for a channel.  R/G/B may exceed 255 for saturation effects.
 360:armwave.c     ****  */
 361:armwave.c     **** void armwave_set_channel_colour(int ch, int r, int g, int b)
 362:armwave.c     **** {
 1457              		.loc 1 362 1 is_stmt 1 view -0
 1458              		.cfi_startproc
 1459              		@ args = 0, pretend = 0, frame = 0
 1460              		@ frame_needed = 0, uses_anonymous_args = 0
 1461              		@ link register save eliminated.
 363:armwave.c     ****     // Only 1ch supported for now
 364:armwave.c     ****     switch(ch) {
 1462              		.loc 1 364 5 view .LVU372
 1463 06a0 010050E3 		cmp	r0, #1	@ ch,
 365:armwave.c     ****         case 1:
 366:armwave.c     ****             g_armwave_state.ch1_color.r = r;
 1464              		.loc 1 366 13 view .LVU373
 1465              	@ armwave.c:366:             g_armwave_state.ch1_color.r = r;
 1466              		.loc 1 366 41 is_stmt 0 view .LVU374
 1467 06a4 0C009F05 		ldreq	r0, .L95	@ tmp117,
 1468              	.LVL91:
 1469              		.loc 1 366 41 view .LVU375
 1470 06a8 BC16C001 		strheq	r1, [r0, #108]	@ movhi	@ r, g_armwave_state.ch1_color.r
 367:armwave.c     ****             g_armwave_state.ch1_color.g = g;
 1471              		.loc 1 367 13 is_stmt 1 view .LVU376
 1472              	@ armwave.c:367:             g_armwave_state.ch1_color.g = g;
 1473              		.loc 1 367 41 is_stmt 0 view .LVU377
 1474 06ac BE26C001 		strheq	r2, [r0, #110]	@ movhi	@ g, g_armwave_state.ch1_color.g
 368:armwave.c     ****             g_armwave_state.ch1_color.b = b;
 1475              		.loc 1 368 13 is_stmt 1 view .LVU378
 1476              	@ armwave.c:368:             g_armwave_state.ch1_color.b = b;
 1477              		.loc 1 368 41 is_stmt 0 view .LVU379
 1478 06b0 B037C001 		strheq	r3, [r0, #112]	@ movhi	@ b, g_armwave_state.ch1_color.b
 369:armwave.c     ****             break;
 1479              		.loc 1 369 13 is_stmt 1 view .LVU380
 1480              	@ armwave.c:371: }
 370:armwave.c     ****     }
 371:armwave.c     **** }
 1481              		.loc 1 371 1 is_stmt 0 view .LVU381
 1482 06b4 1EFF2FE1 		bx	lr	@
 1483              	.L96:
 1484              		.align	2
 1485              	.L95:
 1486 06b8 00000000 		.word	g_armwave_state
 1487              		.cfi_endproc
 1488              	.LFE66:
 1490              		.align	2
 1491              		.global	armwave_dump_ppm_debug
 1492              		.syntax unified
 1493              		.arm
 1494              		.fpu vfp
 1496              	armwave_dump_ppm_debug:
 1497              	.LVL92:
 1498              	.LFB67:
 372:armwave.c     **** 
 373:armwave.c     **** /*
 374:armwave.c     ****  * Dump a ppm of a buffer to a file.
 375:armwave.c     ****  */
 376:armwave.c     **** void armwave_dump_ppm_debug(uint32_t *buffer, char *fn)
 377:armwave.c     **** {
 1499              		.loc 1 377 1 is_stmt 1 view -0
 1500              		.cfi_startproc
 1501              		@ args = 0, pretend = 0, frame = 0
 1502              		@ frame_needed = 0, uses_anonymous_args = 0
 378:armwave.c     ****     FILE *fp = fopen(fn, "wb");
 1503              		.loc 1 378 5 view .LVU383
 1504              	@ armwave.c:377: {
 377:armwave.c     ****     FILE *fp = fopen(fn, "wb");
 1505              		.loc 1 377 1 is_stmt 0 view .LVU384
 1506 06bc 0130A0E1 		mov	r3, r1	@ fn, fn
 1507 06c0 F0432DE9 		push	{r4, r5, r6, r7, r8, r9, lr}	@
 1508              		.cfi_def_cfa_offset 28
 1509              		.cfi_offset 4, -28
 1510              		.cfi_offset 5, -24
 1511              		.cfi_offset 6, -20
 1512              		.cfi_offset 7, -16
 1513              		.cfi_offset 8, -12
 1514              		.cfi_offset 9, -8
 1515              		.cfi_offset 14, -4
 1516 06c4 0080A0E1 		mov	r8, r0	@ buffer, buffer
 1517 06c8 0CD04DE2 		sub	sp, sp, #12	@,,
 1518              		.cfi_def_cfa_offset 40
 1519              	@ armwave.c:378:     FILE *fp = fopen(fn, "wb");
 1520              		.loc 1 378 16 view .LVU385
 1521 06cc C4109FE5 		ldr	r1, .L105	@,
 1522              	.LVL93:
 1523              		.loc 1 378 16 view .LVU386
 1524 06d0 0300A0E1 		mov	r0, r3	@, fn
 1525              	.LVL94:
 1526              		.loc 1 378 16 view .LVU387
 1527 06d4 FEFFFFEB 		bl	fopen64		@
 1528              	.LVL95:
 1529              	@ armwave.c:385:     fprintf(fp, "%d %d\n", g_armwave_state.target_width, g_armwave_state.target_he
 379:armwave.c     ****     uint32_t data;
 380:armwave.c     ****     int xx, yy;
 381:armwave.c     **** 
 382:armwave.c     ****     //printf("in_buffer=0x%08x\n", buffer);
 383:armwave.c     **** 
 384:armwave.c     ****     fputs("P3\n", fp);
 385:armwave.c     ****     fprintf(fp, "%d %d\n", g_armwave_state.target_width, g_armwave_state.target_height);
 1530              		.loc 1 385 5 view .LVU388
 1531 06d8 BC609FE5 		ldr	r6, .L105+4	@ tmp150,
 1532              	@ armwave.c:384:     fputs("P3\n", fp);
 384:armwave.c     ****     fprintf(fp, "%d %d\n", g_armwave_state.target_width, g_armwave_state.target_height);
 1533              		.loc 1 384 5 view .LVU389
 1534 06dc 0320A0E3 		mov	r2, #3	@,
 1535 06e0 0110A0E3 		mov	r1, #1	@,
 1536              	@ armwave.c:378:     FILE *fp = fopen(fn, "wb");
 378:armwave.c     ****     uint32_t data;
 1537              		.loc 1 378 16 view .LVU390
 1538 06e4 0070A0E1 		mov	r7, r0	@ fp,
 1539              	.LVL96:
 379:armwave.c     ****     uint32_t data;
 1540              		.loc 1 379 5 is_stmt 1 view .LVU391
 380:armwave.c     **** 
 1541              		.loc 1 380 5 view .LVU392
 384:armwave.c     ****     fprintf(fp, "%d %d\n", g_armwave_state.target_width, g_armwave_state.target_height);
 1542              		.loc 1 384 5 view .LVU393
 1543 06e8 0030A0E1 		mov	r3, r0	@, fp
 1544 06ec AC009FE5 		ldr	r0, .L105+8	@,
 1545              	.LVL97:
 384:armwave.c     ****     fprintf(fp, "%d %d\n", g_armwave_state.target_width, g_armwave_state.target_height);
 1546              		.loc 1 384 5 is_stmt 0 view .LVU394
 1547 06f0 FEFFFFEB 		bl	fwrite		@
 1548              	.LVL98:
 1549              		.loc 1 385 5 is_stmt 1 view .LVU395
 1550 06f4 D825C6E1 		ldrd	r2, [r6, #88]	@, tmp150,
 1551 06f8 A4109FE5 		ldr	r1, .L105+12	@,
 1552 06fc 0700A0E1 		mov	r0, r7	@, fp
 1553 0700 FEFFFFEB 		bl	fprintf		@
 1554              	.LVL99:
 386:armwave.c     ****     fputs("255\n", fp);
 1555              		.loc 1 386 5 view .LVU396
 1556 0704 0420A0E3 		mov	r2, #4	@,
 1557 0708 0730A0E1 		mov	r3, r7	@, fp
 1558 070c 0110A0E3 		mov	r1, #1	@,
 1559 0710 90009FE5 		ldr	r0, .L105+16	@,
 1560 0714 FEFFFFEB 		bl	fwrite		@
 1561              	.LVL100:
 387:armwave.c     **** 
 388:armwave.c     ****     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 1562              		.loc 1 388 5 view .LVU397
 1563              	@ armwave.c:388:     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 1564              		.loc 1 388 37 is_stmt 0 view .LVU398
 1565 0718 5C2096E5 		ldr	r2, [r6, #92]	@ prephitmp_53, g_armwave_state.target_height
 1566              	@ armwave.c:388:     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 1567              		.loc 1 388 5 view .LVU399
 1568 071c 000052E3 		cmp	r2, #0	@ prephitmp_53,
 1569 0720 180000DA 		ble	.L98		@,
 1570 0724 583096E5 		ldr	r3, [r6, #88]	@ _13, g_armwave_state.target_width
 1571              	@ armwave.c:393:             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >>
 389:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 390:armwave.c     ****             data = *(buffer + (xx + (yy * g_armwave_state.target_width)));
 391:armwave.c     ****             //printf("xx,yy=%4d,%4d, word=0x%08x\n", xx, yy, data);
 392:armwave.c     **** 
 393:armwave.c     ****             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >> 16) & 0xff);
 1572              		.loc 1 393 13 view .LVU400
 1573 0728 7C909FE5 		ldr	r9, .L105+20	@ tmp152,
 1574              	@ armwave.c:388:     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 388:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1575              		.loc 1 388 12 view .LVU401
 1576 072c 0050A0E3 		mov	r5, #0	@ yy,
 1577              	.LVL101:
 1578              	.L99:
 1579              	@ armwave.c:389:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 389:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1580              		.loc 1 389 9 view .LVU402
 1581 0730 000053E3 		cmp	r3, #0	@ _13,
 1582              	@ armwave.c:389:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 389:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1583              		.loc 1 389 16 view .LVU403
 1584 0734 0040A0C3 		movgt	r4, #0	@ xx,
 1585              	@ armwave.c:389:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 389:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1586              		.loc 1 389 9 view .LVU404
 1587 0738 0F0000DA 		ble	.L101		@,
 1588              	.LVL102:
 1589              	.L100:
 390:armwave.c     ****             //printf("xx,yy=%4d,%4d, word=0x%08x\n", xx, yy, data);
 1590              		.loc 1 390 13 is_stmt 1 discriminator 3 view .LVU405
 1591              	@ armwave.c:390:             data = *(buffer + (xx + (yy * g_armwave_state.target_width)));
 390:armwave.c     ****             //printf("xx,yy=%4d,%4d, word=0x%08x\n", xx, yy, data);
 1592              		.loc 1 390 29 is_stmt 0 discriminator 3 view .LVU406
 1593 073c 954323E0 		mla	r3, r5, r3, r4	@ tmp141, yy, _13, xx
 1594              	@ armwave.c:393:             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >>
 1595              		.loc 1 393 13 discriminator 3 view .LVU407
 1596 0740 0910A0E1 		mov	r1, r9	@, tmp152
 1597 0744 0700A0E1 		mov	r0, r7	@, fp
 1598              	@ armwave.c:390:             data = *(buffer + (xx + (yy * g_armwave_state.target_width)));
 390:armwave.c     ****             //printf("xx,yy=%4d,%4d, word=0x%08x\n", xx, yy, data);
 1599              		.loc 1 390 18 discriminator 3 view .LVU408
 1600 0748 032198E7 		ldr	r2, [r8, r3, lsl #2]	@ data, *_7
 1601              	.LVL103:
 1602              		.loc 1 393 13 is_stmt 1 discriminator 3 view .LVU409
 1603              	@ armwave.c:389:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 389:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1604              		.loc 1 389 58 is_stmt 0 discriminator 3 view .LVU410
 1605 074c 014084E2 		add	r4, r4, #1	@ xx, xx,
 1606              	.LVL104:
 1607              	@ armwave.c:393:             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >>
 1608              		.loc 1 393 81 discriminator 3 view .LVU411
 1609 0750 22C8A0E1 		lsr	ip, r2, #16	@ tmp146, data,
 1610              	@ armwave.c:393:             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >>
 1611              		.loc 1 393 61 discriminator 3 view .LVU412
 1612 0754 2234A0E1 		lsr	r3, r2, #8	@ tmp142, data,
 1613              	@ armwave.c:393:             fprintf(fp, "%3d %3d %3d\n", data & 0xff, (data >> 8) & 0xff, (data >>
 1614              		.loc 1 393 13 discriminator 3 view .LVU413
 1615 0758 7CC0EFE6 		uxtb	ip, ip	@ tmp147, tmp146
 1616 075c 7330EFE6 		uxtb	r3, r3	@, tmp142
 1617 0760 00C08DE5 		str	ip, [sp]	@ tmp147,
 1618 0764 7220EFE6 		uxtb	r2, r2	@, data
 1619              	.LVL105:
 1620              		.loc 1 393 13 discriminator 3 view .LVU414
 1621 0768 FEFFFFEB 		bl	fprintf		@
 1622              	.LVL106:
 1623              	@ armwave.c:389:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 389:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1624              		.loc 1 389 41 discriminator 3 view .LVU415
 1625 076c 583096E5 		ldr	r3, [r6, #88]	@ _13, g_armwave_state.target_width
 1626              	@ armwave.c:389:         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 389:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1627              		.loc 1 389 9 discriminator 3 view .LVU416
 1628 0770 040053E1 		cmp	r3, r4	@ _13, xx
 1629 0774 F0FFFFCA 		bgt	.L100		@,
 1630 0778 5C2096E5 		ldr	r2, [r6, #92]	@ prephitmp_53, g_armwave_state.target_height
 1631              	.LVL107:
 1632              	.L101:
 1633              	@ armwave.c:388:     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 388:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1634              		.loc 1 388 55 discriminator 2 view .LVU417
 1635 077c 015085E2 		add	r5, r5, #1	@ yy, yy,
 1636              	.LVL108:
 1637              	@ armwave.c:388:     for(yy = 0; yy < g_armwave_state.target_height; yy++) {
 388:armwave.c     ****         for(xx = 0; xx < g_armwave_state.target_width; xx++) {
 1638              		.loc 1 388 5 discriminator 2 view .LVU418
 1639 0780 020055E1 		cmp	r5, r2	@ yy, prephitmp_53
 1640 0784 E9FFFFBA 		blt	.L99		@,
 1641              	.LVL109:
 1642              	.L98:
 394:armwave.c     ****         }
 395:armwave.c     ****     }
 396:armwave.c     **** 
 397:armwave.c     ****     fclose(fp);
 1643              		.loc 1 397 5 is_stmt 1 view .LVU419
 1644 0788 0700A0E1 		mov	r0, r7	@, fp
 1645              	@ armwave.c:398: }
 398:armwave.c     **** }
 1646              		.loc 1 398 1 is_stmt 0 view .LVU420
 1647 078c 0CD08DE2 		add	sp, sp, #12	@,,
 1648              		.cfi_def_cfa_offset 28
 1649              		@ sp needed	@
 1650 0790 F043BDE8 		pop	{r4, r5, r6, r7, r8, r9, lr}	@
 1651              		.cfi_restore 14
 1652              		.cfi_restore 9
 1653              		.cfi_restore 8
 1654              		.cfi_restore 7
 1655              		.cfi_restore 6
 1656              		.cfi_restore 5
 1657              		.cfi_restore 4
 1658              		.cfi_def_cfa_offset 0
 1659              	.LVL110:
 1660              	@ armwave.c:397:     fclose(fp);
 397:armwave.c     **** }
 1661              		.loc 1 397 5 view .LVU421
 1662 0794 FEFFFFEA 		b	fclose		@
 1663              	.LVL111:
 1664              	.L106:
 397:armwave.c     **** }
 1665              		.loc 1 397 5 view .LVU422
 1666              		.align	2
 1667              	.L105:
 1668 0798 94010000 		.word	.LC13
 1669 079c 00000000 		.word	g_armwave_state
 1670 07a0 98010000 		.word	.LC14
 1671 07a4 9C010000 		.word	.LC15
 1672 07a8 A4010000 		.word	.LC16
 1673 07ac AC010000 		.word	.LC17
 1674              		.cfi_endproc
 1675              	.LFE67:
 1677              		.align	2
 1678              		.global	armwave_test_init
 1679              		.syntax unified
 1680              		.arm
 1681              		.fpu vfp
 1683              	armwave_test_init:
 1684              	.LVL112:
 1685              	.LFB68:
 399:armwave.c     **** 
 400:armwave.c     **** /*
 401:armwave.c     ****  * Initialise some test functionry.
 402:armwave.c     ****  */
 403:armwave.c     **** void armwave_test_init(int wave_size, int nwaves, int render_width, int render_height)
 404:armwave.c     **** {
 1686              		.loc 1 404 1 is_stmt 1 view -0
 1687              		.cfi_startproc
 1688              		@ args = 0, pretend = 0, frame = 0
 1689              		@ frame_needed = 0, uses_anonymous_args = 0
 405:armwave.c     ****     test_create_gamma();
 1690              		.loc 1 405 5 view .LVU424
 1691              	.LBB12:
 1692              	.LBI12:
  34:armwave.c     **** {
 1693              		.loc 1 34 6 view .LVU425
  34:armwave.c     **** {
 1694              		.loc 1 34 6 is_stmt 0 view .LVU426
 1695              	.LBE12:
 1696              	@ armwave.c:404: {
 404:armwave.c     ****     test_create_gamma();
 1697              		.loc 1 404 1 view .LVU427
 1698 07b0 F0472DE9 		push	{r4, r5, r6, r7, r8, r9, r10, lr}	@
 1699              		.cfi_def_cfa_offset 32
 1700              		.cfi_offset 4, -32
 1701              		.cfi_offset 5, -28
 1702              		.cfi_offset 6, -24
 1703              		.cfi_offset 7, -20
 1704              		.cfi_offset 8, -16
 1705              		.cfi_offset 9, -12
 1706              		.cfi_offset 10, -8
 1707              		.cfi_offset 14, -4
 1708 07b4 068B2DED 		vpush.64	{d8, d9, d10}	@
 1709              		.cfi_def_cfa_offset 56
 1710              		.cfi_offset 80, -56
 1711              		.cfi_offset 81, -52
 1712              		.cfi_offset 82, -48
 1713              		.cfi_offset 83, -44
 1714              		.cfi_offset 84, -40
 1715              		.cfi_offset 85, -36
 1716 07b8 BC409FE5 		ldr	r4, .L111+20	@ ivtmp.79,
 1717              	.LBB15:
 1718              	.LBB13:
 1719              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1720              		.loc 1 40 32 view .LVU428
 1721 07bc 2DAA9FED 		vldr.32	s20, .L111+16	@ tmp136,
 1722              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1723              		.loc 1 40 26 view .LVU429
 1724 07c0 289B9FED 		vldr.64	d9, .L111	@ tmp151,
 1725              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1726              		.loc 1 40 49 view .LVU430
 1727 07c4 298B9FED 		vldr.64	d8, .L111+8	@ tmp139,
 1728 07c8 01C084E2 		add	ip, r4, #1	@ _38, ivtmp.79,
 1729              	.LBE13:
 1730              	.LBE15:
 1731              	@ armwave.c:404: {
 404:armwave.c     ****     test_create_gamma();
 1732              		.loc 1 404 1 view .LVU431
 1733 07cc 10D04DE2 		sub	sp, sp, #16	@,,
 1734              		.cfi_def_cfa_offset 72
 1735              	@ armwave.c:404: {
 404:armwave.c     ****     test_create_gamma();
 1736              		.loc 1 404 1 view .LVU432
 1737 07d0 0060A0E1 		mov	r6, r0	@ wave_size, wave_size
 1738 07d4 0170A0E1 		mov	r7, r1	@ nwaves, nwaves
 1739 07d8 0280A0E1 		mov	r8, r2	@ render_width, render_width
 1740 07dc 0390A0E1 		mov	r9, r3	@ render_height, render_height
 1741 07e0 01AC84E2 		add	r10, r4, #256	@ _39, ivtmp.79,
 1742 07e4 01506CE2 		rsb	r5, ip, #1	@ tmp150, _38,
 1743              	.LVL113:
 1744              	.L108:
 1745              	.LBB16:
 1746              	.LBB14:
  40:armwave.c     ****     }
 1747              		.loc 1 40 9 is_stmt 1 view .LVU433
 1748              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1749              		.loc 1 40 32 is_stmt 0 view .LVU434
 1750 07e8 043085E0 		add	r3, r5, r4	@ tmp133, tmp150, ivtmp.79
 1751              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1752              		.loc 1 40 26 view .LVU435
 1753 07ec 491BB0EE 		vmov.f64	d1, d9	@, tmp151
 1754              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1755              		.loc 1 40 32 view .LVU436
 1756 07f0 903A07EE 		vmov	s15, r3	@ int	@ tmp133, tmp133
 1757 07f4 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp134, tmp133
 1758 07f8 8A0A87EE 		vdiv.f32	s0, s15, s20	@ tmp135, tmp134, tmp136
 1759              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1760              		.loc 1 40 26 view .LVU437
 1761 07fc C00AB7EE 		vcvt.f64.f32	d0, s0	@, tmp135
 1762 0800 FEFFFFEB 		bl	pow		@
 1763              	.LVL114:
 1764              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1765              		.loc 1 40 49 view .LVU438
 1766 0804 080B20EE 		vmul.f64	d0, d0, d8	@ tmp138,, tmp139
 1767              	@ armwave.c:40:         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
  40:armwave.c     ****     }
 1768              		.loc 1 40 24 view .LVU439
 1769 0808 C07BFCEE 		vcvt.u32.f64	s15, d0	@ tmp140, tmp138
 1770 080c 900A17EE 		vmov	r0, s15	@ int	@ tmp140, tmp140
 1771 0810 0100E4E5 		strb	r0, [r4, #1]!	@ tmp140, MEM[base: _37, offset: 0B]
 1772              	.LVL115:
 1773              	@ armwave.c:39:     for(i = 0; i < 256; i++) {
  39:armwave.c     ****         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 1774              		.loc 1 39 5 view .LVU440
 1775 0814 0A0054E1 		cmp	r4, r10	@ ivtmp.79, _39
 1776 0818 F2FFFF1A 		bne	.L108		@,
 1777              	.LVL116:
  39:armwave.c     ****         gamma_table[i] = pow(i / 255.0f, gamma) * 255.0f;
 1778              		.loc 1 39 5 view .LVU441
 1779              	.LBE14:
 1780              	.LBE16:
 406:armwave.c     **** 
 407:armwave.c     ****     // make ch1 yellowish by default
 408:armwave.c     ****     armwave_set_channel_colour(1, 2550, 1780, 250);
 1781              		.loc 1 408 5 is_stmt 1 view .LVU442
 1782              	.LBB17:
 1783              	.LBI17:
 361:armwave.c     **** {
 1784              		.loc 1 361 6 view .LVU443
 1785              	.LBB18:
 364:armwave.c     ****         case 1:
 1786              		.loc 1 364 5 view .LVU444
 366:armwave.c     ****             g_armwave_state.ch1_color.g = g;
 1787              		.loc 1 366 13 view .LVU445
 367:armwave.c     ****             g_armwave_state.ch1_color.b = b;
 1788              		.loc 1 367 13 view .LVU446
 1789              	@ armwave.c:366:             g_armwave_state.ch1_color.r = r;
 366:armwave.c     ****             g_armwave_state.ch1_color.g = g;
 1790              		.loc 1 366 41 is_stmt 0 view .LVU447
 1791 081c 5CC09FE5 		ldr	ip, .L111+24	@ tmp142,
 1792 0820 5C409FE5 		ldr	r4, .L111+28	@ tmp143,
 1793              	.LBE18:
 1794              	.LBE17:
 1795              	@ armwave.c:410:     armwave_setup_render(0, wave_size, nwaves, wave_size, render_width, render_hei
 409:armwave.c     **** 
 410:armwave.c     ****     armwave_setup_render(0, wave_size, nwaves, wave_size, render_width, render_height, 0x00000000);
 1796              		.loc 1 410 5 view .LVU448
 1797 0824 0000A0E3 		mov	r0, #0	@ tmp147,
 1798              	.LBB22:
 1799              	.LBB19:
 1800              	@ armwave.c:368:             g_armwave_state.ch1_color.b = b;
 368:armwave.c     ****             break;
 1801              		.loc 1 368 41 view .LVU449
 1802 0828 FAE0A0E3 		mov	lr, #250	@ tmp146,
 1803              	.LBE19:
 1804              	.LBE22:
 1805              	@ armwave.c:410:     armwave_setup_render(0, wave_size, nwaves, wave_size, render_width, render_hei
 1806              		.loc 1 410 5 view .LVU450
 1807 082c 08008DE5 		str	r0, [sp, #8]	@ tmp147,
 1808 0830 04908DE5 		str	r9, [sp, #4]	@ render_height,
 1809 0834 00808DE5 		str	r8, [sp]	@ render_width,
 1810 0838 0610A0E1 		mov	r1, r6	@, tmp3
 1811 083c 0720A0E1 		mov	r2, r7	@, nwaves
 1812              	.LBB23:
 1813              	.LBB20:
 1814              	@ armwave.c:366:             g_armwave_state.ch1_color.r = r;
 366:armwave.c     ****             g_armwave_state.ch1_color.g = g;
 1815              		.loc 1 366 41 view .LVU451
 1816 0840 6C408CE5 		str	r4, [ip, #108]	@ tmp143, MEM[(short int *)&g_armwave_state + 108B]
 368:armwave.c     ****             break;
 1817              		.loc 1 368 13 is_stmt 1 view .LVU452
 1818              	.LBE20:
 1819              	.LBE23:
 1820              	@ armwave.c:410:     armwave_setup_render(0, wave_size, nwaves, wave_size, render_width, render_hei
 1821              		.loc 1 410 5 is_stmt 0 view .LVU453
 1822 0844 0630A0E1 		mov	r3, r6	@, wave_size
 1823              	.LBB24:
 1824              	.LBB21:
 1825              	@ armwave.c:368:             g_armwave_state.ch1_color.b = b;
 368:armwave.c     ****             break;
 1826              		.loc 1 368 41 view .LVU454
 1827 0848 B0E7CCE1 		strh	lr, [ip, #112]	@ movhi	@ tmp146, g_armwave_state.ch1_color.b
 369:armwave.c     ****     }
 1828              		.loc 1 369 13 is_stmt 1 view .LVU455
 1829              	.LVL117:
 369:armwave.c     ****     }
 1830              		.loc 1 369 13 is_stmt 0 view .LVU456
 1831              	.LBE21:
 1832              	.LBE24:
 1833              		.loc 1 410 5 is_stmt 1 view .LVU457
 1834 084c FEFFFFEB 		bl	armwave_setup_render		@
 1835              	.LVL118:
 411:armwave.c     **** 
 412:armwave.c     ****     printf("armwave version: %s\n", ARMWAVE_VER);
 1836              		.loc 1 412 5 view .LVU458
 1837 0850 30109FE5 		ldr	r1, .L111+32	@,
 1838 0854 30009FE5 		ldr	r0, .L111+36	@,
 1839              	@ armwave.c:413: }
 413:armwave.c     **** }
 1840              		.loc 1 413 1 is_stmt 0 view .LVU459
 1841 0858 10D08DE2 		add	sp, sp, #16	@,,
 1842              		.cfi_def_cfa_offset 56
 1843              		@ sp needed	@
 1844 085c 068BBDEC 		vldm	sp!, {d8-d10}	@,
 1845              		.cfi_restore 84
 1846              		.cfi_restore 85
 1847              		.cfi_restore 82
 1848              		.cfi_restore 83
 1849              		.cfi_restore 80
 1850              		.cfi_restore 81
 1851              		.cfi_def_cfa_offset 32
 1852 0860 F047BDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, lr}	@
 1853              		.cfi_restore 14
 1854              		.cfi_restore 10
 1855              		.cfi_restore 9
 1856              		.cfi_restore 8
 1857              		.cfi_restore 7
 1858              		.cfi_restore 6
 1859              		.cfi_restore 5
 1860              		.cfi_restore 4
 1861              		.cfi_def_cfa_offset 0
 1862              	.LVL119:
 1863              	@ armwave.c:412:     printf("armwave version: %s\n", ARMWAVE_VER);
 412:armwave.c     **** }
 1864              		.loc 1 412 5 view .LVU460
 1865 0864 FEFFFFEA 		b	printf		@
 1866              	.LVL120:
 1867              	.L112:
 1868              		.align	3
 1869              	.L111:
 1870 0868 000000C0 		.word	-1073741824
 1871 086c CCCCEC3F 		.word	1072483532
 1872 0870 00000000 		.word	0
 1873 0874 00E06F40 		.word	1081073664
 1874 0878 00007F43 		.word	1132396544
 1875 087c FFFFFFFF 		.word	gamma_table-1
 1876 0880 00000000 		.word	g_armwave_state
 1877 0884 F609F406 		.word	116656630
 1878 0888 00000000 		.word	.LC0
 1879 088c 08000000 		.word	.LC1
 1880              		.cfi_endproc
 1881              	.LFE68:
 1883              		.global	__aeabi_idiv
 1884              		.align	2
 1885              		.global	armwave_test_generate
 1886              		.syntax unified
 1887              		.arm
 1888              		.fpu vfp
 1890              	armwave_test_generate:
 1891              	.LFB69:
 414:armwave.c     **** 
 415:armwave.c     **** /*
 416:armwave.c     ****  * Fill buffers with test funtionry.
 417:armwave.c     ****  */
 418:armwave.c     **** void armwave_test_generate()
 419:armwave.c     **** {
 1892              		.loc 1 419 1 is_stmt 1 view -0
 1893              		.cfi_startproc
 1894              		@ args = 0, pretend = 0, frame = 32
 1895              		@ frame_needed = 0, uses_anonymous_args = 0
 420:armwave.c     ****     uint32_t yy;
 1896              		.loc 1 420 5 view .LVU462
 421:armwave.c     ****     uint32_t xx_rem = g_armwave_state.target_width, ypos = 0;
 1897              		.loc 1 421 5 view .LVU463
 1898              	@ armwave.c:419: {
 419:armwave.c     ****     uint32_t yy;
 1899              		.loc 1 419 1 is_stmt 0 view .LVU464
 1900 0890 F04F2DE9 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}	@
 1901              		.cfi_def_cfa_offset 36
 1902              		.cfi_offset 4, -36
 1903              		.cfi_offset 5, -32
 1904              		.cfi_offset 6, -28
 1905              		.cfi_offset 7, -24
 1906              		.cfi_offset 8, -20
 1907              		.cfi_offset 9, -16
 1908              		.cfi_offset 10, -12
 1909              		.cfi_offset 11, -8
 1910              		.cfi_offset 14, -4
 1911 0894 24D04DE2 		sub	sp, sp, #36	@,,
 1912              		.cfi_def_cfa_offset 72
 1913              	@ armwave.c:421:     uint32_t xx_rem = g_armwave_state.target_width, ypos = 0;
 1914              		.loc 1 421 38 view .LVU465
 1915 0898 3C929FE5 		ldr	r9, .L132	@ tmp315,
 1916              	@ armwave.c:423:     memset(g_armwave_state.ch1_buffer, 0, g_armwave_state.ch_buff_size);
 422:armwave.c     **** 
 423:armwave.c     ****     memset(g_armwave_state.ch1_buffer, 0, g_armwave_state.ch_buff_size);
 1917              		.loc 1 423 5 view .LVU466
 1918 089c 0010A0E3 		mov	r1, #0	@,
 1919              	@ armwave.c:421:     uint32_t xx_rem = g_armwave_state.target_width, ypos = 0;
 421:armwave.c     **** 
 1920              		.loc 1 421 14 view .LVU467
 1921 08a0 583099E5 		ldr	r3, [r9, #88]	@ xx_rem, g_armwave_state.target_width
 1922              	@ armwave.c:423:     memset(g_armwave_state.ch1_buffer, 0, g_armwave_state.ch_buff_size);
 1923              		.loc 1 423 5 view .LVU468
 1924 08a4 502099E5 		ldr	r2, [r9, #80]	@, g_armwave_state.ch_buff_size
 1925 08a8 040099E5 		ldr	r0, [r9, #4]	@, g_armwave_state.ch1_buffer
 1926              	@ armwave.c:421:     uint32_t xx_rem = g_armwave_state.target_width, ypos = 0;
 421:armwave.c     **** 
 1927              		.loc 1 421 14 view .LVU469
 1928 08ac 10308DE5 		str	r3, [sp, #16]	@ xx_rem, %sfp
 1929              	.LVL121:
 1930              		.loc 1 423 5 is_stmt 1 view .LVU470
 1931 08b0 FEFFFFEB 		bl	memset		@
 1932              	.LVL122:
 424:armwave.c     **** 
 425:armwave.c     ****     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height); yy++) {
 1933              		.loc 1 425 5 view .LVU471
 1934              	@ armwave.c:425:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 1935              		.loc 1 425 38 is_stmt 0 view .LVU472
 1936 08b4 584099E5 		ldr	r4, [r9, #88]	@ prephitmp_218, g_armwave_state.target_width
 1937              	@ armwave.c:425:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 1938              		.loc 1 425 69 view .LVU473
 1939 08b8 446099E5 		ldr	r6, [r9, #68]	@ _43, g_armwave_state.slice_height
 1940              	@ armwave.c:425:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 1941              		.loc 1 425 52 view .LVU474
 1942 08bc 0400A0E1 		mov	r0, r4	@, prephitmp_218
 1943 08c0 0610A0E1 		mov	r1, r6	@, _43
 1944 08c4 FEFFFFEB 		bl	__aeabi_idiv		@
 1945              	.LVL123:
 1946              	@ armwave.c:425:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 1947              		.loc 1 425 5 view .LVU475
 1948 08c8 000050E3 		cmp	r0, #0	@ tmp225
 1949 08cc 7D00000A 		beq	.L124		@,
 1950 08d0 385099E5 		ldr	r5, [r9, #56]	@ prephitmp_227, g_armwave_state.waves
 1951              	@ armwave.c:421:     uint32_t xx_rem = g_armwave_state.target_width, ypos = 0;
 421:armwave.c     **** 
 1952              		.loc 1 421 53 view .LVU476
 1953 08d4 0030A0E3 		mov	r3, #0	@ ypos,
 1954 08d8 14308DE5 		str	r3, [sp, #20]	@ ypos, %sfp
 1955              	@ armwave.c:425:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 1956              		.loc 1 425 12 view .LVU477
 1957 08dc 0C308DE5 		str	r3, [sp, #12]	@ yy, %sfp
 1958              	.LVL124:
 1959              	.L122:
 426:armwave.c     ****         //printf("armwave_test_generate: slice %d (y=%d, h=%d)\n", yy, yy * g_armwave_state.slice_h
 427:armwave.c     **** 
 428:armwave.c     ****         render_nonaa_to_buffer_1ch_slice(yy * g_armwave_state.slice_height, g_armwave_state.slice_r
 1960              		.loc 1 428 9 is_stmt 1 discriminator 3 view .LVU478
 1961 08e0 0C309DE5 		ldr	r3, [sp, #12]	@ yy, %sfp
 1962              	.LBB27:
 1963              	.LBB28:
 1964              	@ armwave.c:71:     write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.cmp
  71:armwave.c     **** 
 1965              		.loc 1 71 63 is_stmt 0 discriminator 3 view .LVU479
 1966 08e4 242099E5 		ldr	r2, [r9, #36]	@ g_armwave_state.cmp_x_bitdepth_scale, g_armwave_state.cmp_x_bitdepth_scale
 1967              	.LBE28:
 1968              	.LBE27:
 1969              	@ armwave.c:428:         render_nonaa_to_buffer_1ch_slice(yy * g_armwave_state.slice_height, g_armw
 1970              		.loc 1 428 9 discriminator 3 view .LVU480
 1971 08e8 481099E5 		ldr	r1, [r9, #72]	@ _9, g_armwave_state.slice_record_height
 1972 08ec 930603E0 		mul	r3, r3, r6	@ _7, yy, _43
 1973              	.LBB31:
 1974              	.LBB29:
 1975              	@ armwave.c:74:     for(w = 0; w < g_armwave_state.waves; w++) {
  74:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 1976              		.loc 1 74 5 discriminator 3 view .LVU481
 1977 08f0 000055E3 		cmp	r5, #0	@ prephitmp_227,
 1978              	.LBE29:
 1979              	.LBE31:
 1980              	@ armwave.c:428:         render_nonaa_to_buffer_1ch_slice(yy * g_armwave_state.slice_height, g_armw
 1981              		.loc 1 428 9 discriminator 3 view .LVU482
 1982 08f4 08108DE5 		str	r1, [sp, #8]	@ _9, %sfp
 1983              	.LVL125:
 1984              	.LBB32:
 1985              	.LBI27:
  62:armwave.c     **** {
 1986              		.loc 1 62 6 is_stmt 1 discriminator 3 view .LVU483
 1987              	.LBB30:
  64:armwave.c     ****     uint32_t value, word;
 1988              		.loc 1 64 5 discriminator 3 view .LVU484
  65:armwave.c     ****     uint8_t *wave_base;
 1989              		.loc 1 65 5 discriminator 3 view .LVU485
  66:armwave.c     ****     uint8_t *write_buffer_base;
 1990              		.loc 1 66 5 discriminator 3 view .LVU486
  67:armwave.c     ****     uint8_t *write_buffer;
 1991              		.loc 1 67 5 discriminator 3 view .LVU487
  68:armwave.c     **** 
 1992              		.loc 1 68 5 discriminator 3 view .LVU488
  71:armwave.c     **** 
 1993              		.loc 1 71 5 discriminator 3 view .LVU489
 1994              	@ armwave.c:71:     write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.cmp
  71:armwave.c     **** 
 1995              		.loc 1 71 63 is_stmt 0 discriminator 3 view .LVU490
 1996 08f8 920307E0 		mul	r7, r2, r3	@ _31, g_armwave_state.cmp_x_bitdepth_scale, _7
 1997              	@ armwave.c:71:     write_buffer_base = g_armwave_state.ch1_buffer + (slice_y * g_armwave_state.cmp
  71:armwave.c     **** 
 1998              		.loc 1 71 40 discriminator 3 view .LVU491
 1999 08fc 042099E5 		ldr	r2, [r9, #4]	@ _29, g_armwave_state.ch1_buffer
 2000              	.LVL126:
  74:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 2001              		.loc 1 74 5 is_stmt 1 discriminator 3 view .LVU492
  74:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 2002              		.loc 1 74 5 is_stmt 0 discriminator 3 view .LVU493
 2003 0900 5D0000DA 		ble	.L115		@,
 2004              	@ armwave.c:74:     for(w = 0; w < g_armwave_state.waves; w++) {
  74:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 2005              		.loc 1 74 11 view .LVU494
 2006 0904 00A0A0E3 		mov	r10, #0	@ w,
 2007 0908 0780A0E1 		mov	r8, r7	@ _31, _31
 2008 090c 043043E2 		sub	r3, r3, #4	@ _40, _7,
 2009              	.LVL127:
  74:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 2010              		.loc 1 74 11 view .LVU495
 2011 0910 18308DE5 		str	r3, [sp, #24]	@ _40, %sfp
 2012              	.LVL128:
 2013              	.L121:
  75:armwave.c     **** 
 2014              		.loc 1 75 9 is_stmt 1 view .LVU496
 2015              	@ armwave.c:79:         for(yy = 0; yy < height; yy += 4) {
  79:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2016              		.loc 1 79 9 is_stmt 0 view .LVU497
 2017 0914 08109DE5 		ldr	r1, [sp, #8]	@ _9, %sfp
 2018              	@ armwave.c:75:         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wa
  75:armwave.c     **** 
 2019              		.loc 1 75 64 view .LVU498
 2020 0918 343099E5 		ldr	r3, [r9, #52]	@ g_armwave_state.wave_stride, g_armwave_state.wave_stride
 2021              	@ armwave.c:79:         for(yy = 0; yy < height; yy += 4) {
  79:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2022              		.loc 1 79 9 view .LVU499
 2023 091c 000051E3 		cmp	r1, #0	@ _9,
 2024              	@ armwave.c:75:         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wa
  75:armwave.c     **** 
 2025              		.loc 1 75 36 view .LVU500
 2026 0920 141099E5 		ldr	r1, [r9, #20]	@ _32, g_armwave_state.wave_buffer
 2027              	@ armwave.c:75:         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wa
  75:armwave.c     **** 
 2028              		.loc 1 75 64 view .LVU501
 2029 0924 930A03E0 		mul	r3, r3, r10	@ _36, g_armwave_state.wave_stride, w
 2030              	.LVL129:
  79:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2031              		.loc 1 79 9 is_stmt 1 view .LVU502
  79:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2032              		.loc 1 79 9 is_stmt 0 view .LVU503
 2033 0928 4E00000A 		beq	.L116		@,
 2034 092c 18009DE5 		ldr	r0, [sp, #24]	@ _40, %sfp
 2035 0930 003083E0 		add	r3, r3, r0	@ tmp234, _36, _40
 2036              	.LVL130:
  79:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2037              		.loc 1 79 9 view .LVU504
 2038 0934 033081E0 		add	r3, r1, r3	@ ivtmp.85, _32, tmp234
 2039              	@ armwave.c:79:         for(yy = 0; yy < height; yy += 4) {
  79:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2040              		.loc 1 79 16 view .LVU505
 2041 0938 0010A0E3 		mov	r1, #0	@ yy,
 2042              	.LVL131:
  79:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2043              		.loc 1 79 16 view .LVU506
 2044 093c 04308DE5 		str	r3, [sp, #4]	@ ivtmp.85, %sfp
 2045              	.LVL132:
 2046              	.L120:
  80:armwave.c     **** 
 2047              		.loc 1 80 13 is_stmt 1 view .LVU507
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2048              		.loc 1 91 17 view .LVU508
  92:armwave.c     ****                 word >>= 8;
 2049              		.loc 1 92 17 view .LVU509
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2050              		.loc 1 91 17 view .LVU510
  92:armwave.c     ****                 word >>= 8;
 2051              		.loc 1 92 17 view .LVU511
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2052              		.loc 1 91 17 view .LVU512
  92:armwave.c     ****                 word >>= 8;
 2053              		.loc 1 92 17 view .LVU513
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2054              		.loc 1 91 17 view .LVU514
  92:armwave.c     ****                 word >>= 8;
 2055              		.loc 1 92 17 view .LVU515
 2056              	@ armwave.c:80:             word = *(uint32_t*)(wave_base + yy);
  80:armwave.c     **** 
 2057              		.loc 1 80 18 is_stmt 0 view .LVU516
 2058 0940 04009DE5 		ldr	r0, [sp, #4]	@ ivtmp.85, %sfp
 2059              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2060              		.loc 1 91 64 view .LVU517
 2061 0944 033081E2 		add	r3, r1, #3	@ tmp298, yy,
 2062 0948 1C308DE5 		str	r3, [sp, #28]	@ tmp298, %sfp
 2063              	@ armwave.c:80:             word = *(uint32_t*)(wave_base + yy);
  80:armwave.c     **** 
 2064              		.loc 1 80 18 view .LVU518
 2065 094c 0430B0E5 		ldr	r3, [r0, #4]!	@ word, MEM[base: _252, offset: 0B]
 2066              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2067              		.loc 1 91 64 view .LVU519
 2068 0950 01B081E2 		add	fp, r1, #1	@ tmp261, yy,
 2069              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 2070              		.loc 1 86 20 view .LVU520
 2071 0954 FF5013E2 		ands	r5, r3, #255	@ scale_value, word,
 2072 0958 01E0A003 		moveq	lr, #1	@ tmp236,
 2073 095c 00E0A013 		movne	lr, #0	@ tmp236,
 2074              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 2075              		.loc 1 86 19 view .LVU521
 2076 0960 FF0055E3 		cmp	r5, #255	@ scale_value,
 2077 0964 01E08E03 		orreq	lr, lr, #1	@,, tmp241, tmp236
 2078 0968 00005EE3 		cmp	lr, #0	@ tmp241,
 2079              	@ armwave.c:80:             word = *(uint32_t*)(wave_base + yy);
  80:armwave.c     **** 
 2080              		.loc 1 80 18 view .LVU522
 2081 096c 04008DE5 		str	r0, [sp, #4]	@ ivtmp.85, %sfp
 2082              	.LVL133:
  82:armwave.c     ****                 scale_value = word & 0xff;
 2083              		.loc 1 82 13 is_stmt 1 view .LVU523
  83:armwave.c     ****                 
 2084              		.loc 1 83 17 view .LVU524
  86:armwave.c     ****                     continue;
 2085              		.loc 1 86 17 view .LVU525
 2086              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2087              		.loc 1 91 64 is_stmt 0 view .LVU526
 2088 0970 027081E2 		add	r7, r1, #2	@ tmp280, yy,
 2089              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 2090              		.loc 1 92 47 view .LVU527
 2091 0974 084085E0 		add	r4, r5, r8	@ tmp246, scale_value, _31
 2092              	@ armwave.c:93:                 word >>= 8;
  93:armwave.c     ****             }
 2093              		.loc 1 93 22 view .LVU528
 2094 0978 23C4A0E1 		lsr	ip, r3, #8	@ word, word,
 2095 097c 2308A0E1 		lsr	r0, r3, #16	@ word, word,
 2096              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 2097              		.loc 1 86 19 view .LVU529
 2098 0980 3300001A 		bne	.L123		@,
 2099              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2100              		.loc 1 91 64 view .LVU530
 2101 0984 246099E5 		ldr	r6, [r9, #36]	@ g_armwave_state.cmp_x_bitdepth_scale, g_armwave_state.cmp_x_bitdepth_scale
 2102              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 2103              		.loc 1 86 20 view .LVU531
 2104 0988 FFC01CE2 		ands	ip, ip, #255	@ scale_value, word,
 2105 098c 0150A003 		moveq	r5, #1	@ tmp254,
 2106              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2107              		.loc 1 91 64 view .LVU532
 2108 0990 960106E0 		mul	r6, r6, r1	@ tmp243, g_armwave_state.cmp_x_bitdepth_scale, yy
 2109              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 2110              		.loc 1 86 20 view .LVU533
 2111 0994 0050A013 		movne	r5, #0	@ tmp254,
 2112              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 2113              		.loc 1 92 47 view .LVU534
 2114 0998 08E08CE0 		add	lr, ip, r8	@ tmp265, scale_value, _31
 2115 099c 264484E0 		add	r4, r4, r6, lsr #8	@ tmp247, tmp246, tmp243,
 2116              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 2117              		.loc 1 86 19 view .LVU535
 2118 09a0 FF005CE3 		cmp	ip, #255	@ scale_value,
 2119 09a4 05C0A011 		movne	ip, r5	@, tmp259, tmp254
 2120 09a8 01C08503 		orreq	ip, r5, #1	@,, tmp259, tmp254
 2121 09ac 00005CE3 		cmp	ip, #0	@ tmp259,
 2122              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 2123              		.loc 1 92 47 view .LVU536
 2124 09b0 04C0D2E7 		ldrb	ip, [r2, r4]	@ zero_extendqisi2	@ *_93, *_93
 2125 09b4 01C08CE2 		add	ip, ip, #1	@ tmp250, *_93,
 2126 09b8 04C0C2E7 		strb	ip, [r2, r4]	@ tmp250, *_93
 2127              	.LVL134:
  93:armwave.c     ****             }
 2128              		.loc 1 93 17 is_stmt 1 view .LVU537
  83:armwave.c     ****                 
 2129              		.loc 1 83 17 view .LVU538
  86:armwave.c     ****                     continue;
 2130              		.loc 1 86 17 view .LVU539
 2131              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 2132              		.loc 1 86 19 is_stmt 0 view .LVU540
 2133 09bc 2400001A 		bne	.L123		@,
 2134              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2135              		.loc 1 91 64 view .LVU541
 2136 09c0 244099E5 		ldr	r4, [r9, #36]	@ g_armwave_state.cmp_x_bitdepth_scale, g_armwave_state.cmp_x_bitdepth_scale
 2137              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 2138              		.loc 1 86 20 view .LVU542
 2139 09c4 FF0010E2 		ands	r0, r0, #255	@ scale_value, word,
 2140              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 2141              		.loc 1 92 47 view .LVU543
 2142 09c8 08C080E0 		add	ip, r0, r8	@ tmp284, scale_value, _31
 2143              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2144              		.loc 1 91 64 view .LVU544
 2145 09cc 940B0BE0 		mul	fp, r4, fp	@ tmp262, g_armwave_state.cmp_x_bitdepth_scale, tmp261
 2146              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 2147              		.loc 1 86 20 view .LVU545
 2148 09d0 0140A003 		moveq	r4, #1	@ tmp273,
 2149 09d4 0040A013 		movne	r4, #0	@ tmp273,
 2150              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 2151              		.loc 1 92 47 view .LVU546
 2152 09d8 2BE48EE0 		add	lr, lr, fp, lsr #8	@ tmp266, tmp265, tmp262,
 2153              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 2154              		.loc 1 86 19 view .LVU547
 2155 09dc FF0050E3 		cmp	r0, #255	@ scale_value,
 2156 09e0 0400A011 		movne	r0, r4	@, tmp278, tmp273
 2157 09e4 01008403 		orreq	r0, r4, #1	@,, tmp278, tmp273
 2158 09e8 000050E3 		cmp	r0, #0	@ tmp278,
 2159              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 2160              		.loc 1 92 47 view .LVU548
 2161 09ec 0E00D2E7 		ldrb	r0, [r2, lr]	@ zero_extendqisi2	@ *_121, *_121
 2162 09f0 010080E2 		add	r0, r0, #1	@ tmp269, *_121,
 2163 09f4 0E00C2E7 		strb	r0, [r2, lr]	@ tmp269, *_121
  93:armwave.c     ****             }
 2164              		.loc 1 93 17 is_stmt 1 view .LVU549
 2165              	.LVL135:
  83:armwave.c     ****                 
 2166              		.loc 1 83 17 view .LVU550
  86:armwave.c     ****                     continue;
 2167              		.loc 1 86 17 view .LVU551
 2168              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 2169              		.loc 1 86 19 is_stmt 0 view .LVU552
 2170 09f8 1500001A 		bne	.L123		@,
 2171              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2172              		.loc 1 91 64 view .LVU553
 2173 09fc 24E099E5 		ldr	lr, [r9, #36]	@ g_armwave_state.cmp_x_bitdepth_scale, g_armwave_state.cmp_x_bitdepth_scale
 2174              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 2175              		.loc 1 86 20 view .LVU554
 2176 0a00 233CB0E1 		lsrs	r3, r3, #24	@ word, word,
 2177              	.LVL136:
 2178              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 2179              		.loc 1 92 47 view .LVU555
 2180 0a04 030088E0 		add	r0, r8, r3	@ tmp302, _31, word
 2181              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2182              		.loc 1 91 64 view .LVU556
 2183 0a08 9E0707E0 		mul	r7, lr, r7	@ tmp281, g_armwave_state.cmp_x_bitdepth_scale, tmp280
 2184              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 2185              		.loc 1 86 20 view .LVU557
 2186 0a0c 01E0A003 		moveq	lr, #1	@ tmp291,
 2187 0a10 00E0A013 		movne	lr, #0	@ tmp291,
 2188              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 2189              		.loc 1 92 47 view .LVU558
 2190 0a14 27748CE0 		add	r7, ip, r7, lsr #8	@ tmp285, tmp284, tmp281,
 2191              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 2192              		.loc 1 86 19 view .LVU559
 2193 0a18 FF0053E3 		cmp	r3, #255	@ word,
 2194 0a1c 0E30A011 		movne	r3, lr	@, tmp296, tmp291
 2195 0a20 01308E03 		orreq	r3, lr, #1	@,, tmp296, tmp291
 2196 0a24 000053E3 		cmp	r3, #0	@ tmp296,
 2197              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 2198              		.loc 1 92 47 view .LVU560
 2199 0a28 0730D2E7 		ldrb	r3, [r2, r7]	@ zero_extendqisi2	@ *_149, *_149
 2200 0a2c 013083E2 		add	r3, r3, #1	@ tmp288, *_149,
 2201 0a30 0730C2E7 		strb	r3, [r2, r7]	@ tmp288, *_149
  93:armwave.c     ****             }
 2202              		.loc 1 93 17 is_stmt 1 view .LVU561
 2203              	.LVL137:
  83:armwave.c     ****                 
 2204              		.loc 1 83 17 view .LVU562
  86:armwave.c     ****                     continue;
 2205              		.loc 1 86 17 view .LVU563
 2206              	@ armwave.c:86:                 if(COND_UNLIKELY(scale_value == 0x00 || scale_value == 0xff))
  86:armwave.c     ****                     continue;
 2207              		.loc 1 86 19 is_stmt 0 view .LVU564
 2208 0a34 0600001A 		bne	.L123		@,
 2209              	@ armwave.c:91:                 write_buffer = write_buffer_base + (((yy + ys) * g_armwave_state.cm
  91:armwave.c     ****                 *(write_buffer + scale_value) += 1;
 2210              		.loc 1 91 64 view .LVU565
 2211 0a38 243099E5 		ldr	r3, [r9, #36]	@ g_armwave_state.cmp_x_bitdepth_scale, g_armwave_state.cmp_x_bitdepth_scale
 2212 0a3c 03C081E2 		add	ip, r1, #3	@ tmp298, yy,
 2213 0a40 930C03E0 		mul	r3, r3, ip	@ tmp299, g_armwave_state.cmp_x_bitdepth_scale, tmp298
 2214              	@ armwave.c:92:                 *(write_buffer + scale_value) += 1;
  92:armwave.c     ****                 word >>= 8;
 2215              		.loc 1 92 47 view .LVU566
 2216 0a44 233480E0 		add	r3, r0, r3, lsr #8	@ tmp303, tmp302, tmp299,
 2217 0a48 0300D2E7 		ldrb	r0, [r2, r3]	@ zero_extendqisi2	@ *_177, *_177
 2218 0a4c 010080E2 		add	r0, r0, #1	@ tmp306, *_177,
 2219 0a50 0300C2E7 		strb	r0, [r2, r3]	@ tmp306, *_177
  93:armwave.c     ****             }
 2220              		.loc 1 93 17 is_stmt 1 view .LVU567
 2221              	.LVL138:
 2222              	.L123:
 2223              	@ armwave.c:79:         for(yy = 0; yy < height; yy += 4) {
  79:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2224              		.loc 1 79 9 is_stmt 0 view .LVU568
 2225 0a54 08309DE5 		ldr	r3, [sp, #8]	@ _9, %sfp
 2226              	@ armwave.c:79:         for(yy = 0; yy < height; yy += 4) {
  79:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2227              		.loc 1 79 37 view .LVU569
 2228 0a58 041081E2 		add	r1, r1, #4	@ yy, yy,
 2229              	.LVL139:
 2230              	@ armwave.c:79:         for(yy = 0; yy < height; yy += 4) {
  79:armwave.c     ****             word = *(uint32_t*)(wave_base + yy);
 2231              		.loc 1 79 9 view .LVU570
 2232 0a5c 010053E1 		cmp	r3, r1	@ _9, yy
 2233 0a60 B6FFFF8A 		bhi	.L120		@,
 2234 0a64 385099E5 		ldr	r5, [r9, #56]	@ prephitmp_227, g_armwave_state.waves
 2235              	.LVL140:
 2236              	.L116:
 2237              	@ armwave.c:74:     for(w = 0; w < g_armwave_state.waves; w++) {
  74:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 2238              		.loc 1 74 44 view .LVU571
 2239 0a68 01A08AE2 		add	r10, r10, #1	@ w, w,
 2240              	.LVL141:
 2241              	@ armwave.c:74:     for(w = 0; w < g_armwave_state.waves; w++) {
  74:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 2242              		.loc 1 74 5 view .LVU572
 2243 0a6c 05005AE1 		cmp	r10, r5	@ w, prephitmp_227
 2244 0a70 A7FFFFBA 		blt	.L121		@,
 2245 0a74 446099E5 		ldr	r6, [r9, #68]	@ _43, g_armwave_state.slice_height
 2246 0a78 584099E5 		ldr	r4, [r9, #88]	@ prephitmp_218, g_armwave_state.target_width
 2247              	.LVL142:
 2248              	.L115:
  74:armwave.c     ****         wave_base = g_armwave_state.wave_buffer + slice_y + (w * g_armwave_state.wave_stride);
 2249              		.loc 1 74 5 view .LVU573
 2250              	.LBE30:
 2251              	.LBE32:
 429:armwave.c     ****         xx_rem -= g_armwave_state.slice_height;
 2252              		.loc 1 429 9 is_stmt 1 discriminator 3 view .LVU574
 2253              	@ armwave.c:425:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 425:armwave.c     ****         //printf("armwave_test_generate: slice %d (y=%d, h=%d)\n", yy, yy * g_armwave_state.slice_h
 2254              		.loc 1 425 52 is_stmt 0 discriminator 3 view .LVU575
 2255 0a7c 0610A0E1 		mov	r1, r6	@, _43
 2256 0a80 0400A0E1 		mov	r0, r4	@, prephitmp_218
 2257 0a84 FEFFFFEB 		bl	__aeabi_idiv		@
 2258              	.LVL143:
 2259              	@ armwave.c:429:         xx_rem -= g_armwave_state.slice_height;
 2260              		.loc 1 429 16 discriminator 3 view .LVU576
 2261 0a88 10209DE5 		ldr	r2, [sp, #16]	@ xx_rem, %sfp
 2262              	@ armwave.c:425:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 425:armwave.c     ****         //printf("armwave_test_generate: slice %d (y=%d, h=%d)\n", yy, yy * g_armwave_state.slice_h
 2263              		.loc 1 425 87 discriminator 3 view .LVU577
 2264 0a8c 0C309DE5 		ldr	r3, [sp, #12]	@ yy, %sfp
 2265              	@ armwave.c:429:         xx_rem -= g_armwave_state.slice_height;
 2266              		.loc 1 429 16 discriminator 3 view .LVU578
 2267 0a90 062042E0 		sub	r2, r2, r6	@ xx_rem, xx_rem, _43
 2268 0a94 10208DE5 		str	r2, [sp, #16]	@ xx_rem, %sfp
 2269              	.LVL144:
 430:armwave.c     ****         ypos += g_armwave_state.slice_height;
 2270              		.loc 1 430 9 is_stmt 1 discriminator 3 view .LVU579
 2271              	@ armwave.c:430:         ypos += g_armwave_state.slice_height;
 2272              		.loc 1 430 14 is_stmt 0 discriminator 3 view .LVU580
 2273 0a98 14209DE5 		ldr	r2, [sp, #20]	@ ypos, %sfp
 2274              	.LVL145:
 2275              	@ armwave.c:425:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 425:armwave.c     ****         //printf("armwave_test_generate: slice %d (y=%d, h=%d)\n", yy, yy * g_armwave_state.slice_h
 2276              		.loc 1 425 87 discriminator 3 view .LVU581
 2277 0a9c 013083E2 		add	r3, r3, #1	@ yy, yy,
 2278              	@ armwave.c:430:         ypos += g_armwave_state.slice_height;
 2279              		.loc 1 430 14 discriminator 3 view .LVU582
 2280 0aa0 062082E0 		add	r2, r2, r6	@ ypos, ypos, _43
 2281              	@ armwave.c:425:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 425:armwave.c     ****         //printf("armwave_test_generate: slice %d (y=%d, h=%d)\n", yy, yy * g_armwave_state.slice_h
 2282              		.loc 1 425 87 discriminator 3 view .LVU583
 2283 0aa4 0C308DE5 		str	r3, [sp, #12]	@ yy, %sfp
 2284              	.LVL146:
 2285              	@ armwave.c:430:         ypos += g_armwave_state.slice_height;
 2286              		.loc 1 430 14 discriminator 3 view .LVU584
 2287 0aa8 14208DE5 		str	r2, [sp, #20]	@ ypos, %sfp
 2288              	.LVL147:
 2289              	@ armwave.c:425:     for(yy = 0; yy < (g_armwave_state.target_width / g_armwave_state.slice_height)
 425:armwave.c     ****         //printf("armwave_test_generate: slice %d (y=%d, h=%d)\n", yy, yy * g_armwave_state.slice_h
 2290              		.loc 1 425 5 discriminator 3 view .LVU585
 2291 0aac 030050E1 		cmp	r0, r3	@, yy
 2292 0ab0 8AFFFF8A 		bhi	.L122		@,
 2293 0ab4 0200A0E1 		mov	r0, r2	@, ypos
 431:armwave.c     ****     }
 432:armwave.c     **** 
 433:armwave.c     ****     render_nonaa_to_buffer_1ch_slice(ypos, xx_rem);
 2294              		.loc 1 433 5 is_stmt 1 view .LVU586
 2295 0ab8 10109DE5 		ldr	r1, [sp, #16]	@, %sfp
 2296              	@ armwave.c:434: }
 434:armwave.c     **** }
 2297              		.loc 1 434 1 is_stmt 0 view .LVU587
 2298 0abc 24D08DE2 		add	sp, sp, #36	@,,
 2299              		.cfi_remember_state
 2300              		.cfi_def_cfa_offset 36
 2301              		@ sp needed	@
 2302 0ac0 F04FBDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, lr}	@
 2303              		.cfi_restore 14
 2304              		.cfi_restore 11
 2305              		.cfi_restore 10
 2306              		.cfi_restore 9
 2307              		.cfi_restore 8
 2308              		.cfi_restore 7
 2309              		.cfi_restore 6
 2310              		.cfi_restore 5
 2311              		.cfi_restore 4
 2312              		.cfi_def_cfa_offset 0
 2313              	@ armwave.c:433:     render_nonaa_to_buffer_1ch_slice(ypos, xx_rem);
 433:armwave.c     **** }
 2314              		.loc 1 433 5 view .LVU588
 2315 0ac4 FEFFFFEA 		b	render_nonaa_to_buffer_1ch_slice		@
 2316              	.LVL148:
 2317              	.L124:
 2318              		.cfi_restore_state
 2319              	@ armwave.c:421:     uint32_t xx_rem = g_armwave_state.target_width, ypos = 0;
 421:armwave.c     **** 
 2320              		.loc 1 421 53 view .LVU589
 2321 0ac8 14008DE5 		str	r0, [sp, #20]	@ tmp225, %sfp
 433:armwave.c     **** }
 2322              		.loc 1 433 5 is_stmt 1 view .LVU590
 2323 0acc 10109DE5 		ldr	r1, [sp, #16]	@, %sfp
 2324              	@ armwave.c:434: }
 2325              		.loc 1 434 1 is_stmt 0 view .LVU591
 2326 0ad0 24D08DE2 		add	sp, sp, #36	@,,
 2327              		.cfi_def_cfa_offset 36
 2328              		@ sp needed	@
 2329 0ad4 F04FBDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, lr}	@
 2330              		.cfi_restore 14
 2331              		.cfi_restore 11
 2332              		.cfi_restore 10
 2333              		.cfi_restore 9
 2334              		.cfi_restore 8
 2335              		.cfi_restore 7
 2336              		.cfi_restore 6
 2337              		.cfi_restore 5
 2338              		.cfi_restore 4
 2339              		.cfi_def_cfa_offset 0
 2340              	@ armwave.c:433:     render_nonaa_to_buffer_1ch_slice(ypos, xx_rem);
 433:armwave.c     **** }
 2341              		.loc 1 433 5 view .LVU592
 2342 0ad8 FEFFFFEA 		b	render_nonaa_to_buffer_1ch_slice		@
 2343              	.LVL149:
 2344              	.L133:
 2345              		.align	2
 2346              	.L132:
 2347 0adc 00000000 		.word	g_armwave_state
 2348              		.cfi_endproc
 2349              	.LFE69:
 2351              		.align	2
 2352              		.global	armwave_test_fill_outbuf
 2353              		.syntax unified
 2354              		.arm
 2355              		.fpu vfp
 2357              	armwave_test_fill_outbuf:
 2358              	.LFB70:
 435:armwave.c     **** 
 436:armwave.c     **** /*
 437:armwave.c     ****  * Render image to the local allocated buffer.
 438:armwave.c     ****  */
 439:armwave.c     **** void armwave_test_fill_outbuf()
 440:armwave.c     **** {
 2359              		.loc 1 440 1 is_stmt 1 view -0
 2360              		.cfi_startproc
 2361              		@ args = 0, pretend = 0, frame = 8
 2362              		@ frame_needed = 0, uses_anonymous_args = 0
 441:armwave.c     ****     armwave_fill_pixbuf_scaled(g_armwave_state.out_pixbuf);
 2363              		.loc 1 441 5 view .LVU594
 2364 0ae0 50C19FE5 		ldr	ip, .L155	@ tmp204,
 2365              	@ armwave.c:440: {
 440:armwave.c     ****     armwave_fill_pixbuf_scaled(g_armwave_state.out_pixbuf);
 2366              		.loc 1 440 1 is_stmt 0 view .LVU595
 2367 0ae4 F04F2DE9 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}	@
 2368              		.cfi_def_cfa_offset 36
 2369              		.cfi_offset 4, -36
 2370              		.cfi_offset 5, -32
 2371              		.cfi_offset 6, -28
 2372              		.cfi_offset 7, -24
 2373              		.cfi_offset 8, -20
 2374              		.cfi_offset 9, -16
 2375              		.cfi_offset 10, -12
 2376              		.cfi_offset 11, -8
 2377              		.cfi_offset 14, -4
 2378 0ae8 0CD04DE2 		sub	sp, sp, #12	@,,
 2379              		.cfi_def_cfa_offset 48
 2380              	@ armwave.c:441:     armwave_fill_pixbuf_scaled(g_armwave_state.out_pixbuf);
 2381              		.loc 1 441 5 view .LVU596
 2382 0aec 68809CE5 		ldr	r8, [ip, #104]	@ _1, g_armwave_state.out_pixbuf
 2383              	.LVL150:
 2384              	.LBB35:
 2385              	.LBI35:
 158:armwave.c     **** {
 2386              		.loc 1 158 6 is_stmt 1 view .LVU597
 2387              	.LBB36:
 160:armwave.c     ****     // uint32_t ysub;
 2388              		.loc 1 160 5 view .LVU598
 162:armwave.c     ****     uint8_t r, g, b, value; 
 2389              		.loc 1 162 5 view .LVU599
 163:armwave.c     ****     // uint8_t row;
 2390              		.loc 1 163 5 view .LVU600
 165:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 2391              		.loc 1 165 5 view .LVU601
 2392              	@ armwave.c:165:     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 165:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 2393              		.loc 1 165 15 is_stmt 0 view .LVU602
 2394 0af0 04909CE5 		ldr	r9, [ip, #4]	@ base_32ptr, g_armwave_state.ch1_buffer
 2395              	.LVL151:
 166:armwave.c     ****     uint32_t offset;
 2396              		.loc 1 166 5 is_stmt 1 view .LVU603
 167:armwave.c     **** 
 2397              		.loc 1 167 5 view .LVU604
 169:armwave.c     **** 
 2398              		.loc 1 169 5 view .LVU605
 2399 0af4 000058E3 		cmp	r8, #0	@ _1,
 2400 0af8 4900000A 		beq	.L153		@,
 171:armwave.c     ****     //vscale = g_armwave_state.target_height >> 8;
 2401              		.loc 1 171 5 view .LVU606
 2402              	@ armwave.c:171:     npix = g_armwave_state.target_width * 256; 
 171:armwave.c     ****     //vscale = g_armwave_state.target_height >> 8;
 2403              		.loc 1 171 10 is_stmt 0 view .LVU607
 2404 0afc 58709CE5 		ldr	r7, [ip, #88]	@ g_armwave_state.target_width, g_armwave_state.target_width
 2405 0b00 0774A0E1 		lsl	r7, r7, #8	@ npix, g_armwave_state.target_width,
 2406              	.LVL152:
 174:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 2407              		.loc 1 174 5 is_stmt 1 view .LVU608
 174:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 2408              		.loc 1 174 5 is_stmt 0 view .LVU609
 2409 0b04 000057E3 		cmp	r7, #0	@ npix,
 2410 0b08 0A0000DA 		ble	.L134		@,
 2411              	@ armwave.c:186:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 186:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 2412              		.loc 1 186 52 view .LVU610
 2413 0b0c FCB6DCE1 		ldrsh	fp, [ip, #108]	@ _17, g_armwave_state.ch1_color.r
 2414              	@ armwave.c:187:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 187:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 2415              		.loc 1 187 52 view .LVU611
 2416 0b10 FEA6DCE1 		ldrsh	r10, [ip, #110]	@ _23, g_armwave_state.ch1_color.g
 2417              	@ armwave.c:188:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 188:armwave.c     **** 
 2418              		.loc 1 188 52 view .LVU612
 2419 0b14 F057DCE1 		ldrsh	r5, [ip, #112]	@ _27, g_armwave_state.ch1_color.b
 2420              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2421              		.loc 1 210 57 view .LVU613
 2422 0b18 0A6ADCED 		vldr.32	s13, [ip, #40]	@ _49, g_armwave_state.vscale_frac
 2423              	@ armwave.c:174:     for(n = 0; n < npix; n += 4) {
 174:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 2424              		.loc 1 174 11 view .LVU614
 2425 0b1c 00E0A0E3 		mov	lr, #0	@ n,
 2426              	.LVL153:
 2427              	.L141:
 178:armwave.c     **** 
 2428              		.loc 1 178 9 is_stmt 1 view .LVU615
 2429              	@ armwave.c:178:         wave_word = *base_32ptr++;
 178:armwave.c     **** 
 2430              		.loc 1 178 19 is_stmt 0 view .LVU616
 2431 0b20 040099E4 		ldr	r0, [r9], #4	@ wave_word, MEM[base: base_32ptr_8, offset: 4294967292B]
 2432              	.LVL154:
 180:armwave.c     ****             for(w = 0; w < 4; w++) {
 2433              		.loc 1 180 9 is_stmt 1 view .LVU617
 2434              	@ armwave.c:180:         if(COND_UNLIKELY(wave_word != 0)) {
 180:armwave.c     ****             for(w = 0; w < 4; w++) {
 2435              		.loc 1 180 11 is_stmt 0 view .LVU618
 2436 0b24 000050E3 		cmp	r0, #0	@ wave_word,
 2437 0b28 0400001A 		bne	.L150		@,
 2438 0b2c 04E08EE2 		add	lr, lr, #4	@ n, n,
 2439              	.L137:
 2440              	.LVL155:
 2441              	@ armwave.c:174:     for(n = 0; n < npix; n += 4) {
 174:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 2442              		.loc 1 174 5 view .LVU619
 2443 0b30 0E0057E1 		cmp	r7, lr	@ npix, n
 2444 0b34 F9FFFFCA 		bgt	.L141		@,
 2445              	.LVL156:
 2446              	.L134:
 174:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 2447              		.loc 1 174 5 view .LVU620
 2448              	.LBE36:
 2449              	.LBE35:
 2450              	@ armwave.c:442: }
 442:armwave.c     **** }
 2451              		.loc 1 442 1 view .LVU621
 2452 0b38 0CD08DE2 		add	sp, sp, #12	@,,
 2453              		.cfi_remember_state
 2454              		.cfi_def_cfa_offset 36
 2455              		@ sp needed	@
 2456 0b3c F08FBDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}	@
 2457              	.LVL157:
 2458              	.L150:
 2459              		.cfi_restore_state
 2460              	.LBB38:
 2461              	.LBB37:
 2462              	@ armwave.c:185:                 if(value != 0) {
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2463              		.loc 1 185 19 view .LVU622
 2464 0b40 FF1010E2 		ands	r1, r0, #255	@ _19, wave_word,
 2465              	@ armwave.c:180:         if(COND_UNLIKELY(wave_word != 0)) {
 180:armwave.c     ****             for(w = 0; w < 4; w++) {
 2466              		.loc 1 180 11 view .LVU623
 2467 0b44 0E60A0E1 		mov	r6, lr	@ ivtmp.102, n
 2468              	.LVL158:
 182:armwave.c     ****                 wave_word >>= 8;
 2469              		.loc 1 182 17 is_stmt 1 view .LVU624
 183:armwave.c     **** 
 2470              		.loc 1 183 17 view .LVU625
 2471              	@ armwave.c:183:                 wave_word >>= 8;
 183:armwave.c     **** 
 2472              		.loc 1 183 27 is_stmt 0 view .LVU626
 2473 0b48 2004A0E1 		lsr	r0, r0, #8	@ wave_word, wave_word,
 2474              	.LVL159:
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2475              		.loc 1 185 17 is_stmt 1 view .LVU627
 2476 0b4c 04E08EE2 		add	lr, lr, #4	@ n, ivtmp.102,
 2477              	@ armwave.c:185:                 if(value != 0) {
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2478              		.loc 1 185 19 is_stmt 0 view .LVU628
 2479 0b50 0500001A 		bne	.L154		@,
 2480              	.LVL160:
 2481              	.L138:
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2482              		.loc 1 185 19 view .LVU629
 2483 0b54 016086E2 		add	r6, r6, #1	@ ivtmp.102, ivtmp.102,
 2484              	@ armwave.c:181:             for(w = 0; w < 4; w++) {
 181:armwave.c     ****                 value = wave_word & 0xff;
 2485              		.loc 1 181 13 view .LVU630
 2486 0b58 06005EE1 		cmp	lr, r6	@ n, ivtmp.102
 2487 0b5c F3FFFF0A 		beq	.L137		@,
 182:armwave.c     ****                 wave_word >>= 8;
 2488              		.loc 1 182 17 is_stmt 1 view .LVU631
 2489              	.LVL161:
 183:armwave.c     **** 
 2490              		.loc 1 183 17 view .LVU632
 2491              	@ armwave.c:185:                 if(value != 0) {
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2492              		.loc 1 185 19 is_stmt 0 view .LVU633
 2493 0b60 FF1010E2 		ands	r1, r0, #255	@ _19, wave_word,
 2494              	@ armwave.c:183:                 wave_word >>= 8;
 183:armwave.c     **** 
 2495              		.loc 1 183 27 view .LVU634
 2496 0b64 2004A0E1 		lsr	r0, r0, #8	@ wave_word, wave_word,
 2497              	.LVL162:
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2498              		.loc 1 185 17 is_stmt 1 view .LVU635
 2499              	@ armwave.c:185:                 if(value != 0) {
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2500              		.loc 1 185 19 is_stmt 0 view .LVU636
 2501 0b68 F9FFFF0A 		beq	.L138		@,
 2502              	.L154:
 186:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 2503              		.loc 1 186 21 is_stmt 1 view .LVU637
 2504              	.LVL163:
 187:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 2505              		.loc 1 187 21 view .LVU638
 188:armwave.c     **** 
 2506              		.loc 1 188 21 view .LVU639
 190:armwave.c     ****                     g = MIN(gg, 255);
 2507              		.loc 1 190 21 view .LVU640
 191:armwave.c     ****                     b = MIN(bb, 255);
 2508              		.loc 1 191 21 view .LVU641
 192:armwave.c     **** 
 2509              		.loc 1 192 21 view .LVU642
 195:armwave.c     **** 
 2510              		.loc 1 195 21 view .LVU643
 2511              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2512              		.loc 1 210 32 is_stmt 0 view .LVU644
 2513 0b6c 7630EFE6 		uxtb	r3, r6	@ _47, ivtmp.102
 2514              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 2515              		.loc 1 211 41 view .LVU645
 2516 0b70 012083E2 		add	r2, r3, #1	@ tmp196, _47,
 2517              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2518              		.loc 1 210 40 view .LVU646
 2519 0b74 903A07EE 		vmov	s15, r3	@ int	@ _47, _47
 2520              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 2521              		.loc 1 211 41 view .LVU647
 2522 0b78 102A07EE 		vmov	s14, r2	@ int	@ tmp196, tmp196
 2523              	@ armwave.c:188:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 188:armwave.c     **** 
 2524              		.loc 1 188 55 view .LVU648
 2525 0b7c 950103E0 		mul	r3, r5, r1	@ tmp181, _27, _19
 2526              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2527              		.loc 1 210 40 view .LVU649
 2528 0b80 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp194, _47
 2529              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 2530              		.loc 1 211 46 view .LVU650
 2531 0b84 C77AB8EE 		vcvt.f32.s32	s14, s14	@ tmp197, tmp196
 2532              	@ armwave.c:187:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 187:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 2533              		.loc 1 187 55 view .LVU651
 2534 0b88 9A0102E0 		mul	r2, r10, r1	@ tmp185, _23, _19
 2535              	@ armwave.c:188:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 188:armwave.c     **** 
 2536              		.loc 1 188 24 view .LVU652
 2537 0b8c 4334A0E1 		asr	r3, r3, #8	@ bb, tmp181,
 2538              	.LVL164:
 2539              	@ armwave.c:192:                     b = MIN(bb, 255);
 192:armwave.c     **** 
 2540              		.loc 1 192 25 view .LVU653
 2541 0b90 FF0053E3 		cmp	r3, #255	@ bb,
 2542              	@ armwave.c:187:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 187:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 2543              		.loc 1 187 24 view .LVU654
 2544 0b94 4224A0E1 		asr	r2, r2, #8	@ gg, tmp185,
 2545              	.LVL165:
 2546              	@ armwave.c:192:                     b = MIN(bb, 255);
 192:armwave.c     **** 
 2547              		.loc 1 192 25 view .LVU655
 2548 0b98 FF30A0A3 		movge	r3, #255	@ bb,
 2549              	.LVL166:
 2550              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2551              		.loc 1 210 40 view .LVU656
 2552 0b9c A67A67EE 		vmul.f32	s15, s15, s13	@ tmp195, tmp194, _49
 2553              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 2554              		.loc 1 211 46 view .LVU657
 2555 0ba0 267A27EE 		vmul.f32	s14, s14, s13	@ tmp198, tmp197, _49
 2556              	@ armwave.c:191:                     g = MIN(gg, 255);
 191:armwave.c     ****                     b = MIN(bb, 255);
 2557              		.loc 1 191 25 view .LVU658
 2558 0ba4 FF0052E3 		cmp	r2, #255	@ gg,
 2559 0ba8 FF20A0A3 		movge	r2, #255	@ gg,
 2560              	.LVL167:
 2561              	@ armwave.c:186:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 186:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 2562              		.loc 1 186 55 view .LVU659
 2563 0bac 910B01E0 		mul	r1, r1, fp	@ tmp191, _19, _17
 2564              	.LVL168:
 2565              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 2566              		.loc 1 195 56 view .LVU660
 2567 0bb0 0224A0E1 		lsl	r2, r2, #8	@ tmp186, gg,
 2568              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 2569              		.loc 1 195 44 view .LVU661
 2570 0bb4 0338A0E1 		lsl	r3, r3, #16	@ tmp182, bb,
 2571              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2572              		.loc 1 210 24 view .LVU662
 2573 0bb8 E77AFCEE 		vcvt.u32.f32	s15, s15	@ yy, tmp195
 2574              	@ armwave.c:186:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 186:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 2575              		.loc 1 186 24 view .LVU663
 2576 0bbc 4114A0E1 		asr	r1, r1, #8	@ rr, tmp191,
 2577              	.LVL169:
 2578              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 2579              		.loc 1 195 56 view .LVU664
 2580 0bc0 7220FFE6 		uxth	r2, r2	@ tmp187, tmp186
 2581              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 2582              		.loc 1 195 44 view .LVU665
 2583 0bc4 FF3803E2 		and	r3, r3, #16711680	@ tmp183, tmp182,
 2584              	@ armwave.c:190:                     r = MIN(rr, 255);
 190:armwave.c     ****                     g = MIN(gg, 255);
 2585              		.loc 1 190 25 view .LVU666
 2586 0bc8 FF0051E3 		cmp	r1, #255	@ rr,
 2587              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 2588              		.loc 1 195 51 view .LVU667
 2589 0bcc 023083E1 		orr	r3, r3, r2	@ tmp189, tmp183, tmp187
 2590              	@ armwave.c:190:                     r = MIN(rr, 255);
 190:armwave.c     ****                     g = MIN(gg, 255);
 2591              		.loc 1 190 25 view .LVU668
 2592 0bd0 FF10A0A3 		movge	r1, #255	@ rr,
 2593              	.LVL170:
 2594              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2595              		.loc 1 210 24 view .LVU669
 2596 0bd4 904A17EE 		vmov	r4, s15	@ int	@ yy, yy
 2597              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 2598              		.loc 1 211 24 view .LVU670
 2599 0bd8 C77AFCEE 		vcvt.u32.f32	s15, s14	@ ye, tmp198
 2600              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 2601              		.loc 1 195 62 view .LVU671
 2602 0bdc 7110EFE6 		uxtb	r1, r1	@ rr, rr
 2603 0be0 013083E1 		orr	r3, r3, r1	@ tmp193, tmp189, rr
 2604              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 2605              		.loc 1 195 26 view .LVU672
 2606 0be4 FF3483E3 		orr	r3, r3, #-16777216	@ word, tmp193,
 2607              	.LVL171:
 209:armwave.c     ****                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 2608              		.loc 1 209 21 is_stmt 1 view .LVU673
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2609              		.loc 1 210 21 view .LVU674
 211:armwave.c     ****                     xx = (nsub >> 8);
 2610              		.loc 1 211 21 view .LVU675
 212:armwave.c     **** 
 2611              		.loc 1 212 21 view .LVU676
 2612              	@ armwave.c:212:                     xx = (nsub >> 8);
 212:armwave.c     **** 
 2613              		.loc 1 212 32 is_stmt 0 view .LVU677
 2614 0be8 4614A0E1 		asr	r1, r6, #8	@ xx, ivtmp.102,
 2615              	.LVL172:
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2616              		.loc 1 214 21 is_stmt 1 view .LVU678
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2617              		.loc 1 214 21 is_stmt 0 view .LVU679
 2618 0bec 902A17EE 		vmov	r2, s15	@ int	@ ye,
 2619              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 2620              		.loc 1 211 24 view .LVU680
 2621 0bf0 007ACDED 		vstr.32	s15, [sp]	@ int	@ ye, %sfp
 2622              	.LVL173:
 2623              	@ armwave.c:214:                     for(y = yy; y < ye; y++) {
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2624              		.loc 1 214 21 view .LVU681
 2625 0bf4 020054E1 		cmp	r4, r2	@ yy, ye
 2626 0bf8 D5FFFF2A 		bcs	.L138		@,
 2627 0bfc 04008DE5 		str	r0, [sp, #4]	@ wave_word, %sfp
 2628              	.LVL174:
 2629              	.L139:
 215:armwave.c     ****                         *(out_buffer_base + offset) = word;
 2630              		.loc 1 215 25 is_stmt 1 view .LVU682
 216:armwave.c     ****                     }
 2631              		.loc 1 216 25 view .LVU683
 2632              	@ armwave.c:215:                         offset = (xx + (y * g_armwave_state.target_width)); 
 215:armwave.c     ****                         *(out_buffer_base + offset) = word;
 2633              		.loc 1 215 43 is_stmt 0 view .LVU684
 2634 0c00 58209CE5 		ldr	r2, [ip, #88]	@ g_armwave_state.target_width, g_armwave_state.target_width
 2635              	@ armwave.c:214:                     for(y = yy; y < ye; y++) {
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2636              		.loc 1 214 21 view .LVU685
 2637 0c04 00009DE5 		ldr	r0, [sp]	@ ye, %sfp
 2638              	@ armwave.c:216:                         *(out_buffer_base + offset) = word;
 216:armwave.c     ****                     }
 2639              		.loc 1 216 43 view .LVU686
 2640 0c08 921422E0 		mla	r2, r2, r4, r1	@ tmp202, g_armwave_state.target_width, yy, xx
 2641              	.LVL175:
 2642              	@ armwave.c:214:                     for(y = yy; y < ye; y++) {
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2643              		.loc 1 214 42 view .LVU687
 2644 0c0c 014084E2 		add	r4, r4, #1	@ yy, yy,
 2645              	.LVL176:
 2646              	@ armwave.c:214:                     for(y = yy; y < ye; y++) {
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2647              		.loc 1 214 21 view .LVU688
 2648 0c10 040050E1 		cmp	r0, r4	@ ye, yy
 2649              	@ armwave.c:216:                         *(out_buffer_base + offset) = word;
 216:armwave.c     ****                     }
 2650              		.loc 1 216 53 view .LVU689
 2651 0c14 023188E7 		str	r3, [r8, r2, lsl #2]	@ word, *_64
 2652              	@ armwave.c:214:                     for(y = yy; y < ye; y++) {
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2653              		.loc 1 214 21 view .LVU690
 2654 0c18 F8FFFF1A 		bne	.L139		@,
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2655              		.loc 1 214 21 view .LVU691
 2656 0c1c 04009DE5 		ldr	r0, [sp, #4]	@ wave_word, %sfp
 2657 0c20 CBFFFFEA 		b	.L138		@
 2658              	.LVL177:
 2659              	.L153:
 169:armwave.c     **** 
 2660              		.loc 1 169 5 is_stmt 1 view .LVU692
 2661 0c24 10309FE5 		ldr	r3, .L155+4	@,
 2662 0c28 A920A0E3 		mov	r2, #169	@,
 2663 0c2c 0C109FE5 		ldr	r1, .L155+8	@,
 2664 0c30 0C009FE5 		ldr	r0, .L155+12	@,
 2665 0c34 FEFFFFEB 		bl	__assert_fail		@
 2666              	.LVL178:
 2667              	.L156:
 2668              		.align	2
 2669              	.L155:
 2670 0c38 00000000 		.word	g_armwave_state
 2671 0c3c 00000000 		.word	.LANCHOR0
 2672 0c40 20000000 		.word	.LC2
 2673 0c44 2C000000 		.word	.LC3
 2674              	.LBE37:
 2675              	.LBE38:
 2676              		.cfi_endproc
 2677              	.LFE70:
 2679              		.align	2
 2680              		.global	armwave_test_dump_buffer_to_ppm
 2681              		.syntax unified
 2682              		.arm
 2683              		.fpu vfp
 2685              	armwave_test_dump_buffer_to_ppm:
 2686              	.LVL179:
 2687              	.LFB71:
 443:armwave.c     **** 
 444:armwave.c     **** /*
 445:armwave.c     ****  * Dump the working local allocated buffer to a ppm file for debug.
 446:armwave.c     ****  */
 447:armwave.c     **** void armwave_test_dump_buffer_to_ppm(char *fn)
 448:armwave.c     **** {
 2688              		.loc 1 448 1 view -0
 2689              		.cfi_startproc
 2690              		@ args = 0, pretend = 0, frame = 0
 2691              		@ frame_needed = 0, uses_anonymous_args = 0
 2692              		@ link register save eliminated.
 449:armwave.c     ****     armwave_dump_ppm_debug(g_armwave_state.out_pixbuf, fn);
 2693              		.loc 1 449 5 view .LVU694
 2694 0c48 08309FE5 		ldr	r3, .L158	@ tmp112,
 2695 0c4c 0010A0E1 		mov	r1, r0	@, fn
 2696 0c50 680093E5 		ldr	r0, [r3, #104]	@, g_armwave_state.out_pixbuf
 2697              	.LVL180:
 2698              		.loc 1 449 5 is_stmt 0 view .LVU695
 2699 0c54 FEFFFFEA 		b	armwave_dump_ppm_debug		@
 2700              	.LVL181:
 2701              	.L159:
 2702              		.loc 1 449 5 view .LVU696
 2703              		.align	2
 2704              	.L158:
 2705 0c58 00000000 		.word	g_armwave_state
 2706              		.cfi_endproc
 2707              	.LFE71:
 2709              		.align	2
 2710              		.global	armwave_test_fill_gdkbuf
 2711              		.syntax unified
 2712              		.arm
 2713              		.fpu vfp
 2715              	armwave_test_fill_gdkbuf:
 2716              	.LVL182:
 2717              	.LFB72:
 450:armwave.c     **** }
 451:armwave.c     **** 
 452:armwave.c     **** /*
 453:armwave.c     ****  * Render GDK buffer with test funtionry.
 454:armwave.c     ****  */
 455:armwave.c     **** void armwave_test_fill_gdkbuf(PyObject *buf)
 456:armwave.c     **** {
 2718              		.loc 1 456 1 is_stmt 1 view -0
 2719              		.cfi_startproc
 2720              		@ args = 0, pretend = 0, frame = 8
 2721              		@ frame_needed = 0, uses_anonymous_args = 0
 457:armwave.c     ****     //PyObject *mv;
 458:armwave.c     ****     //Py_buffer *buf = malloc(sizeof(Py_buffer));
 459:armwave.c     **** 
 460:armwave.c     ****     // Holy jesus dear mother of God, what have we done?
 461:armwave.c     ****     void *out_pixbuf = ((uint32_t ***)buf)[2][10];
 2722              		.loc 1 461 5 view .LVU698
 2723              	@ armwave.c:461:     void *out_pixbuf = ((uint32_t ***)buf)[2][10];
 2724              		.loc 1 461 11 is_stmt 0 view .LVU699
 2725 0c5c 083090E5 		ldr	r3, [r0, #8]	@ MEM[(uint32_t * * *)buf_2(D) + 8B], MEM[(uint32_t * * *)buf_2(D) + 8B]
 2726              	@ armwave.c:456: {
 456:armwave.c     ****     //PyObject *mv;
 2727              		.loc 1 456 1 view .LVU700
 2728 0c60 F04F2DE9 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}	@
 2729              		.cfi_def_cfa_offset 36
 2730              		.cfi_offset 4, -36
 2731              		.cfi_offset 5, -32
 2732              		.cfi_offset 6, -28
 2733              		.cfi_offset 7, -24
 2734              		.cfi_offset 8, -20
 2735              		.cfi_offset 9, -16
 2736              		.cfi_offset 10, -12
 2737              		.cfi_offset 11, -8
 2738              		.cfi_offset 14, -4
 2739 0c64 0CD04DE2 		sub	sp, sp, #12	@,,
 2740              		.cfi_def_cfa_offset 48
 2741              	.LBB41:
 2742              	.LBB42:
 2743              	@ armwave.c:165:     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 165:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 2744              		.loc 1 165 15 view .LVU701
 2745 0c68 48519FE5 		ldr	r5, .L181	@ tmp206,
 2746              	.LBE42:
 2747              	.LBE41:
 2748              	@ armwave.c:461:     void *out_pixbuf = ((uint32_t ***)buf)[2][10];
 2749              		.loc 1 461 11 view .LVU702
 2750 0c6c 288093E5 		ldr	r8, [r3, #40]	@ out_pixbuf, MEM[(uint32_t * *)_1 + 40B]
 2751              	.LVL183:
 462:armwave.c     ****     
 463:armwave.c     ****     // TODO: use armwave_fill_pixbuf_256 for 256-height buffers for performance?
 464:armwave.c     ****     armwave_fill_pixbuf_scaled(out_pixbuf);
 2752              		.loc 1 464 5 is_stmt 1 view .LVU703
 2753              	.LBB45:
 2754              	.LBI41:
 158:armwave.c     **** {
 2755              		.loc 1 158 6 view .LVU704
 2756              	.LBB43:
 160:armwave.c     ****     // uint32_t ysub;
 2757              		.loc 1 160 5 view .LVU705
 162:armwave.c     ****     uint8_t r, g, b, value; 
 2758              		.loc 1 162 5 view .LVU706
 163:armwave.c     ****     // uint8_t row;
 2759              		.loc 1 163 5 view .LVU707
 165:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 2760              		.loc 1 165 5 view .LVU708
 2761              	@ armwave.c:169:     assert(out_buffer != NULL);
 169:armwave.c     **** 
 2762              		.loc 1 169 5 is_stmt 0 view .LVU709
 2763 0c70 000058E3 		cmp	r8, #0	@ out_pixbuf,
 2764              	@ armwave.c:165:     uint32_t *base_32ptr = (uint32_t*)g_armwave_state.ch1_buffer;
 165:armwave.c     ****     uint32_t *out_buffer_base = out_buffer;
 2765              		.loc 1 165 15 view .LVU710
 2766 0c74 049095E5 		ldr	r9, [r5, #4]	@ base_32ptr, g_armwave_state.ch1_buffer
 2767              	.LVL184:
 166:armwave.c     ****     uint32_t offset;
 2768              		.loc 1 166 5 is_stmt 1 view .LVU711
 167:armwave.c     **** 
 2769              		.loc 1 167 5 view .LVU712
 169:armwave.c     **** 
 2770              		.loc 1 169 5 view .LVU713
 2771 0c78 4900000A 		beq	.L179		@,
 171:armwave.c     ****     //vscale = g_armwave_state.target_height >> 8;
 2772              		.loc 1 171 5 view .LVU714
 2773              	@ armwave.c:171:     npix = g_armwave_state.target_width * 256; 
 171:armwave.c     ****     //vscale = g_armwave_state.target_height >> 8;
 2774              		.loc 1 171 10 is_stmt 0 view .LVU715
 2775 0c7c 587095E5 		ldr	r7, [r5, #88]	@ g_armwave_state.target_width, g_armwave_state.target_width
 2776 0c80 0774A0E1 		lsl	r7, r7, #8	@ npix, g_armwave_state.target_width,
 2777              	.LVL185:
 174:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 2778              		.loc 1 174 5 is_stmt 1 view .LVU716
 174:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 2779              		.loc 1 174 5 is_stmt 0 view .LVU717
 2780 0c84 000057E3 		cmp	r7, #0	@ npix,
 2781 0c88 0A0000DA 		ble	.L160		@,
 2782              	@ armwave.c:186:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 186:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 2783              		.loc 1 186 52 view .LVU718
 2784 0c8c FCB6D5E1 		ldrsh	fp, [r5, #108]	@ _19, g_armwave_state.ch1_color.r
 2785              	@ armwave.c:187:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 187:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 2786              		.loc 1 187 52 view .LVU719
 2787 0c90 FEA6D5E1 		ldrsh	r10, [r5, #110]	@ _25, g_armwave_state.ch1_color.g
 2788              	@ armwave.c:188:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 188:armwave.c     **** 
 2789              		.loc 1 188 52 view .LVU720
 2790 0c94 F047D5E1 		ldrsh	r4, [r5, #112]	@ _29, g_armwave_state.ch1_color.b
 2791              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2792              		.loc 1 210 57 view .LVU721
 2793 0c98 0A6AD5ED 		vldr.32	s13, [r5, #40]	@ _51, g_armwave_state.vscale_frac
 2794              	@ armwave.c:174:     for(n = 0; n < npix; n += 4) {
 174:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 2795              		.loc 1 174 11 view .LVU722
 2796 0c9c 00C0A0E3 		mov	ip, #0	@ n,
 2797              	.LVL186:
 2798              	.L167:
 178:armwave.c     **** 
 2799              		.loc 1 178 9 is_stmt 1 view .LVU723
 2800              	@ armwave.c:178:         wave_word = *base_32ptr++;
 178:armwave.c     **** 
 2801              		.loc 1 178 19 is_stmt 0 view .LVU724
 2802 0ca0 040099E4 		ldr	r0, [r9], #4	@ wave_word, MEM[base: base_32ptr_10, offset: 4294967292B]
 2803              	.LVL187:
 180:armwave.c     ****             for(w = 0; w < 4; w++) {
 2804              		.loc 1 180 9 is_stmt 1 view .LVU725
 2805              	@ armwave.c:180:         if(COND_UNLIKELY(wave_word != 0)) {
 180:armwave.c     ****             for(w = 0; w < 4; w++) {
 2806              		.loc 1 180 11 is_stmt 0 view .LVU726
 2807 0ca4 000050E3 		cmp	r0, #0	@ wave_word,
 2808 0ca8 0400001A 		bne	.L176		@,
 2809 0cac 04C08CE2 		add	ip, ip, #4	@ n, n,
 2810              	.L163:
 2811              	.LVL188:
 2812              	@ armwave.c:174:     for(n = 0; n < npix; n += 4) {
 174:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 2813              		.loc 1 174 5 view .LVU727
 2814 0cb0 0C0057E1 		cmp	r7, ip	@ npix, n
 2815 0cb4 F9FFFFCA 		bgt	.L167		@,
 2816              	.LVL189:
 2817              	.L160:
 174:armwave.c     ****         // Read a 32-bit word at a time.  If any bits are nonzero, we need to process
 2818              		.loc 1 174 5 view .LVU728
 2819              	.LBE43:
 2820              	.LBE45:
 2821              	@ armwave.c:465: }
 465:armwave.c     **** }
 2822              		.loc 1 465 1 view .LVU729
 2823 0cb8 0CD08DE2 		add	sp, sp, #12	@,,
 2824              		.cfi_remember_state
 2825              		.cfi_def_cfa_offset 36
 2826              		@ sp needed	@
 2827 0cbc F08FBDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}	@
 2828              	.LVL190:
 2829              	.L176:
 2830              		.cfi_restore_state
 2831              	.LBB46:
 2832              	.LBB44:
 2833              	@ armwave.c:185:                 if(value != 0) {
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2834              		.loc 1 185 19 view .LVU730
 2835 0cc0 FF1010E2 		ands	r1, r0, #255	@ _21, wave_word,
 2836              	@ armwave.c:180:         if(COND_UNLIKELY(wave_word != 0)) {
 180:armwave.c     ****             for(w = 0; w < 4; w++) {
 2837              		.loc 1 180 11 view .LVU731
 2838 0cc4 0C60A0E1 		mov	r6, ip	@ ivtmp.118, n
 2839              	.LVL191:
 182:armwave.c     ****                 wave_word >>= 8;
 2840              		.loc 1 182 17 is_stmt 1 view .LVU732
 183:armwave.c     **** 
 2841              		.loc 1 183 17 view .LVU733
 2842              	@ armwave.c:183:                 wave_word >>= 8;
 183:armwave.c     **** 
 2843              		.loc 1 183 27 is_stmt 0 view .LVU734
 2844 0cc8 2004A0E1 		lsr	r0, r0, #8	@ wave_word, wave_word,
 2845              	.LVL192:
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2846              		.loc 1 185 17 is_stmt 1 view .LVU735
 2847 0ccc 04C08CE2 		add	ip, ip, #4	@ n, ivtmp.118,
 2848              	@ armwave.c:185:                 if(value != 0) {
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2849              		.loc 1 185 19 is_stmt 0 view .LVU736
 2850 0cd0 0500001A 		bne	.L180		@,
 2851              	.LVL193:
 2852              	.L164:
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2853              		.loc 1 185 19 view .LVU737
 2854 0cd4 016086E2 		add	r6, r6, #1	@ ivtmp.118, ivtmp.118,
 2855              	@ armwave.c:181:             for(w = 0; w < 4; w++) {
 181:armwave.c     ****                 value = wave_word & 0xff;
 2856              		.loc 1 181 13 view .LVU738
 2857 0cd8 06005CE1 		cmp	ip, r6	@ n, ivtmp.118
 2858 0cdc F3FFFF0A 		beq	.L163		@,
 182:armwave.c     ****                 wave_word >>= 8;
 2859              		.loc 1 182 17 is_stmt 1 view .LVU739
 2860              	.LVL194:
 183:armwave.c     **** 
 2861              		.loc 1 183 17 view .LVU740
 2862              	@ armwave.c:185:                 if(value != 0) {
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2863              		.loc 1 185 19 is_stmt 0 view .LVU741
 2864 0ce0 FF1010E2 		ands	r1, r0, #255	@ _21, wave_word,
 2865              	@ armwave.c:183:                 wave_word >>= 8;
 183:armwave.c     **** 
 2866              		.loc 1 183 27 view .LVU742
 2867 0ce4 2004A0E1 		lsr	r0, r0, #8	@ wave_word, wave_word,
 2868              	.LVL195:
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2869              		.loc 1 185 17 is_stmt 1 view .LVU743
 2870              	@ armwave.c:185:                 if(value != 0) {
 185:armwave.c     ****                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 2871              		.loc 1 185 19 is_stmt 0 view .LVU744
 2872 0ce8 F9FFFF0A 		beq	.L164		@,
 2873              	.L180:
 186:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 2874              		.loc 1 186 21 is_stmt 1 view .LVU745
 2875              	.LVL196:
 187:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 2876              		.loc 1 187 21 view .LVU746
 188:armwave.c     **** 
 2877              		.loc 1 188 21 view .LVU747
 190:armwave.c     ****                     g = MIN(gg, 255);
 2878              		.loc 1 190 21 view .LVU748
 191:armwave.c     ****                     b = MIN(bb, 255);
 2879              		.loc 1 191 21 view .LVU749
 192:armwave.c     **** 
 2880              		.loc 1 192 21 view .LVU750
 195:armwave.c     **** 
 2881              		.loc 1 195 21 view .LVU751
 2882              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2883              		.loc 1 210 32 is_stmt 0 view .LVU752
 2884 0cec 7630EFE6 		uxtb	r3, r6	@ _49, ivtmp.118
 2885              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 2886              		.loc 1 211 41 view .LVU753
 2887 0cf0 012083E2 		add	r2, r3, #1	@ tmp198, _49,
 2888              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2889              		.loc 1 210 40 view .LVU754
 2890 0cf4 903A07EE 		vmov	s15, r3	@ int	@ _49, _49
 2891              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 2892              		.loc 1 211 41 view .LVU755
 2893 0cf8 102A07EE 		vmov	s14, r2	@ int	@ tmp198, tmp198
 2894              	@ armwave.c:188:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 188:armwave.c     **** 
 2895              		.loc 1 188 55 view .LVU756
 2896 0cfc 940103E0 		mul	r3, r4, r1	@ tmp183, _29, _21
 2897              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2898              		.loc 1 210 40 view .LVU757
 2899 0d00 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp196, _49
 2900              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 2901              		.loc 1 211 46 view .LVU758
 2902 0d04 C77AB8EE 		vcvt.f32.s32	s14, s14	@ tmp199, tmp198
 2903              	@ armwave.c:187:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 187:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 2904              		.loc 1 187 55 view .LVU759
 2905 0d08 9A0102E0 		mul	r2, r10, r1	@ tmp187, _25, _21
 2906              	@ armwave.c:188:                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 188:armwave.c     **** 
 2907              		.loc 1 188 24 view .LVU760
 2908 0d0c 4334A0E1 		asr	r3, r3, #8	@ bb, tmp183,
 2909              	.LVL197:
 2910              	@ armwave.c:192:                     b = MIN(bb, 255);
 192:armwave.c     **** 
 2911              		.loc 1 192 25 view .LVU761
 2912 0d10 FF0053E3 		cmp	r3, #255	@ bb,
 2913              	@ armwave.c:187:                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 187:armwave.c     ****                     bb = (g_armwave_state.ch1_color.b * value) >> 8;
 2914              		.loc 1 187 24 view .LVU762
 2915 0d14 4224A0E1 		asr	r2, r2, #8	@ gg, tmp187,
 2916              	.LVL198:
 2917              	@ armwave.c:192:                     b = MIN(bb, 255);
 192:armwave.c     **** 
 2918              		.loc 1 192 25 view .LVU763
 2919 0d18 FF30A0A3 		movge	r3, #255	@ bb,
 2920              	.LVL199:
 2921              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2922              		.loc 1 210 40 view .LVU764
 2923 0d1c A67A67EE 		vmul.f32	s15, s15, s13	@ tmp197, tmp196, _51
 2924              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 2925              		.loc 1 211 46 view .LVU765
 2926 0d20 267A27EE 		vmul.f32	s14, s14, s13	@ tmp200, tmp199, _51
 2927              	@ armwave.c:191:                     g = MIN(gg, 255);
 191:armwave.c     ****                     b = MIN(bb, 255);
 2928              		.loc 1 191 25 view .LVU766
 2929 0d24 FF0052E3 		cmp	r2, #255	@ gg,
 2930 0d28 FF20A0A3 		movge	r2, #255	@ gg,
 2931              	.LVL200:
 2932              	@ armwave.c:186:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 186:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 2933              		.loc 1 186 55 view .LVU767
 2934 0d2c 910B01E0 		mul	r1, r1, fp	@ tmp193, _21, _19
 2935              	.LVL201:
 2936              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 2937              		.loc 1 195 56 view .LVU768
 2938 0d30 0224A0E1 		lsl	r2, r2, #8	@ tmp188, gg,
 2939              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 2940              		.loc 1 195 44 view .LVU769
 2941 0d34 0338A0E1 		lsl	r3, r3, #16	@ tmp184, bb,
 2942              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2943              		.loc 1 210 24 view .LVU770
 2944 0d38 E77AFCEE 		vcvt.u32.f32	s15, s15	@ yy, tmp197
 2945              	@ armwave.c:186:                     rr = (g_armwave_state.ch1_color.r * value) >> 8;
 186:armwave.c     ****                     gg = (g_armwave_state.ch1_color.g * value) >> 8;
 2946              		.loc 1 186 24 view .LVU771
 2947 0d3c 4114A0E1 		asr	r1, r1, #8	@ rr, tmp193,
 2948              	.LVL202:
 2949              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 2950              		.loc 1 195 56 view .LVU772
 2951 0d40 7220FFE6 		uxth	r2, r2	@ tmp189, tmp188
 2952              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 2953              		.loc 1 195 44 view .LVU773
 2954 0d44 FF3803E2 		and	r3, r3, #16711680	@ tmp185, tmp184,
 2955              	@ armwave.c:190:                     r = MIN(rr, 255);
 190:armwave.c     ****                     g = MIN(gg, 255);
 2956              		.loc 1 190 25 view .LVU774
 2957 0d48 FF0051E3 		cmp	r1, #255	@ rr,
 2958              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 2959              		.loc 1 195 51 view .LVU775
 2960 0d4c 023083E1 		orr	r3, r3, r2	@ tmp191, tmp185, tmp189
 2961              	@ armwave.c:190:                     r = MIN(rr, 255);
 190:armwave.c     ****                     g = MIN(gg, 255);
 2962              		.loc 1 190 25 view .LVU776
 2963 0d50 FF10A0A3 		movge	r1, #255	@ rr,
 2964              	.LVL203:
 2965              	@ armwave.c:210:                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2966              		.loc 1 210 24 view .LVU777
 2967 0d54 90EA17EE 		vmov	lr, s15	@ int	@ yy, yy
 2968              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 2969              		.loc 1 211 24 view .LVU778
 2970 0d58 C77AFCEE 		vcvt.u32.f32	s15, s14	@ ye, tmp200
 2971              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 2972              		.loc 1 195 62 view .LVU779
 2973 0d5c 7110EFE6 		uxtb	r1, r1	@ rr, rr
 2974 0d60 013083E1 		orr	r3, r3, r1	@ tmp195, tmp191, rr
 2975              	@ armwave.c:195:                     word = 0xff000000 | (b << 16) | (g << 8) | r;
 195:armwave.c     **** 
 2976              		.loc 1 195 26 view .LVU780
 2977 0d64 FF3483E3 		orr	r3, r3, #-16777216	@ word, tmp195,
 2978              	.LVL204:
 209:armwave.c     ****                     yy = (nsub & 0xff) * g_armwave_state.vscale_frac;
 2979              		.loc 1 209 21 is_stmt 1 view .LVU781
 210:armwave.c     ****                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 2980              		.loc 1 210 21 view .LVU782
 211:armwave.c     ****                     xx = (nsub >> 8);
 2981              		.loc 1 211 21 view .LVU783
 212:armwave.c     **** 
 2982              		.loc 1 212 21 view .LVU784
 2983              	@ armwave.c:212:                     xx = (nsub >> 8);
 212:armwave.c     **** 
 2984              		.loc 1 212 32 is_stmt 0 view .LVU785
 2985 0d68 4614A0E1 		asr	r1, r6, #8	@ xx, ivtmp.118,
 2986              	.LVL205:
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2987              		.loc 1 214 21 is_stmt 1 view .LVU786
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2988              		.loc 1 214 21 is_stmt 0 view .LVU787
 2989 0d6c 902A17EE 		vmov	r2, s15	@ int	@ ye,
 2990              	@ armwave.c:211:                     ye = ((nsub & 0xff) + 1) * g_armwave_state.vscale_frac;
 211:armwave.c     ****                     xx = (nsub >> 8);
 2991              		.loc 1 211 24 view .LVU788
 2992 0d70 007ACDED 		vstr.32	s15, [sp]	@ int	@ ye, %sfp
 2993              	.LVL206:
 2994              	@ armwave.c:214:                     for(y = yy; y < ye; y++) {
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 2995              		.loc 1 214 21 view .LVU789
 2996 0d74 02005EE1 		cmp	lr, r2	@ yy, ye
 2997 0d78 D5FFFF2A 		bcs	.L164		@,
 2998 0d7c 04008DE5 		str	r0, [sp, #4]	@ wave_word, %sfp
 2999              	.LVL207:
 3000              	.L165:
 215:armwave.c     ****                         *(out_buffer_base + offset) = word;
 3001              		.loc 1 215 25 is_stmt 1 view .LVU790
 216:armwave.c     ****                     }
 3002              		.loc 1 216 25 view .LVU791
 3003              	@ armwave.c:215:                         offset = (xx + (y * g_armwave_state.target_width)); 
 215:armwave.c     ****                         *(out_buffer_base + offset) = word;
 3004              		.loc 1 215 43 is_stmt 0 view .LVU792
 3005 0d80 582095E5 		ldr	r2, [r5, #88]	@ g_armwave_state.target_width, g_armwave_state.target_width
 3006              	@ armwave.c:214:                     for(y = yy; y < ye; y++) {
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 3007              		.loc 1 214 21 view .LVU793
 3008 0d84 00009DE5 		ldr	r0, [sp]	@ ye, %sfp
 3009              	@ armwave.c:216:                         *(out_buffer_base + offset) = word;
 216:armwave.c     ****                     }
 3010              		.loc 1 216 43 view .LVU794
 3011 0d88 921E22E0 		mla	r2, r2, lr, r1	@ tmp204, g_armwave_state.target_width, yy, xx
 3012              	.LVL208:
 3013              	@ armwave.c:214:                     for(y = yy; y < ye; y++) {
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 3014              		.loc 1 214 42 view .LVU795
 3015 0d8c 01E08EE2 		add	lr, lr, #1	@ yy, yy,
 3016              	.LVL209:
 3017              	@ armwave.c:214:                     for(y = yy; y < ye; y++) {
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 3018              		.loc 1 214 21 view .LVU796
 3019 0d90 0E0050E1 		cmp	r0, lr	@ ye, yy
 3020              	@ armwave.c:216:                         *(out_buffer_base + offset) = word;
 216:armwave.c     ****                     }
 3021              		.loc 1 216 53 view .LVU797
 3022 0d94 023188E7 		str	r3, [r8, r2, lsl #2]	@ word, *_66
 3023              	@ armwave.c:214:                     for(y = yy; y < ye; y++) {
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 3024              		.loc 1 214 21 view .LVU798
 3025 0d98 F8FFFF1A 		bne	.L165		@,
 214:armwave.c     ****                         offset = (xx + (y * g_armwave_state.target_width)); 
 3026              		.loc 1 214 21 view .LVU799
 3027 0d9c 04009DE5 		ldr	r0, [sp, #4]	@ wave_word, %sfp
 3028 0da0 CBFFFFEA 		b	.L164		@
 3029              	.LVL210:
 3030              	.L179:
 169:armwave.c     **** 
 3031              		.loc 1 169 5 is_stmt 1 view .LVU800
 3032 0da4 10309FE5 		ldr	r3, .L181+4	@,
 3033 0da8 A920A0E3 		mov	r2, #169	@,
 3034 0dac 0C109FE5 		ldr	r1, .L181+8	@,
 3035 0db0 0C009FE5 		ldr	r0, .L181+12	@,
 3036              	.LVL211:
 169:armwave.c     **** 
 3037              		.loc 1 169 5 is_stmt 0 view .LVU801
 3038 0db4 FEFFFFEB 		bl	__assert_fail		@
 3039              	.LVL212:
 3040              	.L182:
 3041              		.align	2
 3042              	.L181:
 3043 0db8 00000000 		.word	g_armwave_state
 3044 0dbc 00000000 		.word	.LANCHOR0
 3045 0dc0 20000000 		.word	.LC2
 3046 0dc4 2C000000 		.word	.LC3
 3047              	.LBE44:
 3048              	.LBE46:
 3049              		.cfi_endproc
 3050              	.LFE72:
 3052              		.align	2
 3053              		.global	armwave_test_buffer_alloc
 3054              		.syntax unified
 3055              		.arm
 3056              		.fpu vfp
 3058              	armwave_test_buffer_alloc:
 3059              	.LVL213:
 3060              	.LFB73:
 466:armwave.c     **** 
 467:armwave.c     **** /*
 468:armwave.c     ****  * Allocate a test buffer, freeing any existing buffer.
 469:armwave.c     ****  */
 470:armwave.c     **** void armwave_test_buffer_alloc(int nsets)
 471:armwave.c     **** {
 3061              		.loc 1 471 1 is_stmt 1 view -0
 3062              		.cfi_startproc
 3063              		@ args = 0, pretend = 0, frame = 0
 3064              		@ frame_needed = 0, uses_anonymous_args = 0
 472:armwave.c     ****     if(g_armwave_state.test_wave_buffer != NULL) {
 3065              		.loc 1 472 5 view .LVU803
 3066              	@ armwave.c:471: {
 471:armwave.c     ****     if(g_armwave_state.test_wave_buffer != NULL) {
 3067              		.loc 1 471 1 is_stmt 0 view .LVU804
 3068 0dc8 70402DE9 		push	{r4, r5, r6, lr}	@
 3069              		.cfi_def_cfa_offset 16
 3070              		.cfi_offset 4, -16
 3071              		.cfi_offset 5, -12
 3072              		.cfi_offset 6, -8
 3073              		.cfi_offset 14, -4
 3074              	@ armwave.c:471: {
 471:armwave.c     ****     if(g_armwave_state.test_wave_buffer != NULL) {
 3075              		.loc 1 471 1 view .LVU805
 3076 0dcc 0060A0E1 		mov	r6, r0	@ nsets, nsets
 3077              	@ armwave.c:472:     if(g_armwave_state.test_wave_buffer != NULL) {
 3078              		.loc 1 472 23 view .LVU806
 3079 0dd0 44409FE5 		ldr	r4, .L190	@ tmp128,
 3080 0dd4 180094E5 		ldr	r0, [r4, #24]	@ _1, g_armwave_state.test_wave_buffer
 3081              	.LVL214:
 3082              	@ armwave.c:472:     if(g_armwave_state.test_wave_buffer != NULL) {
 3083              		.loc 1 472 7 view .LVU807
 3084 0dd8 000050E3 		cmp	r0, #0	@ _1,
 3085 0ddc 0000000A 		beq	.L184		@,
 473:armwave.c     ****         free(g_armwave_state.test_wave_buffer);
 3086              		.loc 1 473 9 is_stmt 1 view .LVU808
 3087 0de0 FEFFFFEB 		bl	free		@
 3088              	.LVL215:
 3089              	.L184:
 474:armwave.c     ****     }
 475:armwave.c     **** 
 476:armwave.c     ****     //printf("armwave_test_buffer_alloc: length=%d max=%d\n", g_armwave_state.wave_length, g_armwav
 477:armwave.c     **** 
 478:armwave.c     ****     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armwave_state.waves_m
 3090              		.loc 1 478 5 view .LVU809
 3091              	@ armwave.c:478:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 3092              		.loc 1 478 75 is_stmt 0 view .LVU810
 3093 0de4 4C3094E5 		ldr	r3, [r4, #76]	@ g_armwave_state.wave_length, g_armwave_state.wave_length
 3094 0de8 3C5094E5 		ldr	r5, [r4, #60]	@ g_armwave_state.waves_max, g_armwave_state.waves_max
 3095              	@ armwave.c:478:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 3096              		.loc 1 478 40 view .LVU811
 3097 0dec 0610A0E1 		mov	r1, r6	@, nsets
 3098              	@ armwave.c:478:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 3099              		.loc 1 478 75 view .LVU812
 3100 0df0 950305E0 		mul	r5, r5, r3	@ _4, g_armwave_state.waves_max, g_armwave_state.wave_length
 3101              	@ armwave.c:478:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 3102              		.loc 1 478 40 view .LVU813
 3103 0df4 0500A0E1 		mov	r0, r5	@, _4
 3104 0df8 FEFFFFEB 		bl	calloc		@
 3105              	.LVL216:
 3106              	@ armwave.c:480:     if(g_armwave_state.test_wave_buffer == NULL) {
 479:armwave.c     **** 
 480:armwave.c     ****     if(g_armwave_state.test_wave_buffer == NULL) {
 3107              		.loc 1 480 7 view .LVU814
 3108 0dfc 000050E3 		cmp	r0, #0	@ tmp124,
 3109              	@ armwave.c:478:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 478:armwave.c     **** 
 3110              		.loc 1 478 38 view .LVU815
 3111 0e00 180084E5 		str	r0, [r4, #24]	@ tmp124, g_armwave_state.test_wave_buffer
 3112              		.loc 1 480 5 is_stmt 1 view .LVU816
 3113              	@ armwave.c:480:     if(g_armwave_state.test_wave_buffer == NULL) {
 3114              		.loc 1 480 7 is_stmt 0 view .LVU817
 3115 0e04 7080BD18 		popne	{r4, r5, r6, pc}	@
 481:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes, %d sets)\
 3116              		.loc 1 481 9 is_stmt 1 view .LVU818
 3117 0e08 960501E0 		mul	r1, r6, r5	@, nsets, _4
 3118 0e0c 0620A0E1 		mov	r2, r6	@, nsets
 3119 0e10 08009FE5 		ldr	r0, .L190+4	@,
 3120              	@ armwave.c:485: }
 482:armwave.c     ****             g_armwave_state.wave_length * g_armwave_state.waves_max * nsets, nsets);
 483:armwave.c     ****         return;
 484:armwave.c     ****     }
 485:armwave.c     **** }
 3121              		.loc 1 485 1 is_stmt 0 view .LVU819
 3122 0e14 7040BDE8 		pop	{r4, r5, r6, lr}	@
 3123              		.cfi_restore 14
 3124              		.cfi_restore 6
 3125              		.cfi_restore 5
 3126              		.cfi_restore 4
 3127              		.cfi_def_cfa_offset 0
 3128              	.LVL217:
 3129              	@ armwave.c:481:         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d
 481:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes, %d sets)\
 3130              		.loc 1 481 9 view .LVU820
 3131 0e18 FEFFFFEA 		b	printf		@
 3132              	.LVL218:
 3133              	.L191:
 481:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes, %d sets)\
 3134              		.loc 1 481 9 view .LVU821
 3135              		.align	2
 3136              	.L190:
 3137 0e1c 00000000 		.word	g_armwave_state
 3138 0e20 BC010000 		.word	.LC18
 3139              		.cfi_endproc
 3140              	.LFE73:
 3142              		.align	2
 3143              		.global	armwave_fill_pixbuf_into_pybuffer
 3144              		.syntax unified
 3145              		.arm
 3146              		.fpu vfp
 3148              	armwave_fill_pixbuf_into_pybuffer:
 3149              	.LVL219:
 3150              	.LFB74:
 486:armwave.c     **** 
 487:armwave.c     **** /*
 488:armwave.c     ****  * Fill a pixbuf PyBuffer with a rendered waveform.
 489:armwave.c     ****  */
 490:armwave.c     **** PyObject *armwave_fill_pixbuf_into_pybuffer(PyObject *buf_obj)
 491:armwave.c     **** {
 3151              		.loc 1 491 1 is_stmt 1 view -0
 3152              		.cfi_startproc
 3153              		@ args = 0, pretend = 0, frame = 48
 3154              		@ frame_needed = 0, uses_anonymous_args = 0
 492:armwave.c     ****     Py_buffer buffer;
 3155              		.loc 1 492 5 view .LVU823
 493:armwave.c     ****     int ret;
 3156              		.loc 1 493 5 view .LVU824
 494:armwave.c     **** 
 495:armwave.c     ****     //printf("armwave_fill_pixbuf_into_pybuffer: start\n");
 496:armwave.c     **** 
 497:armwave.c     ****     ret = PyObject_GetBuffer(buf_obj, &buffer, PyBUF_SIMPLE | PyBUF_WRITABLE);
 3157              		.loc 1 497 5 view .LVU825
 3158              	@ armwave.c:491: {
 491:armwave.c     ****     Py_buffer buffer;
 3159              		.loc 1 491 1 is_stmt 0 view .LVU826
 3160 0e24 04E02DE5 		str	lr, [sp, #-4]!	@,
 3161              		.cfi_def_cfa_offset 4
 3162              		.cfi_offset 14, -4
 3163 0e28 34D04DE2 		sub	sp, sp, #52	@,,
 3164              		.cfi_def_cfa_offset 56
 3165              	@ armwave.c:497:     ret = PyObject_GetBuffer(buf_obj, &buffer, PyBUF_SIMPLE | PyBUF_WRITABLE);
 3166              		.loc 1 497 11 view .LVU827
 3167 0e2c 04108DE2 		add	r1, sp, #4	@ tmp131,,
 3168 0e30 0120A0E3 		mov	r2, #1	@,
 3169 0e34 FEFFFFEB 		bl	PyObject_GetBuffer		@
 3170              	.LVL220:
 498:armwave.c     **** 
 499:armwave.c     ****     if(ret != 0) {
 3171              		.loc 1 499 5 is_stmt 1 view .LVU828
 3172              	@ armwave.c:499:     if(ret != 0) {
 3173              		.loc 1 499 7 is_stmt 0 view .LVU829
 3174 0e38 000050E3 		cmp	r0, #0	@,
 3175 0e3c 0A00001A 		bne	.L196		@,
 500:armwave.c     ****         printf("armwave_fill_pixbuf_into_pybuffer: PyObject_GetBuffer() failed, returning PyFalse\n
 501:armwave.c     ****         Py_RETURN_FALSE;
 502:armwave.c     ****     }
 503:armwave.c     **** 
 504:armwave.c     ****     //printf("PyObject_GetBuffer did not trigger assert: buffer->buf=0x%08x, buffer->obj=0x%08x, bu
 505:armwave.c     **** 
 506:armwave.c     ****     armwave_fill_pixbuf_scaled(buffer.buf);
 3176              		.loc 1 506 5 is_stmt 1 view .LVU830
 3177 0e40 04009DE5 		ldr	r0, [sp, #4]	@, buffer.buf
 3178              	.LVL221:
 3179              		.loc 1 506 5 is_stmt 0 view .LVU831
 3180 0e44 FEFFFFEB 		bl	armwave_fill_pixbuf_scaled		@
 3181              	.LVL222:
 507:armwave.c     ****     //printf("armwave_fill_pixbuf_into_pybuffer: buffer fill done\n");
 508:armwave.c     **** 
 509:armwave.c     ****     PyBuffer_Release(&buffer);
 3182              		.loc 1 509 5 is_stmt 1 view .LVU832
 3183 0e48 04008DE2 		add	r0, sp, #4	@ tmp132,,
 3184 0e4c FEFFFFEB 		bl	PyBuffer_Release		@
 3185              	.LVL223:
 510:armwave.c     ****     //printf("armwave_fill_pixbuf_into_pybuffer: done\n");
 511:armwave.c     **** 
 512:armwave.c     ****     Py_RETURN_TRUE;
 3186              		.loc 1 512 5 view .LVU833
 3187              	.LBB47:
 3188              	.LBI47:
 3189              		.file 2 "/usr/local/include/python3.8/object.h"
   1:/usr/local/include/python3.8/object.h **** #ifndef Py_OBJECT_H
   2:/usr/local/include/python3.8/object.h **** #define Py_OBJECT_H
   3:/usr/local/include/python3.8/object.h **** 
   4:/usr/local/include/python3.8/object.h **** #include "pymem.h"   /* _Py_tracemalloc_config */
   5:/usr/local/include/python3.8/object.h **** 
   6:/usr/local/include/python3.8/object.h **** #ifdef __cplusplus
   7:/usr/local/include/python3.8/object.h **** extern "C" {
   8:/usr/local/include/python3.8/object.h **** #endif
   9:/usr/local/include/python3.8/object.h **** 
  10:/usr/local/include/python3.8/object.h **** 
  11:/usr/local/include/python3.8/object.h **** /* Object and type object interface */
  12:/usr/local/include/python3.8/object.h **** 
  13:/usr/local/include/python3.8/object.h **** /*
  14:/usr/local/include/python3.8/object.h **** Objects are structures allocated on the heap.  Special rules apply to
  15:/usr/local/include/python3.8/object.h **** the use of objects to ensure they are properly garbage-collected.
  16:/usr/local/include/python3.8/object.h **** Objects are never allocated statically or on the stack; they must be
  17:/usr/local/include/python3.8/object.h **** accessed through special macros and functions only.  (Type objects are
  18:/usr/local/include/python3.8/object.h **** exceptions to the first rule; the standard types are represented by
  19:/usr/local/include/python3.8/object.h **** statically initialized type objects, although work on type/class unification
  20:/usr/local/include/python3.8/object.h **** for Python 2.2 made it possible to have heap-allocated type objects too).
  21:/usr/local/include/python3.8/object.h **** 
  22:/usr/local/include/python3.8/object.h **** An object has a 'reference count' that is increased or decreased when a
  23:/usr/local/include/python3.8/object.h **** pointer to the object is copied or deleted; when the reference count
  24:/usr/local/include/python3.8/object.h **** reaches zero there are no references to the object left and it can be
  25:/usr/local/include/python3.8/object.h **** removed from the heap.
  26:/usr/local/include/python3.8/object.h **** 
  27:/usr/local/include/python3.8/object.h **** An object has a 'type' that determines what it represents and what kind
  28:/usr/local/include/python3.8/object.h **** of data it contains.  An object's type is fixed when it is created.
  29:/usr/local/include/python3.8/object.h **** Types themselves are represented as objects; an object contains a
  30:/usr/local/include/python3.8/object.h **** pointer to the corresponding type object.  The type itself has a type
  31:/usr/local/include/python3.8/object.h **** pointer pointing to the object representing the type 'type', which
  32:/usr/local/include/python3.8/object.h **** contains a pointer to itself!.
  33:/usr/local/include/python3.8/object.h **** 
  34:/usr/local/include/python3.8/object.h **** Objects do not float around in memory; once allocated an object keeps
  35:/usr/local/include/python3.8/object.h **** the same size and address.  Objects that must hold variable-size data
  36:/usr/local/include/python3.8/object.h **** can contain pointers to variable-size parts of the object.  Not all
  37:/usr/local/include/python3.8/object.h **** objects of the same type have the same size; but the size cannot change
  38:/usr/local/include/python3.8/object.h **** after allocation.  (These restrictions are made so a reference to an
  39:/usr/local/include/python3.8/object.h **** object can be simply a pointer -- moving an object would require
  40:/usr/local/include/python3.8/object.h **** updating all the pointers, and changing an object's size would require
  41:/usr/local/include/python3.8/object.h **** moving it if there was another object right next to it.)
  42:/usr/local/include/python3.8/object.h **** 
  43:/usr/local/include/python3.8/object.h **** Objects are always accessed through pointers of the type 'PyObject *'.
  44:/usr/local/include/python3.8/object.h **** The type 'PyObject' is a structure that only contains the reference count
  45:/usr/local/include/python3.8/object.h **** and the type pointer.  The actual memory allocated for an object
  46:/usr/local/include/python3.8/object.h **** contains other data that can only be accessed after casting the pointer
  47:/usr/local/include/python3.8/object.h **** to a pointer to a longer structure type.  This longer type must start
  48:/usr/local/include/python3.8/object.h **** with the reference count and type fields; the macro PyObject_HEAD should be
  49:/usr/local/include/python3.8/object.h **** used for this (to accommodate for future changes).  The implementation
  50:/usr/local/include/python3.8/object.h **** of a particular object type can cast the object pointer to the proper
  51:/usr/local/include/python3.8/object.h **** type and back.
  52:/usr/local/include/python3.8/object.h **** 
  53:/usr/local/include/python3.8/object.h **** A standard interface exists for objects that contain an array of items
  54:/usr/local/include/python3.8/object.h **** whose size is determined when the object is allocated.
  55:/usr/local/include/python3.8/object.h **** */
  56:/usr/local/include/python3.8/object.h **** 
  57:/usr/local/include/python3.8/object.h **** /* Py_DEBUG implies Py_REF_DEBUG. */
  58:/usr/local/include/python3.8/object.h **** #if defined(Py_DEBUG) && !defined(Py_REF_DEBUG)
  59:/usr/local/include/python3.8/object.h **** #define Py_REF_DEBUG
  60:/usr/local/include/python3.8/object.h **** #endif
  61:/usr/local/include/python3.8/object.h **** 
  62:/usr/local/include/python3.8/object.h **** #if defined(Py_LIMITED_API) && defined(Py_REF_DEBUG)
  63:/usr/local/include/python3.8/object.h **** #error Py_LIMITED_API is incompatible with Py_DEBUG, Py_TRACE_REFS, and Py_REF_DEBUG
  64:/usr/local/include/python3.8/object.h **** #endif
  65:/usr/local/include/python3.8/object.h **** 
  66:/usr/local/include/python3.8/object.h **** 
  67:/usr/local/include/python3.8/object.h **** #ifdef Py_TRACE_REFS
  68:/usr/local/include/python3.8/object.h **** /* Define pointers to support a doubly-linked list of all live heap objects. */
  69:/usr/local/include/python3.8/object.h **** #define _PyObject_HEAD_EXTRA            \
  70:/usr/local/include/python3.8/object.h ****     struct _object *_ob_next;           \
  71:/usr/local/include/python3.8/object.h ****     struct _object *_ob_prev;
  72:/usr/local/include/python3.8/object.h **** 
  73:/usr/local/include/python3.8/object.h **** #define _PyObject_EXTRA_INIT 0, 0,
  74:/usr/local/include/python3.8/object.h **** 
  75:/usr/local/include/python3.8/object.h **** #else
  76:/usr/local/include/python3.8/object.h **** #define _PyObject_HEAD_EXTRA
  77:/usr/local/include/python3.8/object.h **** #define _PyObject_EXTRA_INIT
  78:/usr/local/include/python3.8/object.h **** #endif
  79:/usr/local/include/python3.8/object.h **** 
  80:/usr/local/include/python3.8/object.h **** /* PyObject_HEAD defines the initial segment of every PyObject. */
  81:/usr/local/include/python3.8/object.h **** #define PyObject_HEAD                   PyObject ob_base;
  82:/usr/local/include/python3.8/object.h **** 
  83:/usr/local/include/python3.8/object.h **** #define PyObject_HEAD_INIT(type)        \
  84:/usr/local/include/python3.8/object.h ****     { _PyObject_EXTRA_INIT              \
  85:/usr/local/include/python3.8/object.h ****     1, type },
  86:/usr/local/include/python3.8/object.h **** 
  87:/usr/local/include/python3.8/object.h **** #define PyVarObject_HEAD_INIT(type, size)       \
  88:/usr/local/include/python3.8/object.h ****     { PyObject_HEAD_INIT(type) size },
  89:/usr/local/include/python3.8/object.h **** 
  90:/usr/local/include/python3.8/object.h **** /* PyObject_VAR_HEAD defines the initial segment of all variable-size
  91:/usr/local/include/python3.8/object.h ****  * container objects.  These end with a declaration of an array with 1
  92:/usr/local/include/python3.8/object.h ****  * element, but enough space is malloc'ed so that the array actually
  93:/usr/local/include/python3.8/object.h ****  * has room for ob_size elements.  Note that ob_size is an element count,
  94:/usr/local/include/python3.8/object.h ****  * not necessarily a byte count.
  95:/usr/local/include/python3.8/object.h ****  */
  96:/usr/local/include/python3.8/object.h **** #define PyObject_VAR_HEAD      PyVarObject ob_base;
  97:/usr/local/include/python3.8/object.h **** #define Py_INVALID_SIZE (Py_ssize_t)-1
  98:/usr/local/include/python3.8/object.h **** 
  99:/usr/local/include/python3.8/object.h **** /* Nothing is actually declared to be a PyObject, but every pointer to
 100:/usr/local/include/python3.8/object.h ****  * a Python object can be cast to a PyObject*.  This is inheritance built
 101:/usr/local/include/python3.8/object.h ****  * by hand.  Similarly every pointer to a variable-size Python object can,
 102:/usr/local/include/python3.8/object.h ****  * in addition, be cast to PyVarObject*.
 103:/usr/local/include/python3.8/object.h ****  */
 104:/usr/local/include/python3.8/object.h **** typedef struct _object {
 105:/usr/local/include/python3.8/object.h ****     _PyObject_HEAD_EXTRA
 106:/usr/local/include/python3.8/object.h ****     Py_ssize_t ob_refcnt;
 107:/usr/local/include/python3.8/object.h ****     struct _typeobject *ob_type;
 108:/usr/local/include/python3.8/object.h **** } PyObject;
 109:/usr/local/include/python3.8/object.h **** 
 110:/usr/local/include/python3.8/object.h **** /* Cast argument to PyObject* type. */
 111:/usr/local/include/python3.8/object.h **** #define _PyObject_CAST(op) ((PyObject*)(op))
 112:/usr/local/include/python3.8/object.h **** 
 113:/usr/local/include/python3.8/object.h **** typedef struct {
 114:/usr/local/include/python3.8/object.h ****     PyObject ob_base;
 115:/usr/local/include/python3.8/object.h ****     Py_ssize_t ob_size; /* Number of items in variable part */
 116:/usr/local/include/python3.8/object.h **** } PyVarObject;
 117:/usr/local/include/python3.8/object.h **** 
 118:/usr/local/include/python3.8/object.h **** /* Cast argument to PyVarObject* type. */
 119:/usr/local/include/python3.8/object.h **** #define _PyVarObject_CAST(op) ((PyVarObject*)(op))
 120:/usr/local/include/python3.8/object.h **** 
 121:/usr/local/include/python3.8/object.h **** #define Py_REFCNT(ob)           (_PyObject_CAST(ob)->ob_refcnt)
 122:/usr/local/include/python3.8/object.h **** #define Py_TYPE(ob)             (_PyObject_CAST(ob)->ob_type)
 123:/usr/local/include/python3.8/object.h **** #define Py_SIZE(ob)             (_PyVarObject_CAST(ob)->ob_size)
 124:/usr/local/include/python3.8/object.h **** 
 125:/usr/local/include/python3.8/object.h **** /*
 126:/usr/local/include/python3.8/object.h **** Type objects contain a string containing the type name (to help somewhat
 127:/usr/local/include/python3.8/object.h **** in debugging), the allocation parameters (see PyObject_New() and
 128:/usr/local/include/python3.8/object.h **** PyObject_NewVar()),
 129:/usr/local/include/python3.8/object.h **** and methods for accessing objects of the type.  Methods are optional, a
 130:/usr/local/include/python3.8/object.h **** nil pointer meaning that particular kind of access is not available for
 131:/usr/local/include/python3.8/object.h **** this type.  The Py_DECREF() macro uses the tp_dealloc method without
 132:/usr/local/include/python3.8/object.h **** checking for a nil pointer; it should always be implemented except if
 133:/usr/local/include/python3.8/object.h **** the implementation can guarantee that the reference count will never
 134:/usr/local/include/python3.8/object.h **** reach zero (e.g., for statically allocated type objects).
 135:/usr/local/include/python3.8/object.h **** 
 136:/usr/local/include/python3.8/object.h **** NB: the methods for certain type groups are now contained in separate
 137:/usr/local/include/python3.8/object.h **** method blocks.
 138:/usr/local/include/python3.8/object.h **** */
 139:/usr/local/include/python3.8/object.h **** 
 140:/usr/local/include/python3.8/object.h **** typedef PyObject * (*unaryfunc)(PyObject *);
 141:/usr/local/include/python3.8/object.h **** typedef PyObject * (*binaryfunc)(PyObject *, PyObject *);
 142:/usr/local/include/python3.8/object.h **** typedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);
 143:/usr/local/include/python3.8/object.h **** typedef int (*inquiry)(PyObject *);
 144:/usr/local/include/python3.8/object.h **** typedef Py_ssize_t (*lenfunc)(PyObject *);
 145:/usr/local/include/python3.8/object.h **** typedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);
 146:/usr/local/include/python3.8/object.h **** typedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);
 147:/usr/local/include/python3.8/object.h **** typedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);
 148:/usr/local/include/python3.8/object.h **** typedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);
 149:/usr/local/include/python3.8/object.h **** typedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);
 150:/usr/local/include/python3.8/object.h **** 
 151:/usr/local/include/python3.8/object.h **** typedef int (*objobjproc)(PyObject *, PyObject *);
 152:/usr/local/include/python3.8/object.h **** typedef int (*visitproc)(PyObject *, void *);
 153:/usr/local/include/python3.8/object.h **** typedef int (*traverseproc)(PyObject *, visitproc, void *);
 154:/usr/local/include/python3.8/object.h **** 
 155:/usr/local/include/python3.8/object.h **** 
 156:/usr/local/include/python3.8/object.h **** typedef void (*freefunc)(void *);
 157:/usr/local/include/python3.8/object.h **** typedef void (*destructor)(PyObject *);
 158:/usr/local/include/python3.8/object.h **** typedef PyObject *(*getattrfunc)(PyObject *, char *);
 159:/usr/local/include/python3.8/object.h **** typedef PyObject *(*getattrofunc)(PyObject *, PyObject *);
 160:/usr/local/include/python3.8/object.h **** typedef int (*setattrfunc)(PyObject *, char *, PyObject *);
 161:/usr/local/include/python3.8/object.h **** typedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);
 162:/usr/local/include/python3.8/object.h **** typedef PyObject *(*reprfunc)(PyObject *);
 163:/usr/local/include/python3.8/object.h **** typedef Py_hash_t (*hashfunc)(PyObject *);
 164:/usr/local/include/python3.8/object.h **** typedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);
 165:/usr/local/include/python3.8/object.h **** typedef PyObject *(*getiterfunc) (PyObject *);
 166:/usr/local/include/python3.8/object.h **** typedef PyObject *(*iternextfunc) (PyObject *);
 167:/usr/local/include/python3.8/object.h **** typedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);
 168:/usr/local/include/python3.8/object.h **** typedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);
 169:/usr/local/include/python3.8/object.h **** typedef int (*initproc)(PyObject *, PyObject *, PyObject *);
 170:/usr/local/include/python3.8/object.h **** typedef PyObject *(*newfunc)(struct _typeobject *, PyObject *, PyObject *);
 171:/usr/local/include/python3.8/object.h **** typedef PyObject *(*allocfunc)(struct _typeobject *, Py_ssize_t);
 172:/usr/local/include/python3.8/object.h **** 
 173:/usr/local/include/python3.8/object.h **** #ifdef Py_LIMITED_API
 174:/usr/local/include/python3.8/object.h **** /* In Py_LIMITED_API, PyTypeObject is an opaque structure. */
 175:/usr/local/include/python3.8/object.h **** typedef struct _typeobject PyTypeObject;
 176:/usr/local/include/python3.8/object.h **** #else
 177:/usr/local/include/python3.8/object.h **** /* PyTypeObject is defined in cpython/object.h */
 178:/usr/local/include/python3.8/object.h **** #endif
 179:/usr/local/include/python3.8/object.h **** 
 180:/usr/local/include/python3.8/object.h **** typedef struct{
 181:/usr/local/include/python3.8/object.h ****     int slot;    /* slot id, see below */
 182:/usr/local/include/python3.8/object.h ****     void *pfunc; /* function pointer */
 183:/usr/local/include/python3.8/object.h **** } PyType_Slot;
 184:/usr/local/include/python3.8/object.h **** 
 185:/usr/local/include/python3.8/object.h **** typedef struct{
 186:/usr/local/include/python3.8/object.h ****     const char* name;
 187:/usr/local/include/python3.8/object.h ****     int basicsize;
 188:/usr/local/include/python3.8/object.h ****     int itemsize;
 189:/usr/local/include/python3.8/object.h ****     unsigned int flags;
 190:/usr/local/include/python3.8/object.h ****     PyType_Slot *slots; /* terminated by slot==0. */
 191:/usr/local/include/python3.8/object.h **** } PyType_Spec;
 192:/usr/local/include/python3.8/object.h **** 
 193:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);
 194:/usr/local/include/python3.8/object.h **** #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
 195:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);
 196:/usr/local/include/python3.8/object.h **** #endif
 197:/usr/local/include/python3.8/object.h **** #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
 198:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void*) PyType_GetSlot(struct _typeobject*, int);
 199:/usr/local/include/python3.8/object.h **** #endif
 200:/usr/local/include/python3.8/object.h **** 
 201:/usr/local/include/python3.8/object.h **** /* Generic type check */
 202:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyType_IsSubtype(struct _typeobject *, struct _typeobject *);
 203:/usr/local/include/python3.8/object.h **** #define PyObject_TypeCheck(ob, tp) \
 204:/usr/local/include/python3.8/object.h ****     (Py_TYPE(ob) == (tp) || PyType_IsSubtype(Py_TYPE(ob), (tp)))
 205:/usr/local/include/python3.8/object.h **** 
 206:/usr/local/include/python3.8/object.h **** PyAPI_DATA(struct _typeobject) PyType_Type; /* built-in 'type' */
 207:/usr/local/include/python3.8/object.h **** PyAPI_DATA(struct _typeobject) PyBaseObject_Type; /* built-in 'object' */
 208:/usr/local/include/python3.8/object.h **** PyAPI_DATA(struct _typeobject) PySuper_Type; /* built-in 'super' */
 209:/usr/local/include/python3.8/object.h **** 
 210:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(unsigned long) PyType_GetFlags(struct _typeobject*);
 211:/usr/local/include/python3.8/object.h **** 
 212:/usr/local/include/python3.8/object.h **** #define PyType_Check(op) \
 213:/usr/local/include/python3.8/object.h ****     PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS)
 214:/usr/local/include/python3.8/object.h **** #define PyType_CheckExact(op) (Py_TYPE(op) == &PyType_Type)
 215:/usr/local/include/python3.8/object.h **** 
 216:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyType_Ready(struct _typeobject *);
 217:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyType_GenericAlloc(struct _typeobject *, Py_ssize_t);
 218:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyType_GenericNew(struct _typeobject *,
 219:/usr/local/include/python3.8/object.h ****                                                PyObject *, PyObject *);
 220:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(unsigned int) PyType_ClearCache(void);
 221:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) PyType_Modified(struct _typeobject *);
 222:/usr/local/include/python3.8/object.h **** 
 223:/usr/local/include/python3.8/object.h **** /* Generic operations on objects */
 224:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);
 225:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);
 226:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);
 227:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);
 228:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);
 229:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);
 230:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);
 231:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);
 232:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);
 233:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);
 234:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);
 235:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);
 236:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);
 237:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);
 238:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *,
 239:/usr/local/include/python3.8/object.h ****                                               PyObject *, PyObject *);
 240:/usr/local/include/python3.8/object.h **** #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
 241:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);
 242:/usr/local/include/python3.8/object.h **** #endif
 243:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(Py_hash_t) PyObject_Hash(PyObject *);
 244:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(Py_hash_t) PyObject_HashNotImplemented(PyObject *);
 245:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_IsTrue(PyObject *);
 246:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyObject_Not(PyObject *);
 247:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) PyCallable_Check(PyObject *);
 248:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);
 249:/usr/local/include/python3.8/object.h **** 
 250:/usr/local/include/python3.8/object.h **** /* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a
 251:/usr/local/include/python3.8/object.h ****    list of strings.  PyObject_Dir(NULL) is like builtins.dir(),
 252:/usr/local/include/python3.8/object.h ****    returning the names of the current locals.  In this case, if there are
 253:/usr/local/include/python3.8/object.h ****    no current locals, NULL is returned, and PyErr_Occurred() is false.
 254:/usr/local/include/python3.8/object.h **** */
 255:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);
 256:/usr/local/include/python3.8/object.h **** 
 257:/usr/local/include/python3.8/object.h **** 
 258:/usr/local/include/python3.8/object.h **** /* Helpers for printing recursive container types */
 259:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) Py_ReprEnter(PyObject *);
 260:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) Py_ReprLeave(PyObject *);
 261:/usr/local/include/python3.8/object.h **** 
 262:/usr/local/include/python3.8/object.h **** /* Flag bits for printing: */
 263:/usr/local/include/python3.8/object.h **** #define Py_PRINT_RAW    1       /* No string quotes etc. */
 264:/usr/local/include/python3.8/object.h **** 
 265:/usr/local/include/python3.8/object.h **** /*
 266:/usr/local/include/python3.8/object.h **** Type flags (tp_flags)
 267:/usr/local/include/python3.8/object.h **** 
 268:/usr/local/include/python3.8/object.h **** These flags are used to change expected features and behavior for a
 269:/usr/local/include/python3.8/object.h **** particular type.
 270:/usr/local/include/python3.8/object.h **** 
 271:/usr/local/include/python3.8/object.h **** Arbitration of the flag bit positions will need to be coordinated among
 272:/usr/local/include/python3.8/object.h **** all extension writers who publicly release their extensions (this will
 273:/usr/local/include/python3.8/object.h **** be fewer than you might expect!).
 274:/usr/local/include/python3.8/object.h **** 
 275:/usr/local/include/python3.8/object.h **** Most flags were removed as of Python 3.0 to make room for new flags.  (Some
 276:/usr/local/include/python3.8/object.h **** flags are not for backwards compatibility but to indicate the presence of an
 277:/usr/local/include/python3.8/object.h **** optional feature; these flags remain of course.)
 278:/usr/local/include/python3.8/object.h **** 
 279:/usr/local/include/python3.8/object.h **** Type definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.
 280:/usr/local/include/python3.8/object.h **** 
 281:/usr/local/include/python3.8/object.h **** Code can use PyType_HasFeature(type_ob, flag_value) to test whether the
 282:/usr/local/include/python3.8/object.h **** given type object has a specified feature.
 283:/usr/local/include/python3.8/object.h **** */
 284:/usr/local/include/python3.8/object.h **** 
 285:/usr/local/include/python3.8/object.h **** /* Set if the type object is dynamically allocated */
 286:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HEAPTYPE (1UL << 9)
 287:/usr/local/include/python3.8/object.h **** 
 288:/usr/local/include/python3.8/object.h **** /* Set if the type allows subclassing */
 289:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_BASETYPE (1UL << 10)
 290:/usr/local/include/python3.8/object.h **** 
 291:/usr/local/include/python3.8/object.h **** /* Set if the type implements the vectorcall protocol (PEP 590) */
 292:/usr/local/include/python3.8/object.h **** #ifndef Py_LIMITED_API
 293:/usr/local/include/python3.8/object.h **** #define _Py_TPFLAGS_HAVE_VECTORCALL (1UL << 11)
 294:/usr/local/include/python3.8/object.h **** #endif
 295:/usr/local/include/python3.8/object.h **** 
 296:/usr/local/include/python3.8/object.h **** /* Set if the type is 'ready' -- fully initialized */
 297:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_READY (1UL << 12)
 298:/usr/local/include/python3.8/object.h **** 
 299:/usr/local/include/python3.8/object.h **** /* Set while the type is being 'readied', to prevent recursive ready calls */
 300:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_READYING (1UL << 13)
 301:/usr/local/include/python3.8/object.h **** 
 302:/usr/local/include/python3.8/object.h **** /* Objects support garbage collection (see objimpl.h) */
 303:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HAVE_GC (1UL << 14)
 304:/usr/local/include/python3.8/object.h **** 
 305:/usr/local/include/python3.8/object.h **** /* These two bits are preserved for Stackless Python, next after this is 17 */
 306:/usr/local/include/python3.8/object.h **** #ifdef STACKLESS
 307:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3UL << 15)
 308:/usr/local/include/python3.8/object.h **** #else
 309:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0
 310:/usr/local/include/python3.8/object.h **** #endif
 311:/usr/local/include/python3.8/object.h **** 
 312:/usr/local/include/python3.8/object.h **** /* Objects behave like an unbound method */
 313:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_METHOD_DESCRIPTOR (1UL << 17)
 314:/usr/local/include/python3.8/object.h **** 
 315:/usr/local/include/python3.8/object.h **** /* Objects support type attribute cache */
 316:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HAVE_VERSION_TAG   (1UL << 18)
 317:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_VALID_VERSION_TAG  (1UL << 19)
 318:/usr/local/include/python3.8/object.h **** 
 319:/usr/local/include/python3.8/object.h **** /* Type is abstract and cannot be instantiated */
 320:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_IS_ABSTRACT (1UL << 20)
 321:/usr/local/include/python3.8/object.h **** 
 322:/usr/local/include/python3.8/object.h **** /* These flags are used to determine if a type is a subclass. */
 323:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_LONG_SUBCLASS        (1UL << 24)
 324:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_LIST_SUBCLASS        (1UL << 25)
 325:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_TUPLE_SUBCLASS       (1UL << 26)
 326:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_BYTES_SUBCLASS       (1UL << 27)
 327:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_UNICODE_SUBCLASS     (1UL << 28)
 328:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_DICT_SUBCLASS        (1UL << 29)
 329:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_BASE_EXC_SUBCLASS    (1UL << 30)
 330:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_TYPE_SUBCLASS        (1UL << 31)
 331:/usr/local/include/python3.8/object.h **** 
 332:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_DEFAULT  ( \
 333:/usr/local/include/python3.8/object.h ****                  Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \
 334:/usr/local/include/python3.8/object.h ****                  Py_TPFLAGS_HAVE_VERSION_TAG | \
 335:/usr/local/include/python3.8/object.h ****                 0)
 336:/usr/local/include/python3.8/object.h **** 
 337:/usr/local/include/python3.8/object.h **** /* NOTE: The following flags reuse lower bits (removed as part of the
 338:/usr/local/include/python3.8/object.h ****  * Python 3.0 transition). */
 339:/usr/local/include/python3.8/object.h **** 
 340:/usr/local/include/python3.8/object.h **** /* The following flag is kept for compatibility.  Starting with 3.8,
 341:/usr/local/include/python3.8/object.h ****  * binary compatibility of C extensions accross feature releases of
 342:/usr/local/include/python3.8/object.h ****  * Python is not supported anymore, except when using the stable ABI.
 343:/usr/local/include/python3.8/object.h ****  */
 344:/usr/local/include/python3.8/object.h **** 
 345:/usr/local/include/python3.8/object.h **** /* Type structure has tp_finalize member (3.4) */
 346:/usr/local/include/python3.8/object.h **** #define Py_TPFLAGS_HAVE_FINALIZE (1UL << 0)
 347:/usr/local/include/python3.8/object.h **** 
 348:/usr/local/include/python3.8/object.h **** #ifdef Py_LIMITED_API
 349:/usr/local/include/python3.8/object.h **** #  define PyType_HasFeature(t,f)  ((PyType_GetFlags(t) & (f)) != 0)
 350:/usr/local/include/python3.8/object.h **** #endif
 351:/usr/local/include/python3.8/object.h **** #define PyType_FastSubclass(t,f)  PyType_HasFeature(t,f)
 352:/usr/local/include/python3.8/object.h **** 
 353:/usr/local/include/python3.8/object.h **** 
 354:/usr/local/include/python3.8/object.h **** /*
 355:/usr/local/include/python3.8/object.h **** The macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement
 356:/usr/local/include/python3.8/object.h **** reference counts.  Py_DECREF calls the object's deallocator function when
 357:/usr/local/include/python3.8/object.h **** the refcount falls to 0; for
 358:/usr/local/include/python3.8/object.h **** objects that don't contain references to other objects or heap memory
 359:/usr/local/include/python3.8/object.h **** this can be the standard function free().  Both macros can be used
 360:/usr/local/include/python3.8/object.h **** wherever a void expression is allowed.  The argument must not be a
 361:/usr/local/include/python3.8/object.h **** NULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.
 362:/usr/local/include/python3.8/object.h **** The macro _Py_NewReference(op) initialize reference counts to 1, and
 363:/usr/local/include/python3.8/object.h **** in special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional
 364:/usr/local/include/python3.8/object.h **** bookkeeping appropriate to the special build.
 365:/usr/local/include/python3.8/object.h **** 
 366:/usr/local/include/python3.8/object.h **** We assume that the reference count field can never overflow; this can
 367:/usr/local/include/python3.8/object.h **** be proven when the size of the field is the same as the pointer size, so
 368:/usr/local/include/python3.8/object.h **** we ignore the possibility.  Provided a C int is at least 32 bits (which
 369:/usr/local/include/python3.8/object.h **** is implicitly assumed in many parts of this code), that's enough for
 370:/usr/local/include/python3.8/object.h **** about 2**31 references to an object.
 371:/usr/local/include/python3.8/object.h **** 
 372:/usr/local/include/python3.8/object.h **** XXX The following became out of date in Python 2.2, but I'm not sure
 373:/usr/local/include/python3.8/object.h **** XXX what the full truth is now.  Certainly, heap-allocated type objects
 374:/usr/local/include/python3.8/object.h **** XXX can and should be deallocated.
 375:/usr/local/include/python3.8/object.h **** Type objects should never be deallocated; the type pointer in an object
 376:/usr/local/include/python3.8/object.h **** is not considered to be a reference to the type object, to save
 377:/usr/local/include/python3.8/object.h **** complications in the deallocation function.  (This is actually a
 378:/usr/local/include/python3.8/object.h **** decision that's up to the implementer of each new type so if you want,
 379:/usr/local/include/python3.8/object.h **** you can count such references to the type object.)
 380:/usr/local/include/python3.8/object.h **** */
 381:/usr/local/include/python3.8/object.h **** 
 382:/usr/local/include/python3.8/object.h **** /* First define a pile of simple helper macros, one set per special
 383:/usr/local/include/python3.8/object.h ****  * build symbol.  These either expand to the obvious things, or to
 384:/usr/local/include/python3.8/object.h ****  * nothing at all when the special mode isn't in effect.  The main
 385:/usr/local/include/python3.8/object.h ****  * macros can later be defined just once then, yet expand to different
 386:/usr/local/include/python3.8/object.h ****  * things depending on which special build options are and aren't in effect.
 387:/usr/local/include/python3.8/object.h ****  * Trust me <wink>:  while painful, this is 20x easier to understand than,
 388:/usr/local/include/python3.8/object.h ****  * e.g, defining _Py_NewReference five different times in a maze of nested
 389:/usr/local/include/python3.8/object.h ****  * #ifdefs (we used to do that -- it was impenetrable).
 390:/usr/local/include/python3.8/object.h ****  */
 391:/usr/local/include/python3.8/object.h **** #ifdef Py_REF_DEBUG
 392:/usr/local/include/python3.8/object.h **** PyAPI_DATA(Py_ssize_t) _Py_RefTotal;
 393:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_NegativeRefcount(const char *filename, int lineno,
 394:/usr/local/include/python3.8/object.h ****                                       PyObject *op);
 395:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(Py_ssize_t) _Py_GetRefTotal(void);
 396:/usr/local/include/python3.8/object.h **** #define _Py_INC_REFTOTAL        _Py_RefTotal++
 397:/usr/local/include/python3.8/object.h **** #define _Py_DEC_REFTOTAL        _Py_RefTotal--
 398:/usr/local/include/python3.8/object.h **** 
 399:/usr/local/include/python3.8/object.h **** /* Py_REF_DEBUG also controls the display of refcounts and memory block
 400:/usr/local/include/python3.8/object.h ****  * allocations at the interactive prompt and at interpreter shutdown
 401:/usr/local/include/python3.8/object.h ****  */
 402:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _PyDebug_PrintTotalRefs(void);
 403:/usr/local/include/python3.8/object.h **** #else
 404:/usr/local/include/python3.8/object.h **** #define _Py_INC_REFTOTAL
 405:/usr/local/include/python3.8/object.h **** #define _Py_DEC_REFTOTAL
 406:/usr/local/include/python3.8/object.h **** #endif /* Py_REF_DEBUG */
 407:/usr/local/include/python3.8/object.h **** 
 408:/usr/local/include/python3.8/object.h **** #ifdef COUNT_ALLOCS
 409:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_inc_count(struct _typeobject *);
 410:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_dec_count(struct _typeobject *);
 411:/usr/local/include/python3.8/object.h **** #define _Py_INC_TPALLOCS(OP)    _Py_inc_count(Py_TYPE(OP))
 412:/usr/local/include/python3.8/object.h **** #define _Py_INC_TPFREES(OP)     _Py_dec_count(Py_TYPE(OP))
 413:/usr/local/include/python3.8/object.h **** #define _Py_DEC_TPFREES(OP)     Py_TYPE(OP)->tp_frees--
 414:/usr/local/include/python3.8/object.h **** #define _Py_COUNT_ALLOCS_COMMA  ,
 415:/usr/local/include/python3.8/object.h **** #else
 416:/usr/local/include/python3.8/object.h **** #define _Py_INC_TPALLOCS(OP)
 417:/usr/local/include/python3.8/object.h **** #define _Py_INC_TPFREES(OP)
 418:/usr/local/include/python3.8/object.h **** #define _Py_DEC_TPFREES(OP)
 419:/usr/local/include/python3.8/object.h **** #define _Py_COUNT_ALLOCS_COMMA
 420:/usr/local/include/python3.8/object.h **** #endif /* COUNT_ALLOCS */
 421:/usr/local/include/python3.8/object.h **** 
 422:/usr/local/include/python3.8/object.h **** /* Update the Python traceback of an object. This function must be called
 423:/usr/local/include/python3.8/object.h ****    when a memory block is reused from a free list. */
 424:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(int) _PyTraceMalloc_NewReference(PyObject *op);
 425:/usr/local/include/python3.8/object.h **** 
 426:/usr/local/include/python3.8/object.h **** #ifdef Py_TRACE_REFS
 427:/usr/local/include/python3.8/object.h **** /* Py_TRACE_REFS is such major surgery that we call external routines. */
 428:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_NewReference(PyObject *);
 429:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_ForgetReference(PyObject *);
 430:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_PrintReferences(FILE *);
 431:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_PrintReferenceAddresses(FILE *);
 432:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_AddToAllObjects(PyObject *, int force);
 433:/usr/local/include/python3.8/object.h **** #else
 434:/usr/local/include/python3.8/object.h **** /* Without Py_TRACE_REFS, there's little enough to do that we expand code
 435:/usr/local/include/python3.8/object.h ****    inline. */
 436:/usr/local/include/python3.8/object.h **** static inline void _Py_NewReference(PyObject *op)
 437:/usr/local/include/python3.8/object.h **** {
 438:/usr/local/include/python3.8/object.h ****     if (_Py_tracemalloc_config.tracing) {
 439:/usr/local/include/python3.8/object.h ****         _PyTraceMalloc_NewReference(op);
 440:/usr/local/include/python3.8/object.h ****     }
 441:/usr/local/include/python3.8/object.h ****     _Py_INC_TPALLOCS(op);
 442:/usr/local/include/python3.8/object.h ****     _Py_INC_REFTOTAL;
 443:/usr/local/include/python3.8/object.h ****     Py_REFCNT(op) = 1;
 444:/usr/local/include/python3.8/object.h **** }
 445:/usr/local/include/python3.8/object.h **** 
 446:/usr/local/include/python3.8/object.h **** static inline void _Py_ForgetReference(PyObject *op)
 447:/usr/local/include/python3.8/object.h **** {
 448:/usr/local/include/python3.8/object.h ****     (void)op; /* may be unused, shut up -Wunused-parameter */
 449:/usr/local/include/python3.8/object.h ****     _Py_INC_TPFREES(op);
 450:/usr/local/include/python3.8/object.h **** }
 451:/usr/local/include/python3.8/object.h **** #endif /* !Py_TRACE_REFS */
 452:/usr/local/include/python3.8/object.h **** 
 453:/usr/local/include/python3.8/object.h **** 
 454:/usr/local/include/python3.8/object.h **** PyAPI_FUNC(void) _Py_Dealloc(PyObject *);
 455:/usr/local/include/python3.8/object.h **** 
 456:/usr/local/include/python3.8/object.h **** static inline void _Py_INCREF(PyObject *op)
 3190              		.loc 2 456 20 view .LVU834
 3191              	.LBB48:
 457:/usr/local/include/python3.8/object.h **** {
 458:/usr/local/include/python3.8/object.h ****     _Py_INC_REFTOTAL;
 3192              		.loc 2 458 21 view .LVU835
 459:/usr/local/include/python3.8/object.h ****     op->ob_refcnt++;
 3193              		.loc 2 459 5 view .LVU836
 3194              	@ /usr/local/include/python3.8/object.h:459:     op->ob_refcnt++;
 3195              		.loc 2 459 18 is_stmt 0 view .LVU837
 3196 0e50 38309FE5 		ldr	r3, .L197	@ tmp126,
 3197              	.LBE48:
 3198              	.LBE47:
 3199              	@ armwave.c:512:     Py_RETURN_TRUE;
 3200              		.loc 1 512 5 view .LVU838
 3201 0e54 0300A0E1 		mov	r0, r3	@ <retval>, tmp126
 3202              	.LBB50:
 3203              	.LBB49:
 3204              	@ /usr/local/include/python3.8/object.h:459:     op->ob_refcnt++;
 3205              		.loc 2 459 18 view .LVU839
 3206 0e58 002093E5 		ldr	r2, [r3]	@ MEM[(Py_ssize_t *)&_Py_TrueStruct],
 3207 0e5c 012082E2 		add	r2, r2, #1	@ tmp128, MEM[(Py_ssize_t *)&_Py_TrueStruct],
 3208 0e60 002083E5 		str	r2, [r3]	@ tmp128,
 3209              	.LBE49:
 3210              	.LBE50:
 3211              	@ armwave.c:513: }
 513:armwave.c     **** }
 3212              		.loc 1 513 1 view .LVU840
 3213 0e64 34D08DE2 		add	sp, sp, #52	@,,
 3214              		.cfi_remember_state
 3215              		.cfi_def_cfa_offset 4
 3216              		@ sp needed	@
 3217 0e68 04F09DE4 		ldr	pc, [sp], #4	@
 3218              	.LVL224:
 3219              	.L196:
 3220              		.cfi_restore_state
 500:armwave.c     ****         Py_RETURN_FALSE;
 3221              		.loc 1 500 9 is_stmt 1 view .LVU841
 3222 0e6c 20009FE5 		ldr	r0, .L197+4	@,
 3223              	.LVL225:
 500:armwave.c     ****         Py_RETURN_FALSE;
 3224              		.loc 1 500 9 is_stmt 0 view .LVU842
 3225 0e70 FEFFFFEB 		bl	puts		@
 3226              	.LVL226:
 501:armwave.c     ****     }
 3227              		.loc 1 501 9 is_stmt 1 view .LVU843
 3228              	.LBB51:
 3229              	.LBI51:
 456:/usr/local/include/python3.8/object.h **** {
 3230              		.loc 2 456 20 view .LVU844
 3231              	.LBB52:
 458:/usr/local/include/python3.8/object.h ****     op->ob_refcnt++;
 3232              		.loc 2 458 21 view .LVU845
 3233              		.loc 2 459 5 view .LVU846
 3234              	@ /usr/local/include/python3.8/object.h:459:     op->ob_refcnt++;
 3235              		.loc 2 459 18 is_stmt 0 view .LVU847
 3236 0e74 1C309FE5 		ldr	r3, .L197+8	@ tmp120,
 3237              	.LBE52:
 3238              	.LBE51:
 3239              	@ armwave.c:501:         Py_RETURN_FALSE;
 501:armwave.c     ****     }
 3240              		.loc 1 501 9 view .LVU848
 3241 0e78 0300A0E1 		mov	r0, r3	@ <retval>, tmp120
 3242              	.LBB54:
 3243              	.LBB53:
 3244              	@ /usr/local/include/python3.8/object.h:459:     op->ob_refcnt++;
 3245              		.loc 2 459 18 view .LVU849
 3246 0e7c 002093E5 		ldr	r2, [r3]	@ MEM[(Py_ssize_t *)&_Py_FalseStruct],
 3247 0e80 012082E2 		add	r2, r2, #1	@ tmp122, MEM[(Py_ssize_t *)&_Py_FalseStruct],
 3248 0e84 002083E5 		str	r2, [r3]	@ tmp122,
 3249              	.LBE53:
 3250              	.LBE54:
 3251              	@ armwave.c:513: }
 3252              		.loc 1 513 1 view .LVU850
 3253 0e88 34D08DE2 		add	sp, sp, #52	@,,
 3254              		.cfi_def_cfa_offset 4
 3255              		@ sp needed	@
 3256 0e8c 04F09DE4 		ldr	pc, [sp], #4	@
 3257              	.L198:
 3258              		.align	2
 3259              	.L197:
 3260 0e90 00000000 		.word	_Py_TrueStruct
 3261 0e94 10020000 		.word	.LC19
 3262 0e98 00000000 		.word	_Py_FalseStruct
 3263              		.cfi_endproc
 3264              	.LFE74:
 3266              		.align	2
 3267              		.global	armwave_test_create_am_sine
 3268              		.syntax unified
 3269              		.arm
 3270              		.fpu vfp
 3272              	armwave_test_create_am_sine:
 3273              	.LVL227:
 3274              	.LFB75:
 514:armwave.c     **** 
 515:armwave.c     **** /*
 516:armwave.c     ****  * Make a test AM waveform for render tests.
 517:armwave.c     ****  *
 518:armwave.c     ****  * @param   mod                     modulation depth
 519:armwave.c     ****  * @param   noise_fraction          typically 1e-6
 520:armwave.c     ****  * @param   number of wave sets     1-N, must have memory for these
 521:armwave.c     ****  */
 522:armwave.c     **** void armwave_test_create_am_sine(float mod, float noise_fraction, int sets)
 523:armwave.c     **** {
 3275              		.loc 1 523 1 is_stmt 1 view -0
 3276              		.cfi_startproc
 3277              		@ args = 0, pretend = 0, frame = 8
 3278              		@ frame_needed = 0, uses_anonymous_args = 0
 524:armwave.c     ****     float v, noise, xnoise, mod_val;
 3279              		.loc 1 524 5 view .LVU852
 525:armwave.c     ****     float _1_waves_mod = mod * (1.0f / g_armwave_state.waves);
 3280              		.loc 1 525 5 view .LVU853
 3281              	@ armwave.c:523: {
 523:armwave.c     ****     float v, noise, xnoise, mod_val;
 3282              		.loc 1 523 1 is_stmt 0 view .LVU854
 3283 0e9c F0472DE9 		push	{r4, r5, r6, r7, r8, r9, r10, lr}	@
 3284              		.cfi_def_cfa_offset 32
 3285              		.cfi_offset 4, -32
 3286              		.cfi_offset 5, -28
 3287              		.cfi_offset 6, -24
 3288              		.cfi_offset 7, -20
 3289              		.cfi_offset 8, -16
 3290              		.cfi_offset 9, -12
 3291              		.cfi_offset 10, -8
 3292              		.cfi_offset 14, -4
 3293              	@ armwave.c:525:     float _1_waves_mod = mod * (1.0f / g_armwave_state.waves);
 3294              		.loc 1 525 38 view .LVU855
 3295 0ea0 7A7A9FED 		vldr.32	s14, .L230	@ tmp180,
 3296              	@ armwave.c:525:     float _1_waves_mod = mod * (1.0f / g_armwave_state.waves);
 3297              		.loc 1 525 55 view .LVU856
 3298 0ea4 00529FE5 		ldr	r5, .L230+28	@ tmp250,
 3299              	@ armwave.c:523: {
 523:armwave.c     ****     float v, noise, xnoise, mod_val;
 3300              		.loc 1 523 1 view .LVU857
 3301 0ea8 0C8B2DED 		vpush.64	{d8, d9, d10, d11, d12, d13}	@
 3302              		.cfi_def_cfa_offset 80
 3303              		.cfi_offset 80, -80
 3304              		.cfi_offset 81, -76
 3305              		.cfi_offset 82, -72
 3306              		.cfi_offset 83, -68
 3307              		.cfi_offset 84, -64
 3308              		.cfi_offset 85, -60
 3309              		.cfi_offset 86, -56
 3310              		.cfi_offset 87, -52
 3311              		.cfi_offset 88, -48
 3312              		.cfi_offset 89, -44
 3313              		.cfi_offset 90, -40
 3314              		.cfi_offset 91, -36
 3315 0eac 0090A0E1 		mov	r9, r0	@ sets, sets
 3316              	@ armwave.c:525:     float _1_waves_mod = mod * (1.0f / g_armwave_state.waves);
 3317              		.loc 1 525 38 view .LVU858
 3318 0eb0 0E7AD5ED 		vldr.32	s15, [r5, #56]	@ int	@ tmp264, g_armwave_state.waves
 3319              	@ armwave.c:529:     g_armwave_state.test_wave_buffer_stride = (g_armwave_state.waves * g_armwave_s
 526:armwave.c     ****     int s, set_offset = 0;
 527:armwave.c     ****     int w, x;
 528:armwave.c     **** 
 529:armwave.c     ****     g_armwave_state.test_wave_buffer_stride = (g_armwave_state.waves * g_armwave_state.wave_stride)
 3320              		.loc 1 529 70 view .LVU859
 3321 0eb4 343095E5 		ldr	r3, [r5, #52]	@ g_armwave_state.wave_stride, g_armwave_state.wave_stride
 3322 0eb8 382095E5 		ldr	r2, [r5, #56]	@ tmp265, g_armwave_state.waves
 3323              	.LBB57:
 3324              	.LBB58:
 3325              	@ armwave.c:472:     if(g_armwave_state.test_wave_buffer != NULL) {
 472:armwave.c     ****         free(g_armwave_state.test_wave_buffer);
 3326              		.loc 1 472 23 view .LVU860
 3327 0ebc 180095E5 		ldr	r0, [r5, #24]	@ _82, g_armwave_state.test_wave_buffer
 3328              	.LVL228:
 472:armwave.c     ****         free(g_armwave_state.test_wave_buffer);
 3329              		.loc 1 472 23 view .LVU861
 3330              	.LBE58:
 3331              	.LBE57:
 3332              	@ armwave.c:525:     float _1_waves_mod = mod * (1.0f / g_armwave_state.waves);
 525:armwave.c     ****     int s, set_offset = 0;
 3333              		.loc 1 525 38 view .LVU862
 3334 0ec0 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp178, tmp264
 3335              	@ armwave.c:529:     g_armwave_state.test_wave_buffer_stride = (g_armwave_state.waves * g_armwave_s
 3336              		.loc 1 529 70 view .LVU863
 3337 0ec4 920303E0 		mul	r3, r2, r3	@ tmp183, tmp265, g_armwave_state.wave_stride
 3338              	@ armwave.c:523: {
 523:armwave.c     ****     float v, noise, xnoise, mod_val;
 3339              		.loc 1 523 1 view .LVU864
 3340 0ec8 60BAF0EE 		vmov.f32	s23, s1	@ noise_fraction, noise_fraction
 3341              	.LBB62:
 3342              	.LBB59:
 3343              	@ armwave.c:472:     if(g_armwave_state.test_wave_buffer != NULL) {
 472:armwave.c     ****         free(g_armwave_state.test_wave_buffer);
 3344              		.loc 1 472 7 view .LVU865
 3345 0ecc 000050E3 		cmp	r0, #0	@ _82,
 3346              	.LBE59:
 3347              	.LBE62:
 3348              	@ armwave.c:523: {
 523:armwave.c     ****     float v, noise, xnoise, mod_val;
 3349              		.loc 1 523 1 view .LVU866
 3350 0ed0 08D04DE2 		sub	sp, sp, #8	@,,
 3351              		.cfi_def_cfa_offset 88
 3352              	@ armwave.c:530:     g_armwave_state.test_wave_buffer_nsets = sets;
 530:armwave.c     ****     g_armwave_state.test_wave_buffer_nsets = sets;
 3353              		.loc 1 530 44 view .LVU867
 3354 0ed4 209085E5 		str	r9, [r5, #32]	@ sets, g_armwave_state.test_wave_buffer_nsets
 3355              	@ armwave.c:529:     g_armwave_state.test_wave_buffer_stride = (g_armwave_state.waves * g_armwave_s
 529:armwave.c     ****     g_armwave_state.test_wave_buffer_nsets = sets;
 3356              		.loc 1 529 45 view .LVU868
 3357 0ed8 1C3085E5 		str	r3, [r5, #28]	@ tmp183, g_armwave_state.test_wave_buffer_stride
 3358              	@ armwave.c:525:     float _1_waves_mod = mod * (1.0f / g_armwave_state.waves);
 525:armwave.c     ****     int s, set_offset = 0;
 3359              		.loc 1 525 38 view .LVU869
 3360 0edc 27DA87EE 		vdiv.f32	s26, s14, s15	@ tmp179, tmp180, tmp178
 3361              	@ armwave.c:525:     float _1_waves_mod = mod * (1.0f / g_armwave_state.waves);
 525:armwave.c     ****     int s, set_offset = 0;
 3362              		.loc 1 525 11 view .LVU870
 3363 0ee0 00DA2DEE 		vmul.f32	s26, s26, s0	@ _1_waves_mod, tmp179, mod
 3364              	.LVL229:
 526:armwave.c     ****     int w, x;
 3365              		.loc 1 526 5 is_stmt 1 view .LVU871
 527:armwave.c     **** 
 3366              		.loc 1 527 5 view .LVU872
 529:armwave.c     ****     g_armwave_state.test_wave_buffer_nsets = sets;
 3367              		.loc 1 529 5 view .LVU873
 3368              		.loc 1 530 5 view .LVU874
 531:armwave.c     ****     armwave_test_buffer_alloc(sets);
 3369              		.loc 1 531 5 view .LVU875
 3370              	.LBB63:
 3371              	.LBI57:
 470:armwave.c     **** {
 3372              		.loc 1 470 6 view .LVU876
 3373              	.LBB60:
 472:armwave.c     ****         free(g_armwave_state.test_wave_buffer);
 3374              		.loc 1 472 5 view .LVU877
 3375              	@ armwave.c:472:     if(g_armwave_state.test_wave_buffer != NULL) {
 472:armwave.c     ****         free(g_armwave_state.test_wave_buffer);
 3376              		.loc 1 472 7 is_stmt 0 view .LVU878
 3377 0ee4 0000000A 		beq	.L200		@,
 473:armwave.c     ****     }
 3378              		.loc 1 473 9 is_stmt 1 view .LVU879
 3379 0ee8 FEFFFFEB 		bl	free		@
 3380              	.LVL230:
 3381              	.L200:
 478:armwave.c     **** 
 3382              		.loc 1 478 5 view .LVU880
 3383              	@ armwave.c:478:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 478:armwave.c     **** 
 3384              		.loc 1 478 75 is_stmt 0 view .LVU881
 3385 0eec 4C3095E5 		ldr	r3, [r5, #76]	@ g_armwave_state.wave_length, g_armwave_state.wave_length
 3386 0ef0 3C4095E5 		ldr	r4, [r5, #60]	@ g_armwave_state.waves_max, g_armwave_state.waves_max
 3387              	@ armwave.c:478:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 478:armwave.c     **** 
 3388              		.loc 1 478 40 view .LVU882
 3389 0ef4 0910A0E1 		mov	r1, r9	@, sets
 3390              	@ armwave.c:478:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 478:armwave.c     **** 
 3391              		.loc 1 478 75 view .LVU883
 3392 0ef8 940304E0 		mul	r4, r4, r3	@ _85, g_armwave_state.waves_max, g_armwave_state.wave_length
 3393              	@ armwave.c:478:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 478:armwave.c     **** 
 3394              		.loc 1 478 40 view .LVU884
 3395 0efc 0400A0E1 		mov	r0, r4	@, _85
 3396 0f00 FEFFFFEB 		bl	calloc		@
 3397              	.LVL231:
 3398              	@ armwave.c:480:     if(g_armwave_state.test_wave_buffer == NULL) {
 480:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes, %d sets)\
 3399              		.loc 1 480 7 view .LVU885
 3400 0f04 000050E3 		cmp	r0, #0	@ tmp191,
 3401              	@ armwave.c:478:     g_armwave_state.test_wave_buffer = calloc(g_armwave_state.wave_length * g_armw
 478:armwave.c     **** 
 3402              		.loc 1 478 38 view .LVU886
 3403 0f08 180085E5 		str	r0, [r5, #24]	@ tmp191, g_armwave_state.test_wave_buffer
 480:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes, %d sets)\
 3404              		.loc 1 480 5 is_stmt 1 view .LVU887
 3405              	@ armwave.c:480:     if(g_armwave_state.test_wave_buffer == NULL) {
 480:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes, %d sets)\
 3406              		.loc 1 480 7 is_stmt 0 view .LVU888
 3407 0f0c 5A00000A 		beq	.L229		@,
 3408              	.L201:
 3409              	.LVL232:
 480:armwave.c     ****         printf("armwave_test_buffer_alloc: failed to allocate test wave buffer (%d bytes, %d sets)\
 3410              		.loc 1 480 7 view .LVU889
 3411              	.LBE60:
 3412              	.LBE63:
 3413              	@ armwave.c:533:     for(s = 0; s < sets; s++) {
 532:armwave.c     **** 
 533:armwave.c     ****     for(s = 0; s < sets; s++) {
 3414              		.loc 1 533 5 discriminator 1 view .LVU890
 3415 0f10 000059E3 		cmp	r9, #0	@ sets,
 3416 0f14 550000DA 		ble	.L199		@,
 3417              	@ armwave.c:552:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 534:armwave.c     ****         printf("Calculating test set %d\n", s);
 535:armwave.c     ****     
 536:armwave.c     ****         for(w = 0; w < g_armwave_state.waves; w++) {
 537:armwave.c     ****             //mod_val = 0.5f + (((float)w / g_armwave_state.waves) * mod);
 538:armwave.c     ****             mod_val = 0.5f + (_1_waves_mod * w);
 539:armwave.c     **** 
 540:armwave.c     ****             for(x = 0; x < g_armwave_state.wave_length; x++) {
 541:armwave.c     ****                 noise  = ((rand() & 0xffff) * noise_fraction);
 542:armwave.c     ****                 noise *= noise;
 543:armwave.c     ****                 noise *= noise;
 544:armwave.c     ****                 noise *= noise;
 545:armwave.c     **** 
 546:armwave.c     ****                 if((rand() & 0xffff) > 0x7fff)
 547:armwave.c     ****                     noise = -noise;
 548:armwave.c     **** 
 549:armwave.c     ****                 noise += 1.0f;
 550:armwave.c     ****                 xnoise = (rand() & 0xffff) / 6553500.0f;
 551:armwave.c     **** 
 552:armwave.c     ****                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoise) * mod_val) * 
 3418              		.loc 1 552 45 view .LVU891
 3419 0f18 5C8A9FED 		vldr.32	s16, .L230	@ tmp258,
 3420              	@ armwave.c:555:                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_str
 553:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 554:armwave.c     ****                 //printf("%d = %d\n", x + (w * g_armwave_state.wave_stride), MIN(MAX(128 + (v * 127
 555:armwave.c     ****                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_stride) + set_offset
 3421              		.loc 1 555 104 view .LVU892
 3422 0f1c 5CCA9FED 		vldr.32	s24, .L230+4	@ tmp259,
 3423              	@ armwave.c:533:     for(s = 0; s < sets; s++) {
 533:armwave.c     ****         printf("Calculating test set %d\n", s);
 3424              		.loc 1 533 5 view .LVU893
 3425 0f20 0070A0E3 		mov	r7, #0	@ set_offset,
 3426              	@ armwave.c:534:         printf("Calculating test set %d\n", s);
 534:armwave.c     ****         printf("Calculating test set %d\n", s);
 3427              		.loc 1 534 9 view .LVU894
 3428 0f24 84A19FE5 		ldr	r10, .L230+32	@ tmp257,
 3429              	@ armwave.c:533:     for(s = 0; s < sets; s++) {
 533:armwave.c     ****         printf("Calculating test set %d\n", s);
 3430              		.loc 1 533 5 view .LVU895
 3431 0f28 0780A0E1 		mov	r8, r7	@ s, set_offset
 3432              	.LVL233:
 3433              	.L202:
 534:armwave.c     ****         printf("Calculating test set %d\n", s);
 3434              		.loc 1 534 9 is_stmt 1 view .LVU896
 3435 0f2c 0810A0E1 		mov	r1, r8	@, s
 3436 0f30 0A00A0E1 		mov	r0, r10	@, tmp257
 3437 0f34 FEFFFFEB 		bl	printf		@
 3438              	.LVL234:
 536:armwave.c     ****             //mod_val = 0.5f + (((float)w / g_armwave_state.waves) * mod);
 3439              		.loc 1 536 9 view .LVU897
 3440              	@ armwave.c:536:         for(w = 0; w < g_armwave_state.waves; w++) {
 536:armwave.c     ****             //mod_val = 0.5f + (((float)w / g_armwave_state.waves) * mod);
 3441              		.loc 1 536 39 is_stmt 0 view .LVU898
 3442 0f38 382095E5 		ldr	r2, [r5, #56]	@ prephitmp_120, g_armwave_state.waves
 3443              	@ armwave.c:536:         for(w = 0; w < g_armwave_state.waves; w++) {
 536:armwave.c     ****             //mod_val = 0.5f + (((float)w / g_armwave_state.waves) * mod);
 3444              		.loc 1 536 9 view .LVU899
 3445 0f3c 000052E3 		cmp	r2, #0	@ prephitmp_120,
 3446 0f40 450000DA 		ble	.L203		@,
 3447              	@ armwave.c:538:             mod_val = 0.5f + (_1_waves_mod * w);
 538:armwave.c     **** 
 3448              		.loc 1 538 21 view .LVU900
 3449 0f44 53CADFED 		vldr.32	s25, .L230+8	@ tmp200,
 3450              	@ armwave.c:552:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 552:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 3451              		.loc 1 552 33 view .LVU901
 3452 0f48 53BA9FED 		vldr.32	s22, .L230+12	@ tmp253,
 3453              	@ armwave.c:550:                 xnoise = (rand() & 0xffff) / 6553500.0f;
 550:armwave.c     **** 
 3454              		.loc 1 550 24 view .LVU902
 3455 0f4c 53AADFED 		vldr.32	s21, .L230+16	@ tmp254,
 3456 0f50 4C3095E5 		ldr	r3, [r5, #76]	@ prephitmp_124, g_armwave_state.wave_length
 3457              	@ armwave.c:536:         for(w = 0; w < g_armwave_state.waves; w++) {
 536:armwave.c     ****             //mod_val = 0.5f + (((float)w / g_armwave_state.waves) * mod);
 3458              		.loc 1 536 15 view .LVU903
 3459 0f54 0060A0E3 		mov	r6, #0	@ w,
 3460              	.LVL235:
 3461              	.L210:
 538:armwave.c     **** 
 3462              		.loc 1 538 13 is_stmt 1 view .LVU904
 3463              	@ armwave.c:538:             mod_val = 0.5f + (_1_waves_mod * w);
 538:armwave.c     **** 
 3464              		.loc 1 538 21 is_stmt 0 view .LVU905
 3465 0f58 906A07EE 		vmov	s15, r6	@ int	@ w, w
 3466 0f5c 6C9AB0EE 		vmov.f32	s18, s25	@ mod_val, tmp200
 3467              	@ armwave.c:540:             for(x = 0; x < g_armwave_state.wave_length; x++) {
 540:armwave.c     ****                 noise  = ((rand() & 0xffff) * noise_fraction);
 3468              		.loc 1 540 13 view .LVU906
 3469 0f60 000053E3 		cmp	r3, #0	@ prephitmp_124,
 3470              	@ armwave.c:538:             mod_val = 0.5f + (_1_waves_mod * w);
 538:armwave.c     **** 
 3471              		.loc 1 538 21 view .LVU907
 3472 0f64 E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp198, w
 3473 0f68 8D9A07EE 		vmla.f32	s18, s15, s26	@ mod_val, tmp198, _1_waves_mod
 3474              	.LVL236:
 540:armwave.c     ****                 noise  = ((rand() & 0xffff) * noise_fraction);
 3475              		.loc 1 540 13 is_stmt 1 view .LVU908
 540:armwave.c     ****                 noise  = ((rand() & 0xffff) * noise_fraction);
 3476              		.loc 1 540 13 is_stmt 0 view .LVU909
 3477 0f6c 370000DA 		ble	.L204		@,
 3478 0f70 C99AB7EE 		vcvt.f64.f32	d9, s18	@ tmp249, mod_val
 3479              	@ armwave.c:555:                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_str
 3480              		.loc 1 555 113 view .LVU910
 3481 0f74 4AAA9FED 		vldr.32	s20, .L230+20	@ tmp229,
 3482 0f78 4A8ADFED 		vldr.32	s17, .L230+24	@ tmp230,
 3483              	@ armwave.c:540:             for(x = 0; x < g_armwave_state.wave_length; x++) {
 540:armwave.c     ****                 noise  = ((rand() & 0xffff) * noise_fraction);
 3484              		.loc 1 540 19 view .LVU911
 3485 0f7c 0040A0E3 		mov	r4, #0	@ x,
 3486              	.LVL237:
 3487              	.L209:
 541:armwave.c     ****                 noise *= noise;
 3488              		.loc 1 541 17 is_stmt 1 view .LVU912
 3489              	@ armwave.c:541:                 noise  = ((rand() & 0xffff) * noise_fraction);
 541:armwave.c     ****                 noise *= noise;
 3490              		.loc 1 541 28 is_stmt 0 view .LVU913
 3491 0f80 FEFFFFEB 		bl	rand		@
 3492              	.LVL238:
 3493              	@ armwave.c:541:                 noise  = ((rand() & 0xffff) * noise_fraction);
 541:armwave.c     ****                 noise *= noise;
 3494              		.loc 1 541 35 view .LVU914
 3495 0f84 7000FFE6 		uxth	r0, r0	@ tmp201,
 3496              	@ armwave.c:541:                 noise  = ((rand() & 0xffff) * noise_fraction);
 541:armwave.c     ****                 noise *= noise;
 3497              		.loc 1 541 45 view .LVU915
 3498 0f88 900A07EE 		vmov	s15, r0	@ int	@ tmp201, tmp201
 3499 0f8c E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp203, tmp201
 3500              	@ armwave.c:541:                 noise  = ((rand() & 0xffff) * noise_fraction);
 541:armwave.c     ****                 noise *= noise;
 3501              		.loc 1 541 24 view .LVU916
 3502 0f90 AB7A67EE 		vmul.f32	s15, s15, s23	@ noise, tmp203, noise_fraction
 3503              	.LVL239:
 542:armwave.c     ****                 noise *= noise;
 3504              		.loc 1 542 17 is_stmt 1 view .LVU917
 3505              	@ armwave.c:542:                 noise *= noise;
 542:armwave.c     ****                 noise *= noise;
 3506              		.loc 1 542 23 is_stmt 0 view .LVU918
 3507 0f94 A77A67EE 		vmul.f32	s15, s15, s15	@ noise, noise, noise
 3508              	.LVL240:
 543:armwave.c     ****                 noise *= noise;
 3509              		.loc 1 543 17 is_stmt 1 view .LVU919
 3510              	@ armwave.c:543:                 noise *= noise;
 543:armwave.c     ****                 noise *= noise;
 3511              		.loc 1 543 23 is_stmt 0 view .LVU920
 3512 0f98 A77A67EE 		vmul.f32	s15, s15, s15	@ noise, noise, noise
 3513              	.LVL241:
 544:armwave.c     **** 
 3514              		.loc 1 544 17 is_stmt 1 view .LVU921
 3515              	@ armwave.c:544:                 noise *= noise;
 544:armwave.c     **** 
 3516              		.loc 1 544 23 is_stmt 0 view .LVU922
 3517 0f9c A7DA67EE 		vmul.f32	s27, s15, s15	@ noise, noise, noise
 3518              	.LVL242:
 546:armwave.c     ****                     noise = -noise;
 3519              		.loc 1 546 17 is_stmt 1 view .LVU923
 3520              	@ armwave.c:546:                 if((rand() & 0xffff) > 0x7fff)
 546:armwave.c     ****                     noise = -noise;
 3521              		.loc 1 546 21 is_stmt 0 view .LVU924
 3522 0fa0 FEFFFFEB 		bl	rand		@
 3523              	.LVL243:
 547:armwave.c     **** 
 3524              		.loc 1 547 21 is_stmt 1 view .LVU925
 3525              	@ armwave.c:546:                 if((rand() & 0xffff) > 0x7fff)
 546:armwave.c     ****                     noise = -noise;
 3526              		.loc 1 546 19 is_stmt 0 view .LVU926
 3527 0fa4 020910E3 		tst	r0, #32768	@,
 3528              	@ armwave.c:547:                     noise = -noise;
 547:armwave.c     **** 
 3529              		.loc 1 547 27 view .LVU927
 3530 0fa8 6DDAF11E 		vnegne.f32	s27, s27	@ noise, noise
 3531              	.LVL244:
 549:armwave.c     ****                 xnoise = (rand() & 0xffff) / 6553500.0f;
 3532              		.loc 1 549 17 is_stmt 1 view .LVU928
 550:armwave.c     **** 
 3533              		.loc 1 550 17 view .LVU929
 3534              	@ armwave.c:550:                 xnoise = (rand() & 0xffff) / 6553500.0f;
 550:armwave.c     **** 
 3535              		.loc 1 550 27 is_stmt 0 view .LVU930
 3536 0fac FEFFFFEB 		bl	rand		@
 3537              	.LVL245:
 552:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 3538              		.loc 1 552 17 is_stmt 1 view .LVU931
 3539              	@ armwave.c:552:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 552:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 3540              		.loc 1 552 45 is_stmt 0 view .LVU932
 3541 0fb0 137A95ED 		vldr.32	s14, [r5, #76]	@ int	@ tmp270, g_armwave_state.wave_length
 3542              	@ armwave.c:552:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 552:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 3543              		.loc 1 552 33 view .LVU933
 3544 0fb4 904A07EE 		vmov	s15, r4	@ int	@ x, x
 3545              	@ armwave.c:552:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 552:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 3546              		.loc 1 552 45 view .LVU934
 3547 0fb8 C77AB8EE 		vcvt.f32.s32	s14, s14	@ tmp206, tmp270
 3548              	@ armwave.c:552:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 552:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 3549              		.loc 1 552 33 view .LVU935
 3550 0fbc E77AF8EE 		vcvt.f32.s32	s15, s15	@ tmp210, x
 3551              	@ armwave.c:552:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 552:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 3552              		.loc 1 552 45 view .LVU936
 3553 0fc0 076AC8EE 		vdiv.f32	s13, s16, s14	@ tmp208, tmp258, tmp206
 3554              	@ armwave.c:552:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 552:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 3555              		.loc 1 552 33 view .LVU937
 3556 0fc4 8B7A67EE 		vmul.f32	s15, s15, s22	@ tmp211, tmp210, tmp253
 3557              	@ armwave.c:550:                 xnoise = (rand() & 0xffff) / 6553500.0f;
 550:armwave.c     **** 
 3558              		.loc 1 550 34 view .LVU938
 3559 0fc8 7000FFE6 		uxth	r0, r0	@ tmp214,
 3560              	.LVL246:
 3561              	@ armwave.c:550:                 xnoise = (rand() & 0xffff) / 6553500.0f;
 550:armwave.c     **** 
 3562              		.loc 1 550 44 view .LVU939
 3563 0fcc 100A07EE 		vmov	s14, r0	@ int	@ tmp214, tmp214
 3564 0fd0 C77AB8EE 		vcvt.f32.s32	s14, s14	@ tmp216, tmp214
 3565              	@ armwave.c:550:                 xnoise = (rand() & 0xffff) / 6553500.0f;
 550:armwave.c     **** 
 3566              		.loc 1 550 24 view .LVU940
 3567 0fd4 2A0A87EE 		vdiv.f32	s0, s14, s21	@ xnoise, tmp216, tmp254
 3568              	@ armwave.c:552:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 552:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 3569              		.loc 1 552 77 view .LVU941
 3570 0fd8 A70A06EE 		vmla.f32	s0, s13, s15	@ tmp219, tmp208, tmp211
 3571              	@ armwave.c:552:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 552:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 3572              		.loc 1 552 22 view .LVU942
 3573 0fdc C00AB7EE 		vcvt.f64.f32	d0, s0	@, tmp219
 3574 0fe0 FEFFFFEB 		bl	sin		@
 3575              	.LVL247:
 3576              		.loc 1 555 17 is_stmt 1 view .LVU943
 3577              	@ armwave.c:549:                 noise += 1.0f;
 549:armwave.c     ****                 xnoise = (rand() & 0xffff) / 6553500.0f;
 3578              		.loc 1 549 23 is_stmt 0 view .LVU944
 3579 0fe4 887A7DEE 		vadd.f32	s15, s27, s16	@ noise, noise, tmp258
 3580              	@ armwave.c:555:                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_str
 3581              		.loc 1 555 104 view .LVU945
 3582 0fe8 0010A0E3 		mov	r1, #0	@ iftmp.22_50,
 3583              	@ armwave.c:552:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 552:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 3584              		.loc 1 552 98 view .LVU946
 3585 0fec E77AB7EE 		vcvt.f64.f32	d7, s15	@ tmp225, noise
 3586              	@ armwave.c:552:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 552:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 3587              		.loc 1 552 87 view .LVU947
 3588 0ff0 000B29EE 		vmul.f64	d0, d9, d0	@ tmp222, tmp249,
 3589              	@ armwave.c:552:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 552:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 3590              		.loc 1 552 98 view .LVU948
 3591 0ff4 077B20EE 		vmul.f64	d7, d0, d7	@ tmp226, tmp222, tmp225
 3592              	@ armwave.c:552:                 v = (sin((6.28f * x * (1.0f / g_armwave_state.wave_length)) + xnoi
 552:armwave.c     ****                 //v = ((x & 0xff) / 128.0f) - 1.0f;
 3593              		.loc 1 552 19 view .LVU949
 3594 0ff8 C77BB7EE 		vcvt.f32.f64	s14, d7	@ v, tmp226
 3595              	@ armwave.c:555:                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_str
 3596              		.loc 1 555 113 view .LVU950
 3597 0ffc 687AF0EE 		vmov.f32	s15, s17	@ _33, tmp230
 3598 1000 0A7A47EE 		vmla.f32	s15, s14, s20	@ _33, v, tmp229
 3599 1004 C07AF5EE 		vcmpe.f32	s15, #0	@ _33
 3600 1008 10FAF1EE 		vmrs	APSR_nzcv, FPSCR
 3601 100c 050000DA 		ble	.L206		@,
 3602              	@ armwave.c:555:                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_str
 3603              		.loc 1 555 104 discriminator 1 view .LVU951
 3604 1010 CC7AF4EE 		vcmpe.f32	s15, s24	@ _33, tmp259
 3605 1014 FF10A0E3 		mov	r1, #255	@ iftmp.22_50,
 3606 1018 10FAF1EE 		vmrs	APSR_nzcv, FPSCR
 3607 101c E77AFC4E 		vcvtmi.u32.f32	s15, s15	@ tmp234, _33
 3608 1020 017ACD4D 		vstrmi.32	s15, [sp, #4]	@ int	@ tmp234, %sfp
 3609 1024 0410DD45 		ldrbmi	r1, [sp, #4]	@ zero_extendqisi2	@ iftmp.22_50, %sfp
 3610              	.L206:
 3611              	@ armwave.c:555:                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_str
 3612              		.loc 1 555 57 discriminator 12 view .LVU952
 3613 1028 342095E5 		ldr	r2, [r5, #52]	@ g_armwave_state.wave_stride, g_armwave_state.wave_stride
 3614              	@ armwave.c:555:                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_str
 3615              		.loc 1 555 102 discriminator 12 view .LVU953
 3616 102c 183095E5 		ldr	r3, [r5, #24]	@ g_armwave_state.test_wave_buffer, g_armwave_state.test_wave_buffer
 3617 1030 927622E0 		mla	r2, r2, r6, r7	@ tmp241, g_armwave_state.wave_stride, w, set_offset
 3618 1034 043083E0 		add	r3, r3, r4	@ tmp240, g_armwave_state.test_wave_buffer, x
 3619              	@ armwave.c:540:             for(x = 0; x < g_armwave_state.wave_length; x++) {
 540:armwave.c     ****                 noise  = ((rand() & 0xffff) * noise_fraction);
 3620              		.loc 1 540 58 discriminator 12 view .LVU954
 3621 1038 014084E2 		add	r4, r4, #1	@ x, x,
 3622              	.LVL248:
 3623              	@ armwave.c:555:                 g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_str
 3624              		.loc 1 555 102 discriminator 12 view .LVU955
 3625 103c 0310C2E7 		strb	r1, [r2, r3]	@ iftmp.22_50, *_40
 3626              	@ armwave.c:540:             for(x = 0; x < g_armwave_state.wave_length; x++) {
 540:armwave.c     ****                 noise  = ((rand() & 0xffff) * noise_fraction);
 3627              		.loc 1 540 43 discriminator 12 view .LVU956
 3628 1040 4C3095E5 		ldr	r3, [r5, #76]	@ prephitmp_124, g_armwave_state.wave_length
 3629              	@ armwave.c:540:             for(x = 0; x < g_armwave_state.wave_length; x++) {
 540:armwave.c     ****                 noise  = ((rand() & 0xffff) * noise_fraction);
 3630              		.loc 1 540 13 discriminator 12 view .LVU957
 3631 1044 040053E1 		cmp	r3, r4	@ prephitmp_124, x
 3632 1048 CCFFFFCA 		bgt	.L209		@,
 3633 104c 382095E5 		ldr	r2, [r5, #56]	@ prephitmp_120, g_armwave_state.waves
 3634              	.LVL249:
 3635              	.L204:
 3636              	@ armwave.c:536:         for(w = 0; w < g_armwave_state.waves; w++) {
 536:armwave.c     ****             //mod_val = 0.5f + (((float)w / g_armwave_state.waves) * mod);
 3637              		.loc 1 536 48 discriminator 2 view .LVU958
 3638 1050 016086E2 		add	r6, r6, #1	@ w, w,
 3639              	.LVL250:
 3640              	@ armwave.c:536:         for(w = 0; w < g_armwave_state.waves; w++) {
 536:armwave.c     ****             //mod_val = 0.5f + (((float)w / g_armwave_state.waves) * mod);
 3641              		.loc 1 536 9 discriminator 2 view .LVU959
 3642 1054 020056E1 		cmp	r6, r2	@ w, prephitmp_120
 3643 1058 BEFFFFBA 		blt	.L210		@,
 3644              	.LVL251:
 3645              	.L203:
 556:armwave.c     ****             }
 557:armwave.c     ****         }
 558:armwave.c     **** 
 559:armwave.c     ****         set_offset += (g_armwave_state.waves * g_armwave_state.wave_stride);
 3646              		.loc 1 559 9 is_stmt 1 discriminator 2 view .LVU960
 3647              	@ armwave.c:559:         set_offset += (g_armwave_state.waves * g_armwave_state.wave_stride);
 3648              		.loc 1 559 46 is_stmt 0 discriminator 2 view .LVU961
 3649 105c 343095E5 		ldr	r3, [r5, #52]	@ g_armwave_state.wave_stride, g_armwave_state.wave_stride
 3650              	@ armwave.c:533:     for(s = 0; s < sets; s++) {
 533:armwave.c     ****         printf("Calculating test set %d\n", s);
 3651              		.loc 1 533 27 discriminator 2 view .LVU962
 3652 1060 018088E2 		add	r8, r8, #1	@ s, s,
 3653              	.LVL252:
 3654              	@ armwave.c:533:     for(s = 0; s < sets; s++) {
 533:armwave.c     ****         printf("Calculating test set %d\n", s);
 3655              		.loc 1 533 5 discriminator 2 view .LVU963
 3656 1064 080059E1 		cmp	r9, r8	@ sets, s
 3657              	@ armwave.c:559:         set_offset += (g_armwave_state.waves * g_armwave_state.wave_stride);
 3658              		.loc 1 559 20 discriminator 2 view .LVU964
 3659 1068 937227E0 		mla	r7, r3, r2, r7	@ set_offset, g_armwave_state.wave_stride, prephitmp_120, set_offset
 3660              	.LVL253:
 3661              	@ armwave.c:533:     for(s = 0; s < sets; s++) {
 533:armwave.c     ****         printf("Calculating test set %d\n", s);
 3662              		.loc 1 533 5 discriminator 2 view .LVU965
 3663 106c AEFFFF1A 		bne	.L202		@,
 3664              	.LVL254:
 3665              	.L199:
 3666              	@ armwave.c:561: }
 560:armwave.c     ****     }
 561:armwave.c     **** }
 3667              		.loc 1 561 1 view .LVU966
 3668 1070 08D08DE2 		add	sp, sp, #8	@,,
 3669              		.cfi_remember_state
 3670              		.cfi_def_cfa_offset 80
 3671              		@ sp needed	@
 3672 1074 0C8BBDEC 		vldm	sp!, {d8-d13}	@,
 3673              		.cfi_restore 90
 3674              		.cfi_restore 91
 3675              		.cfi_restore 88
 3676              		.cfi_restore 89
 3677              		.cfi_restore 86
 3678              		.cfi_restore 87
 3679              		.cfi_restore 84
 3680              		.cfi_restore 85
 3681              		.cfi_restore 82
 3682              		.cfi_restore 83
 3683              		.cfi_restore 80
 3684              		.cfi_restore 81
 3685              		.cfi_def_cfa_offset 32
 3686              	.LVL255:
 3687              		.loc 1 561 1 view .LVU967
 3688 1078 F087BDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}	@
 3689              	.LVL256:
 3690              	.L229:
 3691              		.cfi_restore_state
 3692              	.LBB64:
 3693              	.LBB61:
 481:armwave.c     ****             g_armwave_state.wave_length * g_armwave_state.waves_max * nsets, nsets);
 3694              		.loc 1 481 9 is_stmt 1 view .LVU968
 3695 107c 940901E0 		mul	r1, r4, r9	@, _85, sets
 3696 1080 0920A0E1 		mov	r2, r9	@, sets
 3697 1084 28009FE5 		ldr	r0, .L230+36	@,
 3698 1088 FEFFFFEB 		bl	printf		@
 3699              	.LVL257:
 483:armwave.c     ****     }
 3700              		.loc 1 483 9 view .LVU969
 3701 108c 9FFFFFEA 		b	.L201		@
 3702              	.L231:
 3703              		.align	2
 3704              	.L230:
 3705 1090 0000803F 		.word	1065353216
 3706 1094 00007F43 		.word	1132396544
 3707 1098 0000003F 		.word	1056964608
 3708 109c C3F5C840 		.word	1086911939
 3709 10a0 38FFC74A 		.word	1254620984
 3710 10a4 0000FE42 		.word	1123942400
 3711 10a8 00000043 		.word	1124073472
 3712 10ac 00000000 		.word	g_armwave_state
 3713 10b0 64020000 		.word	.LC20
 3714 10b4 BC010000 		.word	.LC18
 3715              	.LBE61:
 3716              	.LBE64:
 3717              		.cfi_endproc
 3718              	.LFE75:
 3720              		.align	2
 3721              		.global	armwave_cleanup
 3722              		.syntax unified
 3723              		.arm
 3724              		.fpu vfp
 3726              	armwave_cleanup:
 3727              	.LFB76:
 562:armwave.c     **** 
 563:armwave.c     **** /*
 564:armwave.c     ****  * Make a test square waveform.
 565:armwave.c     ****  *
 566:armwave.c     ****  * @param   noise_fraction      typically 1e-6
 567:armwave.c     ****  */
 568:armwave.c     **** #if 0
 569:armwave.c     **** void armwave_test_create_square(float noise_fraction)
 570:armwave.c     **** {
 571:armwave.c     ****     uint8_t v;
 572:armwave.c     ****     float noise, xnoise;
 573:armwave.c     ****     float level = 0.8f, new_level = 0.8f;
 574:armwave.c     ****     int w, x;
 575:armwave.c     **** 
 576:armwave.c     ****     for(w = 0; w < g_armwave_state.waves; w++) {
 577:armwave.c     ****         for(x = 0; x < g_armwave_state.wave_length; x++) {
 578:armwave.c     ****             noise  = ((rand() & 0xffff) * noise_fraction);
 579:armwave.c     ****             noise *= noise;
 580:armwave.c     ****             noise *= noise;
 581:armwave.c     ****             noise *= noise;
 582:armwave.c     **** 
 583:armwave.c     ****             if((rand() & 0xff) > 0x7f)
 584:armwave.c     ****                 noise = -noise;
 585:armwave.c     **** 
 586:armwave.c     ****             //noise += 1.0f;
 587:armwave.c     **** 
 588:armwave.c     ****             if(x > (g_armwave_state.wave_length * 0.75f)) {
 589:armwave.c     ****                 new_level = 0.2f;
 590:armwave.c     ****             } else if(x > (g_armwave_state.wave_length * 0.5f)) {
 591:armwave.c     ****                 new_level = 0.8f;
 592:armwave.c     ****             } else if(x > (g_armwave_state.wave_length * 0.25f)) {
 593:armwave.c     ****                 new_level = 0.2f;
 594:armwave.c     ****             } else {
 595:armwave.c     ****                 new_level = 0.8f;
 596:armwave.c     ****             }
 597:armwave.c     **** 
 598:armwave.c     ****             level = ((level * 3) + new_level) * 0.25f;
 599:armwave.c     **** 
 600:armwave.c     ****             v = (uint8_t)(CLAMP(level + noise, 0.0f, 1.0f) * 255);
 601:armwave.c     ****             g_armwave_state.test_wave_buffer[x + (w * g_armwave_state.wave_stride)] = v;
 602:armwave.c     ****         }
 603:armwave.c     ****     }
 604:armwave.c     **** }
 605:armwave.c     **** #endif
 606:armwave.c     **** 
 607:armwave.c     **** /*
 608:armwave.c     ****  * Free all buffers and set to NULL, ready to be reinitialised or stopped.
 609:armwave.c     ****  */
 610:armwave.c     **** void armwave_cleanup()
 611:armwave.c     **** {
 3728              		.loc 1 611 1 view -0
 3729              		.cfi_startproc
 3730              		@ args = 0, pretend = 0, frame = 0
 3731              		@ frame_needed = 0, uses_anonymous_args = 0
 612:armwave.c     ****     free(g_armwave_state.out_pixbuf);
 3732              		.loc 1 612 5 view .LVU971
 3733              	@ armwave.c:611: {
 611:armwave.c     ****     free(g_armwave_state.out_pixbuf);
 3734              		.loc 1 611 1 is_stmt 0 view .LVU972
 3735 10b8 10402DE9 		push	{r4, lr}	@
 3736              		.cfi_def_cfa_offset 8
 3737              		.cfi_offset 4, -8
 3738              		.cfi_offset 14, -4
 3739              	@ armwave.c:612:     free(g_armwave_state.out_pixbuf);
 3740              		.loc 1 612 25 view .LVU973
 3741 10bc 34409FE5 		ldr	r4, .L234	@ tmp114,
 3742              	@ armwave.c:612:     free(g_armwave_state.out_pixbuf);
 3743              		.loc 1 612 5 view .LVU974
 3744 10c0 680094E5 		ldr	r0, [r4, #104]	@, g_armwave_state.out_pixbuf
 3745 10c4 FEFFFFEB 		bl	free		@
 3746              	.LVL258:
 613:armwave.c     ****     free(g_armwave_state.ch1_buffer);
 3747              		.loc 1 613 5 is_stmt 1 view .LVU975
 3748 10c8 040094E5 		ldr	r0, [r4, #4]	@, g_armwave_state.ch1_buffer
 3749 10cc FEFFFFEB 		bl	free		@
 3750              	.LVL259:
 614:armwave.c     ****     free(g_armwave_state.xcoord_to_xpixel);
 3751              		.loc 1 614 5 view .LVU976
 3752 10d0 840094E5 		ldr	r0, [r4, #132]	@, g_armwave_state.xcoord_to_xpixel
 3753 10d4 FEFFFFEB 		bl	free		@
 3754              	.LVL260:
 615:armwave.c     ****     free(g_armwave_state.test_wave_buffer);
 3755              		.loc 1 615 5 view .LVU977
 3756 10d8 180094E5 		ldr	r0, [r4, #24]	@, g_armwave_state.test_wave_buffer
 3757 10dc FEFFFFEB 		bl	free		@
 3758              	.LVL261:
 616:armwave.c     **** 
 617:armwave.c     ****     g_armwave_state.out_pixbuf = NULL;
 3759              		.loc 1 617 5 view .LVU978
 3760              	@ armwave.c:617:     g_armwave_state.out_pixbuf = NULL;
 3761              		.loc 1 617 32 is_stmt 0 view .LVU979
 3762 10e0 0030A0E3 		mov	r3, #0	@ tmp123,
 3763 10e4 683084E5 		str	r3, [r4, #104]	@ tmp123, g_armwave_state.out_pixbuf
 618:armwave.c     ****     g_armwave_state.ch1_buffer = NULL;
 3764              		.loc 1 618 5 is_stmt 1 view .LVU980
 3765              	@ armwave.c:618:     g_armwave_state.ch1_buffer = NULL;
 3766              		.loc 1 618 32 is_stmt 0 view .LVU981
 3767 10e8 043084E5 		str	r3, [r4, #4]	@ tmp123, g_armwave_state.ch1_buffer
 619:armwave.c     ****     g_armwave_state.xcoord_to_xpixel = NULL;
 3768              		.loc 1 619 5 is_stmt 1 view .LVU982
 3769              	@ armwave.c:619:     g_armwave_state.xcoord_to_xpixel = NULL;
 3770              		.loc 1 619 38 is_stmt 0 view .LVU983
 3771 10ec 843084E5 		str	r3, [r4, #132]	@ tmp123, g_armwave_state.xcoord_to_xpixel
 620:armwave.c     ****     g_armwave_state.test_wave_buffer = NULL;
 3772              		.loc 1 620 5 is_stmt 1 view .LVU984
 3773              	@ armwave.c:620:     g_armwave_state.test_wave_buffer = NULL;
 3774              		.loc 1 620 38 is_stmt 0 view .LVU985
 3775 10f0 183084E5 		str	r3, [r4, #24]	@ tmp123, g_armwave_state.test_wave_buffer
 3776              	@ armwave.c:621: }
 621:armwave.c     **** }
 3777              		.loc 1 621 1 view .LVU986
 3778 10f4 1080BDE8 		pop	{r4, pc}	@
 3779              	.L235:
 3780              		.align	2
 3781              	.L234:
 3782 10f8 00000000 		.word	g_armwave_state
 3783              		.cfi_endproc
 3784              	.LFE76:
 3786              		.comm	gamma_table,256,4
 3787              		.comm	g_armwave_state,136,4
 3788              		.section	.rodata
 3789              		.align	2
 3790              		.set	.LANCHOR0,. + 0
 3793              	__PRETTY_FUNCTION__.17095:
 3794 0000 61726D77 		.ascii	"armwave_fill_pixbuf_scaled\000"
 3794      6176655F 
 3794      66696C6C 
 3794      5F706978 
 3794      6275665F 
 3795 001b 00       		.space	1
 3798              	__PRETTY_FUNCTION__.17117:
 3799 001c 61726D77 		.ascii	"armwave_setup_render\000"
 3799      6176655F 
 3799      73657475 
 3799      705F7265 
 3799      6E646572 
 3800 0031 000000   		.space	3
 3803              	__PRETTY_FUNCTION__.17124:
 3804 0034 61726D77 		.ascii	"armwave_set_wave_pointer\000"
 3804      6176655F 
 3804      7365745F 
 3804      77617665 
 3804      5F706F69 
 3805 004d 000000   		.space	3
 3808              	__PRETTY_FUNCTION__.17131:
 3809 0050 61726D77 		.ascii	"armwave_set_wave_pointer_u32\000"
 3809      6176655F 
 3809      7365745F 
 3809      77617665 
 3809      5F706F69 
 3810              		.section	.rodata.str1.4,"aMS",%progbits,1
 3811              		.align	2
 3812              	.LC0:
 3813 0000 76302E30 		.ascii	"v0.0.1\000"
 3813      2E3100
 3814 0007 00       		.space	1
 3815              	.LC1:
 3816 0008 61726D77 		.ascii	"armwave version: %s\012\000"
 3816      61766520 
 3816      76657273 
 3816      696F6E3A 
 3816      2025730A 
 3817 001d 000000   		.space	3
 3818              	.LC2:
 3819 0020 61726D77 		.ascii	"armwave.c\000"
 3819      6176652E 
 3819      6300
 3820 002a 0000     		.space	2
 3821              	.LC3:
 3822 002c 6F75745F 		.ascii	"out_buffer != NULL\000"
 3822      62756666 
 3822      65722021 
 3822      3D204E55 
 3822      4C4C00
 3823 003f 00       		.space	1
 3824              	.LC4:
 3825 0040 733D2564 		.ascii	"s=%d e=%d w=%d ws=%d tw=%d th=%d rf=0x%08x\012\000"
 3825      20653D25 
 3825      6420773D 
 3825      25642077 
 3825      733D2564 
 3826              	.LC5:
 3827 006c 73746172 		.ascii	"start_point < end_point\000"
 3827      745F706F 
 3827      696E7420 
 3827      3C20656E 
 3827      645F706F 
 3828              	.LC6:
 3829 0084 63685F62 		.ascii	"ch_buff_size=%d, cmp_x_bitdepth_scale=%d (0x%08x)\012"
 3829      7566665F 
 3829      73697A65 
 3829      3D25642C 
 3829      20636D70 
 3830 00b6 00       		.ascii	"\000"
 3831 00b7 00       		.space	1
 3832              	.LC7:
 3833 00b8 675F6172 		.ascii	"g_armwave_state.ch1_buffer != NULL\000"
 3833      6D776176 
 3833      655F7374 
 3833      6174652E 
 3833      6368315F 
 3834 00db 00       		.space	1
 3835              	.LC8:
 3836 00dc 675F6172 		.ascii	"g_armwave_state.xcoord_to_xpixel != NULL\000"
 3836      6D776176 
 3836      655F7374 
 3836      6174652E 
 3836      78636F6F 
 3837 0105 000000   		.space	3
 3838              	.LC9:
 3839 0108 50747273 		.ascii	"Ptrs: 0x%08x 0x%08x 0x%08x 0x%08x \012\000"
 3839      3A203078 
 3839      25303878 
 3839      20307825 
 3839      30387820 
 3840              	.LC10:
 3841 012c 77617665 		.ascii	"wave_buffer != NULL\000"
 3841      5F627566 
 3841      66657220 
 3841      213D204E 
 3841      554C4C00 
 3842              	.LC11:
 3843 0140 61726D77 		.ascii	"armwave_set_wave_pointer_as_testbuf: error, nsets e"
 3843      6176655F 
 3843      7365745F 
 3843      77617665 
 3843      5F706F69 
 3844 0173 78636565 		.ascii	"xceeded\000"
 3844      64656400 
 3845 017b 00       		.space	1
 3846              	.LC12:
 3847 017c 77617665 		.ascii	"wave_buffer_ptr != 0\000"
 3847      5F627566 
 3847      6665725F 
 3847      70747220 
 3847      213D2030 
 3848 0191 000000   		.space	3
 3849              	.LC13:
 3850 0194 776200   		.ascii	"wb\000"
 3851 0197 00       		.space	1
 3852              	.LC14:
 3853 0198 50330A00 		.ascii	"P3\012\000"
 3854              	.LC15:
 3855 019c 25642025 		.ascii	"%d %d\012\000"
 3855      640A00
 3856 01a3 00       		.space	1
 3857              	.LC16:
 3858 01a4 3235350A 		.ascii	"255\012\000"
 3858      00
 3859 01a9 000000   		.space	3
 3860              	.LC17:
 3861 01ac 25336420 		.ascii	"%3d %3d %3d\012\000"
 3861      25336420 
 3861      2533640A 
 3861      00
 3862 01b9 000000   		.space	3
 3863              	.LC18:
 3864 01bc 61726D77 		.ascii	"armwave_test_buffer_alloc: failed to allocate test "
 3864      6176655F 
 3864      74657374 
 3864      5F627566 
 3864      6665725F 
 3865 01ef 77617665 		.ascii	"wave buffer (%d bytes, %d sets)\012\000"
 3865      20627566 
 3865      66657220 
 3865      28256420 
 3865      62797465 
 3866              	.LC19:
 3867 0210 61726D77 		.ascii	"armwave_fill_pixbuf_into_pybuffer: PyObject_GetBuff"
 3867      6176655F 
 3867      66696C6C 
 3867      5F706978 
 3867      6275665F 
 3868 0243 65722829 		.ascii	"er() failed, returning PyFalse\000"
 3868      20666169 
 3868      6C65642C 
 3868      20726574 
 3868      75726E69 
 3869 0262 0000     		.space	2
 3870              	.LC20:
 3871 0264 43616C63 		.ascii	"Calculating test set %d\012\000"
 3871      756C6174 
 3871      696E6720 
 3871      74657374 
 3871      20736574 
 3872              		.text
 3873              	.Letext0:
 3874              		.file 3 "/usr/lib/gcc/arm-linux-gnueabihf/8/include/stddef.h"
 3875              		.file 4 "/usr/include/arm-linux-gnueabihf/bits/types.h"
 3876              		.file 5 "/usr/include/arm-linux-gnueabihf/bits/types/struct_FILE.h"
 3877              		.file 6 "/usr/include/arm-linux-gnueabihf/bits/types/FILE.h"
 3878              		.file 7 "/usr/include/stdio.h"
 3879              		.file 8 "/usr/include/arm-linux-gnueabihf/bits/sys_errlist.h"
 3880              		.file 9 "/usr/include/errno.h"
 3881              		.file 10 "/usr/include/arm-linux-gnueabihf/bits/stdint-intn.h"
 3882              		.file 11 "/usr/include/unistd.h"
 3883              		.file 12 "/usr/include/arm-linux-gnueabihf/bits/getopt_core.h"
 3884              		.file 13 "/usr/include/arm-linux-gnueabihf/bits/stdint-uintn.h"
 3885              		.file 14 "/usr/local/include/python3.8/pyport.h"
 3886              		.file 15 "/usr/include/math.h"
 3887              		.file 16 "/usr/include/arm-linux-gnueabihf/sys/time.h"
 3888              		.file 17 "/usr/include/time.h"
 3889              		.file 18 "/usr/local/include/python3.8/pymem.h"
 3890              		.file 19 "/usr/local/include/python3.8/cpython/object.h"
 3891              		.file 20 "/usr/local/include/python3.8/methodobject.h"
 3892              		.file 21 "/usr/local/include/python3.8/descrobject.h"
 3893              		.file 22 "/usr/local/include/python3.8/pyhash.h"
 3894              		.file 23 "/usr/local/include/python3.8/pydebug.h"
 3895              		.file 24 "/usr/local/include/python3.8/bytearrayobject.h"
 3896              		.file 25 "/usr/local/include/python3.8/bytesobject.h"
 3897              		.file 26 "/usr/local/include/python3.8/unicodeobject.h"
 3898              		.file 27 "/usr/local/include/python3.8/cpython/unicodeobject.h"
 3899              		.file 28 "/usr/local/include/python3.8/longintrepr.h"
 3900              		.file 29 "/usr/local/include/python3.8/longobject.h"
 3901              		.file 30 "/usr/local/include/python3.8/boolobject.h"
 3902              		.file 31 "/usr/local/include/python3.8/floatobject.h"
 3903              		.file 32 "/usr/local/include/python3.8/complexobject.h"
 3904              		.file 33 "/usr/local/include/python3.8/rangeobject.h"
 3905              		.file 34 "/usr/local/include/python3.8/memoryobject.h"
 3906              		.file 35 "/usr/local/include/python3.8/tupleobject.h"
 3907              		.file 36 "/usr/local/include/python3.8/listobject.h"
 3908              		.file 37 "/usr/local/include/python3.8/dictobject.h"
 3909              		.file 38 "/usr/local/include/python3.8/odictobject.h"
 3910              		.file 39 "/usr/local/include/python3.8/enumobject.h"
 3911              		.file 40 "/usr/local/include/python3.8/setobject.h"
 3912              		.file 41 "/usr/local/include/python3.8/moduleobject.h"
 3913              		.file 42 "/usr/local/include/python3.8/funcobject.h"
 3914              		.file 43 "/usr/local/include/python3.8/classobject.h"
 3915              		.file 44 "/usr/local/include/python3.8/fileobject.h"
 3916              		.file 45 "/usr/local/include/python3.8/cpython/fileobject.h"
 3917              		.file 46 "/usr/local/include/python3.8/pycapsule.h"
 3918              		.file 47 "/usr/local/include/python3.8/traceback.h"
 3919              		.file 48 "/usr/local/include/python3.8/sliceobject.h"
 3920              		.file 49 "/usr/local/include/python3.8/cellobject.h"
 3921              		.file 50 "/usr/local/include/python3.8/iterobject.h"
 3922              		.file 51 "/usr/local/include/python3.8/pystate.h"
 3923              		.file 52 "/usr/local/include/python3.8/cpython/pystate.h"
 3924              		.file 53 "/usr/local/include/python3.8/genobject.h"
 3925              		.file 54 "/usr/local/include/python3.8/weakrefobject.h"
 3926              		.file 55 "/usr/local/include/python3.8/structseq.h"
 3927              		.file 56 "/usr/local/include/python3.8/namespaceobject.h"
 3928              		.file 57 "/usr/local/include/python3.8/picklebufobject.h"
 3929              		.file 58 "/usr/local/include/python3.8/codecs.h"
 3930              		.file 59 "/usr/local/include/python3.8/pyerrors.h"
 3931              		.file 60 "/usr/local/include/python3.8/context.h"
 3932              		.file 61 "/usr/local/include/python3.8/modsupport.h"
 3933              		.file 62 "/usr/local/include/python3.8/code.h"
 3934              		.file 63 "/usr/local/include/python3.8/pythonrun.h"
 3935              		.file 64 "/usr/local/include/python3.8/ceval.h"
 3936              		.file 65 "/usr/local/include/python3.8/import.h"
 3937              		.file 66 "/usr/local/include/python3.8/bltinmodule.h"
 3938              		.file 67 "/usr/local/include/python3.8/pyctype.h"
 3939              		.file 68 "/usr/include/malloc.h"
 3940              		.file 69 "armwave.h"
 3941              		.file 70 "/usr/include/stdlib.h"
 3942              		.file 71 "/usr/local/include/python3.8/cpython/abstract.h"
 3943              		.file 72 "/usr/include/assert.h"
 3944              		.file 73 "<built-in>"
 3945              		.file 74 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h"
